<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="leii.me, iOS, Unity, Design, Game" />





  <link rel="alternate" href="/atom.xml" title="Leii's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="iOS/Unity/Design">
<meta property="og:type" content="website">
<meta property="og:title" content="Leii's Blog">
<meta property="og:url" content="http://leii.me/index.html">
<meta property="og:site_name" content="Leii's Blog">
<meta property="og:description" content="iOS/Unity/Design">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leii's Blog">
<meta name="twitter:description" content="iOS/Unity/Design">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://leii.me/"/>

  <title> Leii's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Leii's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/02/Shader笔记二/" itemprop="url">
                  Shader笔记[二]
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-02T09:19:58+08:00" content="2016-10-02">
              2016-10-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/CG/" itemprop="url" rel="index">
                    <span itemprop="name">CG</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Shader-Language"><a href="#Shader-Language" class="headerlink" title="Shader Language"></a>Shader Language</h2><p>shader language，着色语言，是基于物体本身属性和光照条件，计算每个像素点的颜色值。</p>
<p>shader language 被定义为高级语言，但是不能独立于硬件，现阶段shader language还是完全依赖于GPU架构的，在shader language之前基于图形硬件的编程只能靠汇编语言。shader language目前主流的语言有3种：基于OpenGL 的 GLSL，基于Direct3D的HLSL，还有NVIDIA公司的Cg语言。</p>
<h3 id="1-Shader-Language-原理"><a href="#1-Shader-Language-原理" class="headerlink" title="1 Shader Language 原理"></a>1 Shader Language 原理</h3><p>使用shader language 编写的程序称之为shader program着色程序，着色程序分为vertex shader program 和 fragment shader program（顶点着色与片段着色）。GPU上有可编程顶点处理器和可编程片段处理器，其中又分为多个可编程单元，分别能运行顶点程序和片段程序。顶点和片段处理器都拥有非常强大的并行计算能力,并且非常擅长于矩阵 (不高于 4 阶)计算,片段处理器还可以高速查询纹理信息(目前顶点处理器还 不行,这是顶点处理器的一个发展方向)。 </p>
<p>输入寄存器存放输入的图 元信息;输出寄存器存放处理后的图元信息;纹理 buffer 存放纹理数据,目前 大多数的可编程图形硬件只支持片段处理器处理纹理;从外部宿主程序输入的常 量放在常量寄存器中;临时寄存器存放着色程序在执行过程中产生的临时数据。 </p>
<h3 id="2-Vertex-Shader-Program-amp-Fragment-Shader-Program"><a href="#2-Vertex-Shader-Program-amp-Fragment-Shader-Program" class="headerlink" title="2 Vertex Shader Program &amp; Fragment Shader Program"></a>2 Vertex Shader Program &amp; Fragment Shader Program</h3><p>顶点着色程序从输入寄存器中提取图元信息（顶点位置、法向量、纹理坐标等），并完成顶点的空间转换、法向量空间转换、光照计算等操作，最后将计算好的数据传送到指定寄存器中；然后片段着色器从中获取纹理坐标、光照信息等数据，并根据这些信息以及从应用程序传递的纹理信息进行每个片段的颜色计算，最后将处理后的数据传递给光栅化操作模块。</p>
<p>顶点着色程序通常是和片段着色程序配合使用的，前者的输出是后者的输入，不过也可以只有顶点着色程序，这样的话就只对输入的顶点做操作，顶点内部的点则按照硬件默认的方式进行自动插值。例如, 输入一个三角面片,顶点着色程序对其进行 phong 光照计算,只计算三个顶点的 光照颜色,而三角面片内部点的颜色按照硬件默认的算法(Gourand 明暗处理或 者快速 phong 明暗处理)进行插值,如果图形硬件比较先进,默认的处理算法较 好(快速 phong 明暗处理),则效果也会较好;如果图形硬件使用 Gourand 明暗 处理算法,则会出现马赫带效应(条带化)。 </p>
<p>而片段着色程序是对没个片段进行独立的颜色计算，并且算法自己编写，不但可控性好，而且可以达到很多自定义的效果。</p>
<p>顶点着色程序主要进行几何方面的运算，而片段着色程序主要针对最终的颜色值进行计算。<br>片段着色程序还有一个突出的特点是：检索纹理的能力。对于GPU来说，纹理等价于数组，这意味着，如果要做通用计算,例如数组排序、字符串检索等，就必须使用到片段着色程序。 </p>
<blockquote>
<p> 什么是片断?片断和像素有什么不一样?所谓片断就是所有的三维顶点 在光栅化之后的数据集合,这些数据还没有经过深度值比较,而屏幕显示的像素 都是经过深度比较的。 </p>
</blockquote>
<h3 id="3-3种Shader-Language-比较"><a href="#3-3种Shader-Language-比较" class="headerlink" title="3 3种Shader Language 比较"></a>3 3种Shader Language 比较</h3><p>目前有3种主流的着色器语言：基于OpenGL 的GLSL，基于Direct3D的HLSL(High Level Shading Language)，还有NVIDIA公司的Cg (C for Graphic)语言。</p>
<p>GLSL 与 HLSL 分别提基于 OpenGL 和 Direct3D 的接口,两者不能混用 ,Cg 可以被 OpenGL 和 Direct3D 支持。 Cg 语言和 OpenGL、DirectX 并不是同一层次的语言,而是 OpenGL 和 DirectX 的上层 。Unity shader 所使用的语言是Gg语言。</p>
<p>Cg 语言通常采用动态编译的方式,即,在宿主程序运行时利用 Cg 运行库( Cg Runtime library)动态编译 Cg 代码,使用动态编译的方式,可以将 Cg 程序当作一 个脚本,随时修改随时运行,节省大量的时间 </p>
<p>Cg 程序的编译不但依赖于宿主程序所使用的三维编程接口,而且依赖于图 形硬件环境,因为图形硬件自身的限制,不一定支持某种 Cg 语句,例如,如果 你所使用的 GPU 并不支持循环控制指令,那么在 Cg 程序中编写的循环控制语 句将无法通过编译。被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集,被称 为 Cg Profiles。需要注意的是: profile 分为顶点程序的 profile 和片段程序的 profile,这是因为顶点着色器和片段着色器原本就不是工作在同一个硬件。 </p>
<p>一个Cg profile 定义了一个“被特定图形硬件或API所支持的Cg 语言子集”，</p>
<h3 id="4-CG-语言基础"><a href="#4-CG-语言基础" class="headerlink" title="4 CG 语言基础"></a>4 CG 语言基础</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><p>7种常见的基本数据类型：float 、half、 int、 fixed、 bool、 sampler *(纹理对象的句柄)、string</p>
<p>内置的向量数据类型：float4、bool4等，表示float或bool类型的4元向量，向量最长不能超过4元，即可以声明float1、float3但是写 float5 array 就会编译错误。向量初始化方式一般为：</p>
<pre><code>float4 array = float4(1.0, 2.0, 3.0, 4.0);
</code></pre><p>还可以使用短的构建长的向量：</p>
<pre><code>float2 a = float2(1.0, 2.0);
float4 b = float4(a, 1.0, 2.0);    
</code></pre><p>Cg还提供了矩阵数据类型，最大维数不超过4*4。如：</p>
<pre><code>float1x1 matrix1;//等价于 float matirx 1; x 是字符,并不是乘号! 
float2x3 matrix2;// 表示 2*3 阶矩阵,包含 6 个 float 类型数据 
float4x2 mat3;// 表示 4*2 阶矩阵,包含 8 个 float 类型数据 
</code></pre><blockquote>
<p>注意:Cg 中向量、矩阵与数组是完全不同,向量和矩阵是内置的数据类型 (矩阵基于向量),而数组则是一种数据结构,不是内置数据类型!这一点和 C\C++中不太一样,在 C\C++中,这三者同属于数据结构,数组可以构建向量和 矩阵。 </p>
</blockquote>
<h4 id="4-2-数组与结构体"><a href="#4-2-数组与结构体" class="headerlink" title="4.2 数组与结构体"></a>4.2 数组与结构体</h4><p>着色程序中，数组通常的使用目的是:作为从外部应用程序传入大量参数 到 Cg 的顶点程序中的形参接口,例如与皮肤形变相关的矩阵数组,或者光照参 数数组等。 </p>
<p>进行数组变量声明时,一定要指定数组长度,除非是作为函数参数而声明的 形参数组。并且在当前的 profiles 中,数组的长度和所引用的数组元素的地址必 须在编译时就知道。 </p>
<p>Cg语言支持结构体(structure),实际上Cg中的结构体的声明、使用和C++ 非常类似(只是类似,不是相同)。一个结构体相当于一种数据类型,可以定义 该类型的变量。引入结构体机制,赋予了 Cg 语言一丝面向对象的色彩。还记得 C++中,结构体与类的区别吗?没有区别,除了默认访问属性在结构体中为 public,类中为 private,所以结构体与类是非常近似的,由此可以看出 shader 语 言的发展趋势还是向着具有面向对象特性的高级语言。不过目前的 Cg 语言中的结构体以展现“封装”功能为主,并不支持继承机制。 </p>
<p>一般来说,Cg 的源代码都会在文件首部定义二个结构体,分别用于定义输人 和输出的类型,这二个结构体定义与普通的 C 结构定义不同,除了定义结构体 成员的数据类型外,还定义了该成员的绑定语义类型( Binding Semantics),所谓 绑定语义类型是为了与宿主环境进行数据交换的时候识别不同数据类型的。目前 Cg 支持的绑定语义类型包括 POSTION 位置),COLOR(颜色),NORMAL(法向 量),Texcoord(纹理坐标)等类型。 </p>
<h4 id="4-3-CG表达式与控制语句"><a href="#4-3-CG表达式与控制语句" class="headerlink" title="4.3 CG表达式与控制语句"></a>4.3 CG表达式与控制语句</h4><p>cg的操作符与C类似，其中有</p>
<pre><code>关系操作符：&lt; != &lt;= ==等
逻辑操作符：&amp;&amp; || !等
数学操作符：++ *= % 等
移位操作符： &gt;&gt; &lt;&lt;
</code></pre><p>除此之外还有比较特殊的swizzle 操作符（.）将一个向量的成员取出组成一根新的向量，如<br>    float4(a, b, c, d).xyz  等价于 float3(a, b, c)<br>    float4(a, b, c, d).xyy  等价于 float3(a, b, b)<br>    float4(a, b, c, d).wzyx  等价于 float4(d, c, b, a) </p>
<blockquote>
<p>注意:swizzle操作符只能对结构体和向量使用,不能对数组使用 </p>
</blockquote>
<p>Cg中的控制流语句和 循环语句与C语言类似:条件语句有:if、if-else;循环语句有:while、for。break 语句可以和在for语句中使用。 </p>
<h4 id="4-4-输入-输出"><a href="#4-4-输入-输出" class="headerlink" title="4.4 输入\输出"></a>4.4 输入\输出</h4><p>Cg的关键字大多数是和C/C++一样，比如int float，不过它也有独特的关键字，这些关键字用于指定输入图元的数据含义（位置信息、法向量信息等），本质上也对应着图元数据存放的硬件资源（寄存器或者纹理），称之为语义词（Semantics），通常也根据其用法称之为绑定语义词(binding semantics)。 </p>
<p>除语义词外,Cg 中还提供了三个关键字,in、out、inout,用于表示函数的 输入参数的传递方式,称为输入\输出关键字,这组关键字可以和语义词合用表 达硬件上不同的存储位置,即同一个语义词,使用 in 关键字修辞和 out 关键词修 辞,表示的图形硬件上不同的寄存器。 </p>
<p>Cg 语言还提供两个修辞符:uniform,用于指定变量的数据初始化方式;const 关键字的含义与 C\C++中相同,表示被修辞变量为常量变量。 </p>
<p>Cg 语言将输入数据流分为两类 </p>
<p>1，Varying inputs,即数据流输入图元信息的各种组成要素。从应用程序输入 到 GPU 的数据除了顶点位置数据,还有顶点的法向量数据,纹理坐标数据 等。Cg 语言提供了一组语义词,用以表明参数是由顶点的哪些数据初始化 的。 </p>
<p>2，Uniform inputs,表示一些与三维渲染有关的离散信息数据,这些数据通 常由应用程序传入,并通常不会随着图元信息的变化而变化,如材质对光的 反射信息、运动矩阵等。Uniform 修辞一个参数,表示该参数的值由外部应 用程序初始化并传入;例如在参数列表中写: </p>
<p>输入\输出修辞符  in\out\inout  分别表示修辞一个形参只是用于输入 ，修辞一个形参只是用于输出的 以及修辞一个形参既用于输入也用于输出,这是典型的引用传递。 也可以使用 return 语句来代替 out 修辞符的使用。输入\输出修辞符通常和语义词一起使用,表示顶点着色程序和片段着色程序的输入输出。</p>
<h4 id="4-5-语义词-Semantic-与语义绑定-Binding-Semantics"><a href="#4-5-语义词-Semantic-与语义绑定-Binding-Semantics" class="headerlink" title="4.5 语义词(Semantic)与语义绑定(Binding Semantics)"></a>4.5 语义词(Semantic)与语义绑定(Binding Semantics)</h4><p>语义概念的提出和图形流水线工作机制大有关系。从前面所讲的 GPU 处理 流程中可以看出，一个阶段处理数据，然后传输给下一个阶段，那么每个阶段之 间的接口是如何确定的呢?例如：顶点处理器的输入数据是处于模型空间的顶点 数据(位置、法向量)，输出的是投影坐标和光照颜色，片段处理器要将光照颜 色做为输入，问题是“片段处理器怎么知道光照颜色值的存放位置”?<br>在高级语言中(C/C++)，数据从接口的一端流向另一端,是因为提供了数 据存放的内存位置(通常是指针信息)，由于 Cg 语言并不支持指针机制,且图 形硬件处理过程中,数据通常暂存在寄存器中，故而在 Cg 语言中，通过引入语 义绑定(binding semantics)机制，指定数据存放的位置,实际上就是将输入\输 出数据和寄存器做一个映射关系(在 OpenGL Cg profiles 中是这样的,但在 DirectX-based Cg profiles 中则并没有这种映射关系)。根据输入语义,图形处理 器从某个寄存器取数据，然后再将处理好的数据,根据输出语义,放到指定的寄存器。 </p>
<p>常用的语义词有：POSITION NORMAL BINORMAL BLENDINDICES TEXCOORD0- TEXCOORD7    PSIZE TANGENT BLENDWEIGHT </p>
<p>如： in float4 modelPos: POSITION 表示该参数的数据是顶点位置坐标（通常位于模型空间），属于输入参数，语义词POSITION是输入语义，如果在OpenGL中则对应为接受应用程序传递的顶点数据的寄存器。</p>
<p>顶点着色程序必须声明一个输出变量并绑定POSITION语义词，该变量中 的数据将被用于,且只被用于光栅化 。<br>为了保持顶点程序输出语义和片段程序输入语义的一致性,通常使用相同的 struct类型数据作为两者之间的传递,这是一种非常方便的写法,推荐使用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct VertexIn &#123;</div><div class="line">	float4 position : 	POSITION;</div><div class="line">	float4 normal : NORMAL;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct VertexScreen &#123;</div><div class="line">	float4 oPosition : POSITION;</div><div class="line">	float4 objectPos : TEXCOORD0;</div><div class="line">	float4 objectNormal : TEXCOORD1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>【待续……】</p>
<hr>
<p>参考：GPU编程与CG语言之阳春白雪与下里巴人</p>
<p>计算机图形学</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/01/Shader笔记一/" itemprop="url">
                  Shader笔记[一]
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-01T08:03:29+08:00" content="2016-10-01">
              2016-10-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/CG/" itemprop="url" rel="index">
                    <span itemprop="name">CG</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>计算机图形学是我们大学专业的必修课，因为是系主任亲自教的当时学的还挺认真的，然而在大学里课程与实践应用脱节比较大，不能学以致用，导致学完忘的也快，直到毕业后发现在游戏开发、以及美图视频类APP中都有很广的应用，又重新翻出课本去看，最近比较空写笔记总结一下。本着要知其然并知其所以然的精神从GPU的历史开始：</p>
</blockquote>
<p>Graphics Processing Unit 是70年代末被提出来，用作图片的合成，80年代末，基于数字信号处理芯片（digital signal processor chip）的GPU研发出来，91年，研制出第一个单芯片2D加速器，98年NVIDIA公司研发modern GPU。 </p>
<p>Modern GPU的发展：</p>
<pre><code>1998，第一代诞生，可以独立于CPU进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三维顶点的空间坐标变换能力，这时的GPU只能用于纹理组合的数学运算或者像素颜色值的计算。
1999-2000，第二代modern GPU，可以进行三维坐标转换和光照计算，并且OpenGL和directX7都提供了开发接口，支持应用程序使用硬件的坐标变换。在此之前只有高级工作站的图形硬件才能支持快速的顶点变换。同时，这一阶段对纹理的操作已经扩展到了立方体纹理。
2001，第三代出现，提供了vertex programmability（可顶点编程）。
2002-2003，第四代modern GPU，代表如NVIDIA 的 GeForce FX和ATI Radeon 9700，都支持vertex programmability和fragment programmability，同时 DirectX 和 OpenGL 也扩展了 自身的 API,用以支持 vertex programmability 和 fragment programmability。 
</code></pre><p>目前最新GPU已经具备如下功能:</p>
<ul>
<li>支持 vertex programmability 和 fragment programmability</li>
<li>支持 IEEE32 位浮点运算</li>
<li>支持 4 元向量,4 阶矩阵计算</li>
<li>提供分支指令,支持循环控制语句</li>
<li>具有高带宽的内存传输能力(&gt;27.1GB/s)</li>
<li>支持 1D、2D、3D 纹理像素查询和使用,且速度极快</li>
<li>支持绘制到纹理功能(Render to Texture,RTT)</li>
</ul>
<p>（其中说了3遍的vertex programmability 和 fragment programmability是本文主线）<br>GPU采用流式并行计算模式，可对每个数据独立计算，但是在依赖其他数据的运算不如CPU。</p>
<h2 id="GPU绘制管线"><a href="#GPU绘制管线" class="headerlink" title="GPU绘制管线"></a>GPU绘制管线</h2><p>图形绘制管线分为3个主要阶段：应用程序阶段、几何阶段、光栅阶段。</p>
<h3 id="1，应用程序阶段"><a href="#1，应用程序阶段" class="headerlink" title="1，应用程序阶段"></a>1，应用程序阶段</h3><p>主要用高级编程语言开发，与CPU内存打交道，如碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段执行。该阶段的末端，几何体数据（顶点坐标、法向量、纹理坐标、纹理等）通过数据总线传到图形硬件。数据总线是一个可以共享的通道，用于多个设备之间传送数据，端口是在两个设备之间传送 数据的通道;带宽用来描述端口或者总线上的吞吐量,可以用每秒字节(b/s) 来度量,数据总线和端口(如加速图形端口,Accelerated Graphic Port,AGP)将 不同的功能模块“粘接”在一起。由于端口和数据总线均具有数据传输能力,因此 通常也将端口认为是数据总线。</p>
<h3 id="2，几何阶段"><a href="#2，几何阶段" class="headerlink" title="2，几何阶段"></a>2，几何阶段</h3><p>这个阶段的主要工作是“变换三维顶点坐标”和“光照计算”，显卡信息中通常会有一个表示“T&amp;L”的硬件部分，即“Transform&amp;Lighting”。</p>
<blockquote>
<p>输入计算机的是一系列三维坐标点，GPU会帮我们转换为二维屏幕上的点，达到“跃然纸面”的效果。<br>坐标类型有以下几种：Object Space 模型坐标空间，World Space 世界坐标空间，Eye Space 观察坐标空间，Clip and Project Space 屏幕坐标空间。<br>转换顺序为：CPU[3D APP or Game -&gt; 3D API(OpenGL/DirectX)] -&gt; GPU[Object Coordinates -&gt; World Coordinates -&gt; Eye Coordinates -&gt; Clip and Project Coordinates]</p>
</blockquote>
<h4 id="2-1-Object-Space-gt-World-Space"><a href="#2-1-Object-Space-gt-World-Space" class="headerlink" title="2.1 Object Space -&gt; World Space"></a>2.1 Object Space -&gt; World Space</h4><p>object space coordinates 是模型文件中的顶点值，建模时得到的，如3DMAX导出的.max文件就包含模型空间坐标，它与其他物体没有任何参照关系（与world space coordinate的主要区别），当模型导入计算机后会给它一个相对坐标原点的位置，这个过程就是模型空间坐标转换为世界空间坐标，由一个四阶矩阵控制，通常称之为world matrix。 (光照计算通常是在世界坐标空间中进行的)</p>
<h4 id="2-2-World-Space-gt-Eye-Space"><a href="#2-2-World-Space-gt-Eye-Space" class="headerlink" title="2.2 World Space -&gt; Eye Space"></a>2.2 World Space -&gt; Eye Space</h4><p>3D游戏中屏幕显示的内容随着视点的变化而变化，是因为GPU将物体顶点坐标从world space 转换为 eye space。eye space 即以camera为原点，由视线方向、视角和远近平面组成的一个梯形的三维空间，称之为viewing frustum视锥，超出这个梯形体的场景数据会被去除 frustum culling 视锥裁剪。</p>
<h4 id="2-3-Eye-Space-gt-Project-and-clip-Space"><a href="#2-3-Eye-Space-gt-Project-and-clip-Space" class="headerlink" title="2.3 Eye Space -&gt; Project and clip Space"></a>2.3 Eye Space -&gt; Project and clip Space</h4><p>转变为屏幕坐标的过程主要为下面3步：</p>
<p>1，用透视变化矩阵把顶点从视锥中变换到裁剪空间的CVV（规范立方体）</p>
<p>2，在CVV中进行图元裁剪</p>
<p>3，屏幕映射：将经过前述过程得到的坐标映射到屏幕坐标系上。<br>    （把顶点从view frustum不规则图形投影到CVV这个过程称为投影，投影分平行投影和透视投影） </p>
<p>Primitive Assembly，图元装配，即将顶点根据原始的连接关系，还原出网格结构，网格由顶点和索引组成,在之前的流水线中是对顶点的处理, 在这个阶段是根据索引将顶点链接在一起,组成线、面单元。之后就是对超出屏 幕外的三角形进行裁剪,想象一下:一个三角形其中一个顶点在画面外,另外两 个顶点在画面内,这是我们在屏幕上看到的就是一个四边形。然后将该四边形切 成两个小的三角形。 此外还有一个操作涉及到三角形的顶点顺序(其实也就是三角形的法向量朝 向),根据右手定则来决定三角面片的法向量,如果该法向量朝向视点(法向量 与到视点的方向的点积为正),则该面是正面。一般是顶点按照逆时针排列。如 果该面是反面,则进行背面去除操作(Back-face Culling)。在 OpenGL 中有专门 的函数 enable 和 disable 背面去除操作。所有的裁剪剔除计算都是为了减少需要 绘制的顶点个数。 </p>
<p>处理三角形的过程被称为 Triangle Setup。到目前位置,我们得到了一堆在 屏幕坐标上的三角面片,这些面片是用于做光栅化的(Rasterizing)。 </p>
<h3 id="3，光栅化阶段"><a href="#3，光栅化阶段" class="headerlink" title="3，光栅化阶段"></a>3，光栅化阶段</h3><h4 id="3-1-光栅化"><a href="#3-1-光栅化" class="headerlink" title="3.1 光栅化:"></a>3.1 光栅化:</h4><p>决定哪些像素被集合图元覆盖的过程(Rasterization is the process of determining the set of pixels covered by a geometric primitive)。经过上面诸多坐标 转换之后,现在我们得到了每个点的屏幕坐标值(Screen coordinate),也知道我 们需要绘制的图元(点、线、面)。但此时还存在两个问题：</p>
<p>问题一:点的屏幕坐标值是浮点数,但像素都是由整数点来表示的,如果确 定屏幕坐标值所对应的像素? </p>
<p>问题二:在屏幕上需要绘制的有点、线、面,如何根据两个已经确定位置的 2 个像素点绘制一条线段,如果根据已经确定了位置的 3 个像素点绘制一个三角 形面片? </p>
<p>答：问题一，四舍五入，例如,一条线段的位置是(10.48,20.51),转换为像<br>素位置则是(10,21) 。</p>
<p>问题二，涉及到画线算法和区域图元填充算法，通常的画线算法有DDA算法和Bresenham画线算法。区域图元算法填充有扫描线多边形填充算法和边界填充算法。</p>
<p>这个过程结束之后，顶点以及绘制图元（线、面）已经对应到像素，接下来要做的就是处理像素：给像素赋予颜色值。</p>
<h4 id="3-2-像素处理"><a href="#3-2-像素处理" class="headerlink" title="3.2 像素处理"></a>3.2 像素处理</h4><p>Pixel operation又称为Raster operation，是在更新帧缓存之前执行的最后一系列针对每个片段的操作，目的是计算每个像素的颜色值，被遮挡面通过一个被称为深度测试的过程而消除掉。主要有以下过程：</p>
<p>1，消除遮挡面。</p>
<p>2，纹理操作，也就是根据像素的纹理坐标，查询相应的纹理值。</p>
<p>3，Blending 混色，根据已经画好的颜色，计算透明度混合为新的颜色输出，称之为alpha混合，为了绘制透明的物体，需要对物体进行排序：首先绘制不透明的物体，然后再不透明的物体上方对透明物体按照又后到前的顺序进行混合处理。排序会用到z buffer 。</p>
<p>4，Filering(滤镜)，再将颜色通过某种滤镜运算载输出新的颜色值。</p>
<h3 id="4，图形硬件"><a href="#4，图形硬件" class="headerlink" title="4，图形硬件"></a>4，图形硬件</h3><p>主要介绍GPU中数据的存放硬件，以及各类缓冲区的具体含义和用途，如：z buffer（深度缓冲区）、stencil buffer（模板缓冲区）、frame buffer （帧缓冲区）和color buffer（颜色缓冲区）</p>
<h4 id="4-1-寄存器"><a href="#4-1-寄存器" class="headerlink" title="4.1 寄存器"></a>4.1 寄存器</h4><p>内存能单独存在而寄存器不能，寄存器是有限存储容量的高速存储，用来暂存指令、数据和地址。shader编程是基于计算机硬件的，包括GPU上的寄存器类型，glsl和hlsl的着色虚拟机版本就是就是基于GPU的寄存器和指令集而区分的。</p>
<h4 id="4-2-Z-Buffer-与Z-值"><a href="#4-2-Z-Buffer-与Z-值" class="headerlink" title="4.2 Z Buffer 与Z 值"></a>4.2 Z Buffer 与Z 值</h4><p>又称深度缓冲区，放的是视点到每个像素点的距离，Z值在【0，1】区间，默认最接近眼睛的顶点Z值是0.0，远裁剪面上的顶点Z值是1.0，使用 z buffer可以用来判断空间点的遮挡关系，Z 值并非真正的笛卡儿空间坐标系中的欧几里德距离(Euclidean distance), 而是一种“顶点到视点距离”的相对度量。 </p>
<p>投影到屏幕坐标的图元内部的点是由已知顶点信息插值而来，所以内部的点的Z值也是插值而来，而透视投影的点做线性插值不符合实际的位置，应该是随着点原来的位置离眼睛越远则偏差越大，为了避免或减轻上述的情况,在设置视点相机远裁减面和近裁减面时,两者 的比值应尽量小于 1000。 </p>
<h4 id="4-3-Stencil-Buffer"><a href="#4-3-Stencil-Buffer" class="headerlink" title="4.3 Stencil Buffer"></a>4.3 Stencil Buffer</h4><p>模板缓冲区，是一个额外的buffer，通常附加到z buffer中，Z buffer 和 stencil buffer 通常在 显存中共享同一片区域。Stencil buffer 对大部分人而言应该比较陌生，这是一个 用来“做记号”的 buffer，每个像素对应一个 stencil buffer(其实就是对应一个 Z buffer)。例如：在一个像素的 stencil buffer 中存放 1，表示该像素对应的空间点处于阴影体(shadow volume)中。 </p>
<h4 id="4-4-Frame-Buffer"><a href="#4-4-Frame-Buffer" class="headerlink" title="4.4 Frame Buffer"></a>4.4 Frame Buffer</h4><p>帧缓冲区，用于存放显示输出的数据，这个buffer的数据一般是像素颜色值。有时候也被认为是color buffer与 z buffer的组合。frame buffer 通常都在显卡上,但是有时显卡会集成到主板上,所以这种情况下 frame buffer 被放在内存区域(general main memory)。</p>
<hr>
<p>参考：GPU编程与CG语言之阳春白雪与下里巴人<br>     计算机图形学</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/开发手游与开发APP的几点区别/" itemprop="url">
                  开发手游与开发APP的几点区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-29T00:21:31+08:00" content="2016-09-29">
              2016-09-29
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从高中自己做的FLASH小游戏到现在全职做iOS应用的开发，在游戏和应用上都做过了很多尝试，挖过了各种坑，游戏方面的坑有：拼图游戏、射击游戏、基于物理引擎的游戏、消方块类游戏、SLG游戏、赛车游戏等，其中用到的工具/引擎有FLASH、cocos2d-iphone、cocos2d-X、Unity3D，还有公司自己用JAVA写的安卓游戏引擎。</p>
<p>商用上架的手机应用是从2013年开始写的，到现在为止写过的类型有：股票类、漫画阅览器、类36Kr信息发布平台（一个家政O2O APP），电商类APP、LBS类APP等。</p>
<p>虽然都称不上专家，不过挖了那么久的坑也有不少体会，所以基于自己有限的经验对两者做个比较，也方便自己总结知识点：</p>
<p>1，游戏引擎与系统基础框架，目前国内主流的手机游戏引擎有cocos2d-X和Unity3D，iOS开发主要用到Cocoa框架，而安卓开发主要用到Application Framework这一层的API。</p>
<p>2，游戏引擎注重跨平台，但是不同的引擎功能上差别大；应用基础框架只限于自己的平台，但是功能上iOS安卓大同小异。苹果后来自己研发了用于游戏的API SpriteKit和SceneKit因为不能跨平台用的厂家很少。</p>
<p>3，游戏在客户端的逻辑比较重（因为要自定义很多控件和复杂的交互），应用更多的逻辑放在服务端处理</p>
<p>4，游戏本质上是娱乐产品，给用户提供是APP本身，应用是提供服务的窗口，用作信息的传递和展示</p>
<p>5，多人交互这种强联网类型的游戏主要用长连接（不过也要分具体游戏场景），应用主要是短连接</p>
<p>6，游戏的美术主要分工有：原画、UI、3D、动画、特效、交互等，应用的美术主要是UI和交互</p>
<p>7，游戏在显示层面的工作更多，经常需要用到动画库图形学等，应用在网络层面的工作更多，比如近几年hybrid大热，让native+web的开发成为标配</p>
<p>8，大部分游戏属于小团队开发，产品周期短，所以在工程化以及多人合作开发上的工具和方案都明显比应用要少，特别是Unity在协同开发问题很多，而应用的开发都有比较成熟的项目管理工具（比如iOS的CocoaPod）和组件化方案</p>
<p>9，Unity3D和cocos2d的热更新主要都是通过Lua实现，iOS主流的热修复工具是JSPatch</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/28/iOS近几个版本的主要更新点/" itemprop="url">
                  iOS近几个版本的主要更新点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-28T21:46:32+08:00" content="2016-09-28">
              2016-09-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>每个版本的iOS更新都会给开发者们带来很多想象和发挥的空间，有的功能可能创造了新的用户场景或者解决了用户诟病很久的问题，当然也有些功能不能被市场接受而无人问津（比如SpriteKit、SceneKit），因为很多成熟的APP都会兼容最近的3个版本的iOS系统，所以有的很棒的新功能出现，被大量主流APP所应用到线上需要几年的时间所以记录下之前版本的更新点以便于在做版本兼容的时候查看，本文主要整理API方面的更新</p>
</blockquote>
<h2 id="iOS10-："><a href="#iOS10-：" class="headerlink" title="iOS10 ："></a>iOS10 ：</h2><h3 id="1，SiriKit"><a href="#1，SiriKit" class="headerlink" title="1，SiriKit"></a>1，SiriKit</h3><p> 支持音频、视频、消息发送接收、搜索照片、预订行程、管理锻炼等等。</p>
<p>主要头文件入口是#import’<intents intents.h="">‘、#import ‘<intentsui intentsui.h="">‘</intentsui></intents></p>
<h3 id="2，Proactive-Suggestions"><a href="#2，Proactive-Suggestions" class="headerlink" title="2，Proactive Suggestions"></a>2，Proactive Suggestions</h3><p> 系统预先建议，头文件主要有：</p>
<p>‘<uikit uitextinputtraits.h="">‘ 输入框</uikit></p>
<p>‘<mediaplayer mpplayablecontentmanager.h="">‘ 视频类</mediaplayer></p>
<p>‘<mapkit mkdirectionsrequest.h="">‘ 地图类</mapkit></p>
<h3 id="3，User-Notifications-用户通知"><a href="#3，User-Notifications-用户通知" class="headerlink" title="3，User Notifications 用户通知"></a>3，User Notifications 用户通知</h3><p>（我在“证书与打包与APNs”这篇博文里有详细介绍）</p>
<p>头文件是’<usernotifications usernotifications.h="">‘</usernotifications></p>
<h3 id="4，Messages-新交互"><a href="#4，Messages-新交互" class="headerlink" title="4，Messages 新交互"></a>4，Messages 新交互</h3><p>Integrating with the Messages App 与系统短信 app交互，可以模拟发消息收消息，发邮件表情包等，提供了UI界面。</p>
<p>头文件入口在’<messages messages.h="">‘</messages></p>
<h3 id="5，Speech-Recognition-语音识别转文字"><a href="#5，Speech-Recognition-语音识别转文字" class="headerlink" title="5，Speech Recognition 语音识别转文字"></a>5，Speech Recognition 语音识别转文字</h3><p>头文件入口在’<speech speech.h="">‘</speech></p>
<h3 id="6，Wide-Color-宽域颜色"><a href="#6，Wide-Color-宽域颜色" class="headerlink" title="6，Wide Color 宽域颜色"></a>6，Wide Color 宽域颜色</h3><p> 大多数的 core字打头的图形框架 还有AVFoundation 都大大提高了对扩展像素和宽色域色彩空间的支持。通过图形堆栈扩展这种方式比以往支持广色域的显示设备更加容易。现在对UIKit扩展可以在sRGB的色彩空间下工作，性能更好，也可以在更广泛的色域来搭配sRGB颜色。</p>
<p>UIColor类里新增了两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);</div><div class="line">- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);</div></pre></td></tr></table></figure>
<h3 id="7，Adapting-to-the-True-Tone-Display-真彩色显示"><a href="#7，Adapting-to-the-True-Tone-Display-真彩色显示" class="headerlink" title="7，Adapting to the True Tone Display 真彩色显示"></a>7，Adapting to the True Tone Display 真彩色显示</h3><p>真彩色的显示会根据光感应器来进行自动的调节来达到特定环境下的显示与性能平衡效果。 如果需要这个功能的话需要再info.plist里配置<br>UIWhitePointAdaptivityStyle<br>共有五种选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIWhitePointAdaptivityStyleStandard 标准</div><div class="line">UIWhitePointAdaptivityStyleReading 阅读</div><div class="line">UIWhitePointAdaptivityStylePhoto 图片</div><div class="line">UIWhitePointAdaptivityStyleVideo 视频</div><div class="line">UIWhitePointAdaptivityStyleGame 游戏</div></pre></td></tr></table></figure>
<h3 id="8，App-Search-Enhancements-应用搜索增强"><a href="#8，App-Search-Enhancements-应用搜索增强" class="headerlink" title="8，App Search Enhancements 应用搜索增强"></a>8，App Search Enhancements 应用搜索增强</h3><p>应用程序内搜索，搜索传递，考虑私人差异，结果可视化。 使用CSSearchQuery类，调用Core Spotlight的api，可以让你不必自己维护自己的搜索索引，关于对搜索关键字的处理，还有考虑到不同类别差异导致搜索结果的排序都是苹果帮你处理。</p>
<p>头文件是’<corespotlight cssearchquery.h="">‘</corespotlight></p>
<h3 id="9，Widget-Enhancements-锁屏部件增强"><a href="#9，Widget-Enhancements-锁屏部件增强" class="headerlink" title="9，Widget Enhancements 锁屏部件增强"></a>9，Widget Enhancements 锁屏部件增强</h3><p>现在锁屏界面有了新的设计，建议我们废弃以前的notificationCenterVibrancyEffect 改用widgetPrimaryVibrancyEffect或者widgetSecondaryVibrancyEffect，并且窗口的小部件可以让你描述有多少东西可用，支持紧凑和扩展两种形态。</p>
<p>‘<notificationcenter notificationcenter.h="">‘ 里面有三个头文件</notificationcenter></p>
<p><img src="http://images2015.cnblogs.com/blog/717809/201606/717809-20160621170857694-1224766609.png" alt="headers"></p>
<h3 id="10，Security-and-Privacy-Enhancements-安全和保密性增强"><a href="#10，Security-and-Privacy-Enhancements-安全和保密性增强" class="headerlink" title="10，Security and Privacy Enhancements 安全和保密性增强"></a>10，Security and Privacy Enhancements 安全和保密性增强</h3><p>安全方面在iOS10中引入了更多修改和补充，具体有以下几点：<br>1.在info.plist文件新增了一个key，NSAllowsArbitraryLoadsInWebContent，允许任意web页面加载，同时苹果会用ATS保护你的app。<br>2.使用改进后的SecKey API 而不是过时的 CDSA API。<br>3.安全传输API中不再支持SSLv3， 建议你们尽快停用SHA1和3DES加密算法。<br>4.剪贴板的扩展，因为wwdc2016演示了可以跨设备复制粘贴啊，那肯定要做一些限制可见（#import <uikit uipasteboard.h="">）<br>5.这点最重要的，建议尽快适配， 所有和用户权限相关的地方必须在info.plist里配置里面包括</uikit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSBluetoothPeripheralUsageDescription</div><div class="line">NSCalendarsUsageDescription</div><div class="line">NSCameraUsageDescription</div><div class="line">NSContactsUsageDescription</div><div class="line">NSHealthShareUsageDescription</div><div class="line">NSHealthUpdateUsageDescription</div><div class="line">NSHomeKitUsageDescription</div><div class="line">NSLocationAlwaysUsageDescription</div><div class="line">NSLocationWhenInUseUsageDescription</div><div class="line">NSMicrophoneUsageDescription</div><div class="line">NSMotionUsageDescription</div><div class="line">NSPhotoLibraryUsageDescription</div><div class="line">NSRemindersUsageDescription</div><div class="line">NSSiriUsageDescription</div><div class="line">NSSpeechRecognitionUsageDescription</div><div class="line">NSVideoSubscriberAccountUsageDescription</div><div class="line">NSVoIPUsageDescription</div></pre></td></tr></table></figure>
<h3 id="11，HomeKit-再次更新"><a href="#11，HomeKit-再次更新" class="headerlink" title="11，HomeKit 再次更新"></a>11，HomeKit 再次更新</h3><p>可以使你的手机连接支持homeKit的智能硬件，（没有的话你可以使用HomeKit Accessroy Simulator来模拟home中的智能电器），Demo教程看<a href="http://www.cocoachina.com/ios/20150324/11411.html" target="_blank" rel="external">这里</a> </p>
<p><a href="https://developer.apple.com/reference/homekit?language=objc" target="_blank" rel="external">官方文档</a></p>
<h2 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h2><h3 id="1，Multitasking"><a href="#1，Multitasking" class="headerlink" title="1，Multitasking"></a>1，Multitasking</h3><p>iPad支持新的Multitasking，包括Slide Over, Split View和Picture in Picture，视频需要迁移到 AVKit 的框架</p>
<h3 id="2，XCUITest"><a href="#2，XCUITest" class="headerlink" title="2，XCUITest"></a>2，XCUITest</h3><p>XCUI 使用 Accessibility 标记来确定 view，但因为是 Apple 自家的东西，它可以自动记录你的操作流程，所以你只需要书写最后的验证部分就可以了，比其他的 UI 测试工具方便很多。</p>
<h3 id="3，Search"><a href="#3，Search" class="headerlink" title="3，Search"></a>3，Search</h3><p>主要是spotlight开放了部分api，可以搜索app中的内容。</p>
<h3 id="4，SceneKit-SpriteKit-and-Metal的更新"><a href="#4，SceneKit-SpriteKit-and-Metal的更新" class="headerlink" title="4，SceneKit, SpriteKit, and Metal的更新"></a>4，SceneKit, SpriteKit, and Metal的更新</h3><p>还有GameplayKit，ReplayKit（游戏录像），Model I/O。</p>
<h3 id="5，HomeKit，CloudKit，HealthKit-等"><a href="#5，HomeKit，CloudKit，HealthKit-等" class="headerlink" title="5，HomeKit，CloudKit，HealthKit 等"></a>5，HomeKit，CloudKit，HealthKit 等</h3><p>这几个框架的更新。</p>
<h3 id="6，Swift-2"><a href="#6，Swift-2" class="headerlink" title="6，Swift 2"></a>6，Swift 2</h3><p>更新并开源</p>
<h3 id="7，bitcode"><a href="#7，bitcode" class="headerlink" title="7，bitcode"></a>7，bitcode</h3><p>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
<h3 id="8，App-Transport-Security"><a href="#8，App-Transport-Security" class="headerlink" title="8，App Transport Security"></a>8，App Transport Security</h3><p>NSAllowsArbitraryLoads默认使用了HTTPS协议进行传输</p>
<h3 id="9，RUL-scheme"><a href="#9，RUL-scheme" class="headerlink" title="9，RUL scheme"></a>9，RUL scheme</h3><p>iOS9需要将你要在外部调用的URL scheme列为白名单，才可以完成跳转</p>
<h3 id="10，Contacts-Framework"><a href="#10，Contacts-Framework" class="headerlink" title="10，Contacts Framework"></a>10，Contacts Framework</h3><p>新增Contacts Framework，与此同时废除AddressBookUI Framework</p>
<h3 id="11，-Watch-Connectivity"><a href="#11，-Watch-Connectivity" class="headerlink" title="11， Watch Connectivity"></a>11， Watch Connectivity</h3><p>由于watchOS 2的架构变化，用来对iPhone和Watch进行双向通信</p>
<h3 id="12，Safari-Services-Framework"><a href="#12，Safari-Services-Framework" class="headerlink" title="12，Safari Services Framework"></a>12，Safari Services Framework</h3><p>可以让Safari以一个Controller的形式加载你的网页，和系统的Safari完全共享Cookie和Autofill等特性，最重要的，Safari的JavaScript引擎。在你的app需要展示一个WebView又不需要太多定制的时候，用它来替换掉你现在在用的UIWebView或者WKWebView。</p>
<h3 id="13，UIKit方面的一些提升，比如UIStackView，NSDataAsset"><a href="#13，UIKit方面的一些提升，比如UIStackView，NSDataAsset" class="headerlink" title="13，UIKit方面的一些提升，比如UIStackView，NSDataAsset"></a>13，UIKit方面的一些提升，比如UIStackView，NSDataAsset</h3><h3 id="14，Objective-C-（2015）语言的新特性："><a href="#14，Objective-C-（2015）语言的新特性：" class="headerlink" title="14，Objective-C （2015）语言的新特性："></a>14，Objective-C （2015）语言的新特性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">1、Nullability</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSArray *__nonull names;</div><div class="line">@property (nonatomic, strong, nonnull) NSarray *names;</div><div class="line"></div><div class="line">2、Lightweight Generics * 泛型</div><div class="line"></div><div class="line">NSMutableArray&lt;NSString *&gt; *names;</div><div class="line">NSMutableDictionary&lt;NSString *, NSNumber *&gt; *book;</div><div class="line">NSMutableArray&lt;ObjectType&gt; :</div><div class="line">限制数组只能装字符串，有确定的类型。可以用点语法。自定义泛型。</div><div class="line">泛型的类型可以自己定义，自定义的类添加泛型。协变性，和继承有关系。小类型（子类）-&gt;大类型（父类）__covariant 该怎么去学习。泛型好处取出不是id类型，可以用点语法。</div><div class="line"></div><div class="line">3、__kindof</div><div class="line"></div><div class="line">返回值是id的问题，错了么有警告，潜在问题。所以要写清楚类型。</div><div class="line">做SDK的时候，实现别人看不到。cell 的类型不确定，所以用id。返回不用强制转换。</div><div class="line">返回值可以是他，也可以是他的子类。不用强制转换。方便开发。</div></pre></td></tr></table></figure>
<h2 id="iOS-8"><a href="#iOS-8" class="headerlink" title="iOS 8"></a>iOS 8</h2><h3 id="1，自定义键盘"><a href="#1，自定义键盘" class="headerlink" title="1，自定义键盘"></a>1，自定义键盘</h3><p>支持第三方输入法，你可以为用户提供带有不同输入法和布局的自定义键盘。</p>
<h3 id="2，UIActionSheet-and-UIAlertView-的升级"><a href="#2，UIActionSheet-and-UIAlertView-的升级" class="headerlink" title="2，UIActionSheet and UIAlertView 的升级"></a>2，UIActionSheet and UIAlertView 的升级</h3><p>在iOS8里面，官方提供了新的类UIAlertController来替换UIActionSheet and UIAlertView。</p>
<h3 id="3，Today"><a href="#3，Today" class="headerlink" title="3，Today"></a>3，Today</h3><p>应用可在通知中心的Today视图中展示插件，快速更新或者启动任务，查看包裹寄送情况、最近的上网记录或者即时新闻。</p>
<h3 id="4，Storage-Provider"><a href="#4，Storage-Provider" class="headerlink" title="4，Storage Provider"></a>4，Storage Provider</h3><p>开发者可提供一个能被其他应用访问的文档储存位置。使用文档选择器view controller的应用可以打开由storage provider管理的文档，或者把文档移动到storage provider。</p>
<h3 id="5，touchID"><a href="#5，touchID" class="headerlink" title="5，touchID"></a>5，touchID</h3><p>你可以选择Touch ID登陆第三方应用程序，不需要输入密码，你的指纹数据是被保护的，在没有被允许的情况下别的程序是访问不到它的。</p>
<h3 id="6，分享"><a href="#6，分享" class="headerlink" title="6，分享"></a>6，分享</h3><p>通过提供更多分享选项，iOS 8允许你的应用把照片、视频、网站以及其他内容分享至社交网站或者其他实体。</p>
<h3 id="7，Custom-Actions"><a href="#7，Custom-Actions" class="headerlink" title="7，Custom Actions"></a>7，Custom Actions</h3><p>在Action页面创建自定义action按钮，以便用户给文档添加水印、更新愿望列表，或者把文本转换成不同的语言等。</p>
<h3 id="8，App-Extensions"><a href="#8，App-Extensions" class="headerlink" title="8，App Extensions"></a>8，App Extensions</h3><p>应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他app时使用该项功能。你可以开发一个应用扩展来执行某些特定的任务，用户使用该扩展后就可以在多个上下文环境中执行该任务。</p>
<h3 id="9，PhotoKit"><a href="#9，PhotoKit" class="headerlink" title="9，PhotoKit"></a>9，PhotoKit</h3><p>PhotoKit为使用照片和视频资源提供了新的API，包括由Photos app管理的iCloud Photos资产,所以你可以在“Camera roll”中直接编辑照片，无需提前导入。PhotoKit还包含一个线程安全架构用以获取、缓存缩略图和全尺寸图片，请求资产更改，遵守其他应用所做的变化，以及对资产内容进行可恢复的编辑。</p>
<h3 id="10，Manual-Camera-Controls"><a href="#10，Manual-Camera-Controls" class="headerlink" title="10，Manual Camera Controls"></a>10，Manual Camera Controls</h3><p>AVFoundation框架让拍照变得前所未有的容易。你的应用可以直接控制相机对焦、白平衡以及曝光设置等。应用程序也可以通过包围曝光 (Bracket Exposure)使用不同的曝光设置自动拍摄照片。</p>
<h3 id="11，HealthKit"><a href="#11，HealthKit" class="headerlink" title="11，HealthKit"></a>11，HealthKit</h3><p>HealthKit允许提供健康和健身服务的应用在一个地方访问共享的健康相关信息。用户的健康信息储存在一个集中的安全的地方，用户可以决定和你的应用分享哪些数据。你的应用可访问任何共享的健康相关的信息，并提供关于用户的信息，无需提供对特定健身跟踪设备的专门支持。信息可来自连接至iOS设备的设备，或者由用户手动输入。</p>
<h3 id="12，Metal"><a href="#12，Metal" class="headerlink" title="12，Metal"></a>12，Metal</h3><p>Metal可以使开发者低成本最大限度地发挥A7 GPU的性能，实现了难以令人置信的复杂图形渲染和计算任务，消除了传统图形API中的多个性能瓶颈。Metal提供了精简的API，统一的图形和着色语言以及一个基于Xcode 的工具。许多游戏引擎制造商都已经宣布支持 Metal，比如 Crytek、Unity以及Epic Games。Metal可以将应用的表现和性能带到一个新的水</p>
<hr>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/dsxniubility/p/5596973.html" target="_blank" rel="external">对iOS10新增Api的详细探究</a></p>
<p><a href="http://www.cocoachina.com/ios/20150324/11411.html" target="_blank" rel="external">HomeKit 开发指南（中文版）</a></p>
<p><a href="https://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a></p>
<p><a href="http://www.cocoachina.com/special/ios8/" target="_blank" rel="external">iOS8开发者手册</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/20/iOS上使用OpenCV/" itemprop="url">
                  [转]iOS上使用OpenCV
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-20T15:12:13+08:00" content="2016-09-20">
              2016-09-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/CG/" itemprop="url" rel="index">
                    <span itemprop="name">CG</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自<a href="https://objccn.io/issue-21-9/" target="_blank" rel="external">基于 OpenCV 的人脸识别</a></p>
<h4 id="OpenCV-概述"><a href="#OpenCV-概述" class="headerlink" title="OpenCV 概述"></a>OpenCV 概述</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>OpenCV 的 API 是 C++ 的。它由不同的模块组成，这些模块中包含范围极为广泛的各种方法，从底层的图像颜色空间转换到高层的机器学习工具。</p>
<p>OC和Swift不能直接调用OpenCV，这篇<a href="http://docs.opencv.org/2.4/doc/tutorials/ios/video_processing/video_processing.html#opencviosvideoprocessing" target="_blank" rel="external">OpenCV的iOS教程</a>讲解了把OpenCV的类的文件名后缀都改成.mm然后用Objective-C++调用的方法，但是功能好的方法是给所有你要在 app 中使用到的 OpenCV 功能写一层 Objective-C++ 封装。这些 Objective-C++ 封装把 OpenCV 的 C++ API 转化为安全的 Objective-C API，以方便地在所有 Objective-C 类中使用。</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>下面是在<a href="http://docs.opencv.org/2.4/modules/core/doc/intro.html" target="_blank" rel="external">官方文档</a>中列出的最重要的模块。</p>
<ul>
<li>core：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。</li>
<li>imgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。</li>
<li>video：视频分析模块，包括运动估计、背景消除、物体跟踪算法。</li>
<li>calib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。</li>
<li>features2d：包含了显著特征检测算法、描述算子和算子匹配算法。</li>
<li>objdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。</li>
<li>ml：多种机器学习算法，如 K 均值、支持向量机和神经网络。</li>
<li>highgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。</li>
<li>gpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。</li>
<li>ocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。<br>一些其它辅助模块，如 Python 绑定和用户贡献的算法。</li>
</ul>
<h5 id="基础类和操作"><a href="#基础类和操作" class="headerlink" title="基础类和操作"></a>基础类和操作</h5><p>OpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考<a href="http://docs.opencv.org/2.4/modules/core/doc/core.html" target="_blank" rel="external">全部文档</a>。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。</p>
<h6 id="cv-Mat"><a href="#cv-Mat" class="headerlink" title="cv::Mat"></a>cv::Mat</h6><p>cv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat 来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。</p>
<p>一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uchar *pixelPtr = cvMat.data + rowIndex * cvMat.step[0] + colIndex * cvMat.step[1]</div></pre></td></tr></table></figure>
<p>每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至 CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。</p>
<h6 id="cv-Algorithm"><a href="#cv-Algorithm" class="headerlink" title="cv::Algorithm"></a>cv::Algorithm</h6><p>Algorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。</p>
<h4 id="在-iOS-上使用-OpenCV"><a href="#在-iOS-上使用-OpenCV" class="headerlink" title="在 iOS 上使用 OpenCV"></a>在 iOS 上使用 OpenCV</h4><h5 id="添加-OpenCV-到你的工程中"><a href="#添加-OpenCV-到你的工程中" class="headerlink" title="添加 OpenCV 到你的工程中"></a>添加 OpenCV 到你的工程中</h5><p>集成 OpenCV 到你的工程中有三种方法：</p>
<p>*使用 CocoaPods 就好： pod “OpenCV”。</p>
<p>*下载官方 <a href="http://opencv.org/downloads.html" target="_blank" rel="external">iOS 框架发行包</a>，并把它添加到工程里。</p>
<p>*从 <a href="https://github.com/Itseez/opencv" target="_blank" rel="external">GitHub</a> 拉下代码，并根据<a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/ios_install/ios_install.html#ios-installation" target="_blank" rel="external">教程</a>自己编译 OpenCV 库。</p>
<h5 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C++"></a>Objective-C++</h5><p>如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。</p>
<p>Objective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为 .mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 assign。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。</p>
<p>第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 #ifdef __cplusplus 包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。</p>
<p>要获得更多如何混用 C++ 和 Objective-C 的细节，请查看 Matt Galloway 写的这篇<a href="http://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">教程</a>。</p>
<h4 id="Demo：人脸检测与识别"><a href="#Demo：人脸检测与识别" class="headerlink" title="Demo：人脸检测与识别"></a>Demo：人脸检测与识别</h4><p>现在，我们对 OpenCV 及如何把它集成到我们的应用中有了大概认识，那让我们来做一个小 demo 应用：从 iPhone 的摄像头获取视频流，对它持续进行人脸检测，并在屏幕上标出来。当用户点击一个脸孔时，应用会尝试识别这个人。如果识别结果正确，用户必须点击 “Correct”。如果识别错误，用户必须选择正确的人名来纠正错误。我们的人脸识别器就会从错误中学习，变得越来越好。</p>
<p><img src="https://objccn.io/images/issues/issue-21/blocks-face-recognition-objcio.jpg" alt="pic 1"></p>
<p>本 demo 应用的源码可从 <a href="https://github.com/objcio/issue-21-OpenCV-FaceRec" target="_blank" rel="external">GitHub</a> 获得。</p>
<h5 id="视频拍摄"><a href="#视频拍摄" class="headerlink" title="视频拍摄"></a>视频拍摄</h5><p>OpenCV 的 highgui 模块中有个类，CvVideoCamera，它把 iPhone 的摄像机抽象出来，让我们的 app 通过一个代理函数 - (void)processImage:(cv::Mat&amp;)image 来获得视频流。CvVideoCamera 实例可像下面这样进行设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CvVideoCamera *videoCamera = [[CvVideoCamera alloc] initWithParentView:view];</div><div class="line">videoCamera.defaultAVCaptureDevicePosition = AVCaptureDevicePositionFront;</div><div class="line">videoCamera.defaultAVCaptureSessionPreset = AVCaptureSessionPreset640x480;</div><div class="line">videoCamera.defaultAVCaptureVideoOrientation = AVCaptureVideoOrientationPortrait;</div><div class="line">videoCamera.defaultFPS = 30;</div><div class="line">videoCamera.grayscaleMode = NO;</div><div class="line">videoCamera.delegate = self;</div></pre></td></tr></table></figure>
<p>摄像头的帧率被设置为 30 帧每秒， 我们实现的 processImage 函数将每秒被调用 30 次。因为我们的 app 要持续不断地检测人脸，所以我们应该在这个函数里实现人脸的检测。要注意的是，如果对某一帧进行人脸检测的时间超过 1/30 秒，就会产生掉帧现象。</p>
<h5 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h5><p>其实你并不需要使用 OpenCV 来做人脸检测，因为 Core Image 已经提供了 CIDetector 类。用它来做人脸检测已经相当好了，并且它已经被优化过，使用起来也很容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CIDetector *faceDetector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:@&#123;CIDetectorAccuracy: CIDetectorAccuracyHigh&#125;];</div><div class="line"></div><div class="line">NSArray *faces = [faceDetector featuresInImage:image];</div></pre></td></tr></table></figure>
<p>从该图片中检测到的每一张面孔都在数组 faces 中保存着一个 CIFaceFeature 实例。这个实例中保存着这张面孔的所处的位置和宽高，除此之外，眼睛和嘴的位置也是可选的。</p>
<p>另一方面，OpenCV 也提供了一套物体检测功能，经过训练后能够检测出任何你需要的物体。该库为多个场景自带了可以直接拿来用的检测参数，如人脸、眼睛、嘴、身体、上半身、下半身和笑脸。检测引擎由一些非常简单的检测器的级联组成。这些检测器被称为 Haar 特征检测器，它们各自具有不同的尺度和权重。在训练阶段，决策树会通过已知的正确和错误的图片进行优化。关于训练与检测过程的详情可参考此<a href="http://www.multimedia-computing.de/mediawiki//images/5/52/MRL-TR-May02-revised-Dec02.pdf" target="_blank" rel="external">原始论文</a>。当正确的特征级联及其尺度与权重通过训练确立以后，这些参数就可被加载并初始化级联分类器了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 正面人脸检测器训练参数的文件路径</div><div class="line">NSString *faceCascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt2&quot;</div><div class="line">                                                   ofType:@&quot;xml&quot;];</div><div class="line"></div><div class="line">const CFIndex CASCADE_NAME_LEN = 2048;</div><div class="line">char *CASCADE_NAME = (char *) malloc(CASCADE_NAME_LEN);</div><div class="line">CFStringGetFileSystemRepresentation( (CFStringRef)faceCascadePath, CASCADE_NAME, CASCADE_NAME_LEN);</div><div class="line"></div><div class="line">CascadeClassifier faceDetector;</div><div class="line">faceDetector.load(CASCADE_NAME);</div></pre></td></tr></table></figure>
<p>这些参数文件可在 OpenCV 发行包里的 data/haarcascades 文件夹中找到。</p>
<p>在使用所需要的参数对人脸检测器进行初始化后，就可以用它进行人脸检测了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cv::Mat img;</div><div class="line">vector&lt;cv::Rect&gt; faceRects;</div><div class="line">double scalingFactor = 1.1;</div><div class="line">int minNeighbors = 2;</div><div class="line">int flags = 0;</div><div class="line">cv::Size minimumSize(30,30);</div><div class="line">faceDetector.detectMultiScale(img, faceRects,</div><div class="line">                              scalingFactor, minNeighbors, flags</div><div class="line">                              cv::Size(30, 30) );</div></pre></td></tr></table></figure>
<p>检测过程中，已训练好的分类器会用不同的尺度遍历输入图像的每一个像素，以检测不同大小的人脸。参数 scalingFactor 决定每次遍历分类器后尺度会变大多少倍。参数 minNeighbors 指定一个符合条件的人脸区域应该有多少个符合条件的邻居像素才被认为是一个可能的人脸区域；如果一个符合条件的人脸区域只移动了一个像素就不再触发分类器，那么这个区域非常可能并不是我们想要的结果。拥有少于 minNeighbors 个符合条件的邻居像素的人脸区域会被拒绝掉。如果 minNeighbors 被设置为 0，所有可能的人脸区域都会被返回回来。参数 flags 是 OpenCV 1.x 版本 API 的遗留物，应该始终把它设置为 0。最后，参数 minimumSize 指定我们所寻找的人脸区域大小的最小值。faceRects 向量中将会包含对 img 进行人脸识别获得的所有人脸区域。识别的人脸图像可以通过 cv::Mat 的 () 运算符提取出来，调用方式很简单：cv::Mat faceImg = img(aFaceRect)。</p>
<p>不管是使用 CIDetector 还是 OpenCV 的 CascadeClassifier，只要我们获得了至少一个人脸区域，我们就可以对图像中的人进行识别了。</p>
<h5 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h5><p>OpenCV 自带了三个人脸识别算法：Eigenfaces，Fisherfaces 和局部二值模式直方图 (LBPH)。如果你想知道它们的工作原理及相互之间的区别，请阅读 OpenCV 的<a href="http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms" target="_blank" rel="external">详细文档</a>。</p>
<p>针对于我们的 demo app，我们将采用 LBPH 算法。因为它会根据用户的输入自动更新，而不需要在每添加一个人或纠正一次出错的判断的时候都要重新进行一次彻底的训练。</p>
<p>要使用 LBPH 识别器，我们也用 Objective-C++ 把它封装起来。这个封装中暴露以下函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (FJFaceRecognizer *)faceRecognizerWithFile:(NSString *)path;</div><div class="line">- (NSString *)predict:(UIImage*)img confidence:(double *)confidence;</div><div class="line">- (void)updateWithFace:(UIImage *)img name:(NSString *)name;</div></pre></td></tr></table></figure>
<p>像下面这样用工厂方法来创建一个 LBPH 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (FJFaceRecognizer *)faceRecognizerWithFile:(NSString *)path &#123;</div><div class="line">    FJFaceRecognizer *fr = [FJFaceRecognizer new];</div><div class="line">    fr-&gt;_faceClassifier = createLBPHFaceRecognizer();</div><div class="line">    fr-&gt;_faceClassifier-&gt;load(path.UTF8String);</div><div class="line">    return fr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>预测函数可以像下面这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSString *)predict:(UIImage*)img confidence:(double *)confidence &#123;</div><div class="line">    cv::Mat src = [img cvMatRepresentationGray];</div><div class="line">    int label;</div><div class="line">    self-&gt;_faceClassifier-&gt;predict(src, label, *confidence);</div><div class="line">    return _labelsArray[label];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，我们要使用一个类别方法把 UIImage 转化为 cv::Mat。此转换本身倒是相当简单直接：使用 CGBitmapContextCreate 创建一个指向 cv::Image 中的 data 指针所指向的数据的 CGContextRef。当我们在此图形上下文中绘制此 UIImage 的时候，cv::Image 的 data 指针所指就是所需要的数据。更有趣的是，我们能对一个 Objective-C 类创建一个 Objective-C++ 的类别，并且确实管用。</p>
<p>另外，OpenCV 的人脸识别器仅支持整数标签，但是我们想使用人的名字作标签，所以我们得通过一个 NSArray 属性来对二者实现简单的转换。</p>
<p>一旦识别器给了我们一个识别出来的标签，我们把此标签给用户看，这时候就需要用户给识别器一个反馈。用户可以选择，“是的，识别正确”，也可以选择，“不，这是 Y，不是 X”。在这两种情况下，我们都可以通过人脸图像和正确的标签来更新 LBPH 模型，以提高未来识别的性能。使用用户的反馈来更新人脸识别器的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)updateWithFace:(UIImage *)img name:(NSString *)name &#123;</div><div class="line">    cv::Mat src = [img cvMatRepresentationGray];</div><div class="line">    NSInteger label = [_labelsArray indexOfObject:name];</div><div class="line">    if (label == NSNotFound) &#123;</div><div class="line">        [_labelsArray addObject:name];</div><div class="line">        label = [_labelsArray indexOfObject:name];</div><div class="line">    &#125;</div><div class="line">    vector&lt;cv::Mat&gt; images = vector&lt;cv::Mat&gt;();</div><div class="line">    images.push_back(src);</div><div class="line">    vector&lt;int&gt; labels = vector&lt;int&gt;();</div><div class="line">    labels.push_back((int)label);</div><div class="line">    self-&gt;_faceClassifier-&gt;update(images, labels);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，我们又做了一次了从 UIImage 到 cv::Mat、int 到 NSString 标签的转换。我们还得如 OpenCV 的 FaceRecognizer::update API所期望的那样，把我们的参数放到 std::vector 实例中去。</p>
<p>如此“预测，获得反馈，更新循环”，就是文献上所说的<a href="http://zh.wikipedia.org/wiki/%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92" target="_blank" rel="external">监督式学习</a>。</p>
<hr>
<p>英文原文 <a href="https://www.objc.io/issues/21-camera-and-photos/face-recognition-with-opencv/" target="_blank" rel="external"> Face Recognition with OpenCV</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/URL-Loading-System/" itemprop="url">
                  URL Loading System
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T23:55:29+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>URL Loading System的类主要有以下几种： </p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="url loading system"></p>
<p>其中最重要的3个类分别是NSURLConnection、NSURLSession、NSURLProtocol。</p>
<h5 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h5><p>NSURLConnection 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。</p>
<p>NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <nsurlconnectiondelegate> 和 <nsurlconnectiondatadelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。</nsurlconnectiondatadelegate></nsurlconnectiondelegate></p>
<p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>
<p><img src="http://images.cnitblog.com/i/450136/201406/281617337427186.png" alt="NSURLConnection Pic1"></p>
<p>下面是GET同步请求与异步请求的实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//    GET请求：请求行\请求头\请求体</div><div class="line">//</div><div class="line">//    1.设置请求路径</div><div class="line">     NSString *urlStr= [NSString stringWithFormat: @&quot;http://leii.me/login?username=%@&amp;pwd=%@&quot;,self.username.text,self.pwd.text];</div><div class="line">     NSURL *url=[NSURL URLWithString:urlStr];</div><div class="line">//    2.创建请求对象</div><div class="line">    NSURLRequest *request=[NSURLRequest requestWithURL:url];</div><div class="line">//    3.发送请求</div><div class="line">    //发送同步请求，在主线程执行</div><div class="line">    NSData *data=[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];</div><div class="line">    //（一直在等待服务器返回数据，这行代码会卡住，如果服务器没有返回数据，那么在主线程UI会卡住不能继续执行操作）</div><div class="line">    NSLog(@&quot;同步请求结果：--%d--&quot;,data.length);</div><div class="line">    </div><div class="line">    //发送异步请求</div><div class="line">    //创建一个队列（默认添加到该队列中的任务异步执行）</div><div class="line">//    NSOperationQueue *queue=[[NSOperationQueue alloc]init];</div><div class="line">    //获取一个主队列</div><div class="line">    NSOperationQueue *queue=[NSOperationQueue mainQueue];</div><div class="line">    [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;</div><div class="line">    //通过block异步获取response</div><div class="line">        NSLog(@&quot;--block异步回调数据--%@---%d&quot;, [NSThread currentThread],data.length);</div><div class="line">    &#125;）；</div></pre></td></tr></table></figure>
<p>还可以使用代理方法发送异步请求</p>
<p>要监听服务器返回的data，所以使用<nsurlconnectiondatadelegate>协议</nsurlconnectiondatadelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#pragma mark- NSURLConnectionDataDelegate代理方法</div><div class="line"></div><div class="line">//当接收到服务器的响应（连通了服务器）时会调用</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</div><div class="line"></div><div class="line">//当接收到服务器的数据时会调用（可能会被调用多次，每次只传递部分数据）</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data</div><div class="line"></div><div class="line">//当服务器的数据加载完毕时就会调用</div><div class="line"></div><div class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection</div><div class="line"></div><div class="line">//请求错误（失败）的时候调用（请求超时\断网\没有网\，一般指客户端错误）</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</div></pre></td></tr></table></figure>
<h5 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h5><p>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。</p>
<p>NSURLSession也是一组相互依赖的类，它的大部分组件和NSURLConnection中的组件相同如NSURLRequest，NSURLCache等。而NSURLSession的不同之处在于，它将NSURLConnection替换为NSURLSession和NSURLSessionConfiguration，以及3个NSURLSessionTask的子类：NSURLSessionDataTask, NSURLSessionUploadTask, 和NSURLSessionDownloadTask。</p>
<p>下面是新推出的类：</p>
<p>1.NSURLSessionConfiguration类</p>
<p>其中NSURLSessionConfiguration用于配置会话的属性，可以通过该类配置会话的工作模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSURLSessionConfiguration *)defaultSessionConfiguration;  </div><div class="line">+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;  </div><div class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfiguration:(NSString *)identifier;</div></pre></td></tr></table></figure>
<p>在backgroundSessionConfiguration:方法中的identifier参数指定了会话的ID，用于标记后台的session。<br>该类的其中两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* allow request to route over cellular. */  </div><div class="line">@property BOOL allowsCellularAccess;  </div><div class="line">  </div><div class="line">/* allows background tasks to be scheduled at the discretion of the system for optimal performance. */  </div><div class="line">@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(NA, 7_0);</div></pre></td></tr></table></figure>
<p>allowsCellularAccess 属性指定是否允许使用蜂窝连接， discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。补充：这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过Wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>
<p>2.NSURLSession类</p>
<p>获取NSURLSession类对象有几种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (NSURLSession *)sharedSession;  </div><div class="line">  </div><div class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; </div><div class="line"> </div><div class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue;</div></pre></td></tr></table></figure>
<p>第一种方式是使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书。</p>
<p>第二种方式是通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用。</p>
<p>第三种方式是通过sessionWithConfiguration:delegate:delegateQueue方法创建对象，二三两种方式可以创建一个新会话并定制其会话类型。该方式中指定了session的委托和委托所处的队列。当不再需要连接时，可以调用Session的invalidateAndCancel直接关闭，或者调用finishTasksAndInvalidate等待当前Task结束后关闭。这时Delegate会收到URLSession:didBecomeInvalidWithError:这个事件。Delegate收到这个事件之后会被解引用。</p>
<p>3.NSURLSessionTask类</p>
<p>NSURLSessionTask是一个抽象子类，它有三个子类：NSURLSessionDataTask，NSURLSessionUploadTask和NSURLSessionDownloadTask。这三个类封装了现代应用程序的三个基本网络任务：获取数据，比如JSON或XML，以及上传和下载文件。</p>
<blockquote>
<p>与 NSURLConnection 相比，NSURLsession 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 NSURLSession 对象都由一个 NSURLSessionConfiguration 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</p>
</blockquote>
<p>NSURLSession 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。NSURLSessionTask 与 NSURLConnection 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 NSURLSession 这一公共委托者（common delegate）。</p>
<p>下面是其继承关系：<br><img src="http://img.blog.csdn.net/20140205121918203" alt="pic2"></p>
<p>有多种方法创建对应的任务对象：</p>
<p>（1）NSURLSessionDataTask</p>
<p>通过request对象或url创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Creates a data task with the given request.  The request may have a body stream. */  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;  </div><div class="line">  </div><div class="line">/* Creates a data task to retrieve the contents of the given URL. */  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;</div></pre></td></tr></table></figure>
<p>通过request对象或url创建，同时指定任务完成后通过completionHandler指定回调的代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>（2）NSURLSessionUploadTask<br>通过request创建，在上传时指定文件源或数据源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  </div><div class="line">  </div><div class="line">/* Creates an upload task with the given request.  The body of the request is provided from the bodyData. */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  </div><div class="line">  </div><div class="line">/* Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;</div></pre></td></tr></table></figure>
<p>在创建upload task对象时，通过completionHandler指定任务完成后的回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * upload convenience method. </div><div class="line"> */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>（3）NSURLSessionDownloadTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Creates a download task with the given request. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;  </div><div class="line">  </div><div class="line">/* Creates a download task to download the contents of the given URL. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;  </div><div class="line">  </div><div class="line">/* Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;</div></pre></td></tr></table></figure>
<p>下载任务支持断点续传，第三种方式是通过之前已经下载的数据来创建下载任务。<br>同样地可以通过completionHandler指定任务完成后的回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>4.NSURLSessionDelegate和NSURLSessionTaskDelegate协议</p>
<p>在协议的方法中可以完成各种各样的回调动作，如身份验证、完成任务后的动作、错误处理和后台任务完成的动作等。委托方法指定在NSURLSession中一定数量的字节传输使用int64_t类型的参数。</p>
<p>这里只说下后台任务的一个委托方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>合作使用的ApplicationDelegate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>将任务切换到后台之后，Session的Delegate不会再收到和Task相关的消息。当所有Task全都完成后，程序将被唤醒，并调用ApplicationDelegate的application:handleEventsForBackgroundURLSession:completionHandler:回调，在这里要为后台session（由background session的identifier标识）指定对应的回调代码块。<br>随后，对于每一个完成的后台Task调用该Session的Delegate中的URLSession:downloadTask:didFinishDownloadingToURL:（成功的话）和URLSession:task:didCompleteWithError:（成功或者失败都会调用）方法做处理，以上的回调代码块可以在这里调用。</p>
<h4 id="NSURLSession与NSURLConnection区别"><a href="#NSURLSession与NSURLConnection区别" class="headerlink" title="NSURLSession与NSURLConnection区别"></a>NSURLSession与NSURLConnection区别</h4><p>总结一下两者主要的区别：</p>
<p>1, 使用现状</p>
<p>从iOS9.0开始， NSURLConnection中发送请求的两个方法已过期（同步请求，异步请求），初始化网络连接（initWithRequest: delegate:）的方法也被设置为过期，系统不再推荐使用，建议使用NSURLSession发送网络请求。</p>
<p>2, 普通任务和上传</p>
<p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask, NSURLSessionUploadTask和NSURLSessionDownloadTask.。创建的task都是挂起状态，需要resume才能执行。</p>
<p>当服务器返回的数据较小时，NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别。</p>
<p>执行上传任务时，NSURLSession与NSURLConnection一样同样需要设置POST请求的请求体进行上传。</p>
<p>3, 下载任务方式<br>NSURLConnection下载文件时，先将整个文件下载到内存，然后再写入沙盒，如果文件比较大，就会出现内存暴涨的情况。而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在下载完成后会将tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。</p>
<p>以下代码是实例化网络下载任务时将下载的文件保存到沙盒的caches文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[NSURLSessionDownloadTask [NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://127.0.0.1/dawenjian.zip&quot;] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">   //获取沙盒的caches路径</div><div class="line"></div><div class="line">   NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]stringByAppendingPathComponent:@&quot;kkk.dmg&quot;];</div><div class="line"></div><div class="line">   //生成URL路径</div><div class="line"></div><div class="line">   NSURL *DCurl = [NSURL fileURLWithPath:path];</div><div class="line"></div><div class="line">   //将文件保存到指定文件目录下</div><div class="line"></div><div class="line">   [[NSFileManager defaultManager]moveItemAtURL:location toURL:DCurl error:nil];   &#125;]resume];</div></pre></td></tr></table></figure>
<p>4, 请求方法的控制</p>
<p>NSURLConnection实例化对象，实例化开始，默认请求就发送（同步发送），不需要调用start方法。而cancel 可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</p>
<p>NSURLSession有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务。</p>
<p>5, 断点续传的方式<br>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果 downloadTask （下载任务）为非空，调用 cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中。在点击再次下载时，通过调用 [ [self.session downloadTaskWithResumeData:self.resumeData]resume]方法进行继续下载操作。   </p>
<p>经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷。</p>
<p>6,  配置信息</p>
<p>NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个 NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比于 NSURLConnection 依赖于一个全局的配置对象，缺乏灵活性而言，NSURLSession 有很大的改进了。</p>
<p>[由于篇幅已经很长了，NSProtocol另外创建一篇文章介绍吧… ]</p>
<hr>
<p>参考：</p>
<p><a href="http://blog.csdn.net/jymn_chen/article/details/18937819" target="_blank" rel="external"> NSURLSession学习笔记（一）简介</a></p>
<p><a href="http://www.cnblogs.com/wendingding/p/3813572.html" target="_blank" rel="external">iOS开发网络篇—NSURLConnection基本使用</a></p>
<p><a href="http://www.cnblogs.com/kakaluote123/articles/5426923.html" target="_blank" rel="external">NSURLSession与NSURLConnection区别
</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/域名解析优化/" itemprop="url">
                  [转]域名解析使用HTTPDNS优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-11T22:43:38+08:00" content="2016-09-11">
              2016-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Base/" itemprop="url" rel="index">
                    <span itemprop="name">Base</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结了部分关于传统DNS解析会存在的一些问题和HTTPDNS的解决方案，更详细的介绍可以看原文 <a href="http://www.cnblogs.com/aliyunblogs/p/5749177.html" target="_blank" rel="external">阿里云官方博客</a></p>
<h4 id="DNS概念"><a href="#DNS概念" class="headerlink" title="DNS概念"></a>DNS概念</h4><p>根域、顶级域、二级域:</p>
<p>DNS系统一般采用树状结构进行组织，以ru.wikipedia.org为例，org为顶级域名，wikipedia为二级域名，ru为三级域名</p>
<p>权威DNS：</p>
<p>权威DNS即最终决定域名解析结果的服务器，开发者可以在权威DNS上配置、变更、删除具体域名的对应解析结果信息。</p>
<p>递归DNS：</p>
<p>递归DNS又称为Local DNS，它没有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程。递归DNS上有缓存模块，当目标域名存在缓存解析结果并且TTL未过期时（每个域名都有TTL时间，即有效生存时间，若域名解析结果缓存的时间超过TTL，需要重新向权威DNS获取解析结果），递归DNS会返回缓存结果，否则，递归DNS会一级一级地查询各个层级域名的权威DNS直至获取最终完整域名的解析结果。</p>
<p>公共DNS：</p>
<p>公共DNS是递归DNS的一种特例，它是一种全网开放的递归DNS服务，而传统的递归DNS信息一般由运营商分发给用户。一个比较典型的公共DNS即Google的8.8.8.8，我们可以通过在操作系统配置文件中配置公共DNS来代替Local DNS完成域名解析流程。</p>
<p>以访问www.taobao.com为例，一次完整的域名解析流程包括：</p>
<p>终端向Local DNS发起域名解析请求；<br>Local DNS在获取到域名解析请求后首先从Root hints获取根域名服务器的地址（Root hints包含了互联网DNS根服务器的地址信息）；<br>获取了根域名服务器地址后Local DNS向根域名服务器发起DNS解析请求，根域名服务器返回com顶级域名服务器地址；<br>随后Local DNS向com域名服务器发起解析请求，并得到taobao.com二级域名服务器的地址；<br>Local DNS向taobao.com二级域名服务器发起解析请求，并最终获得了www.taobao.com的IP地址信息；<br>Local DNS将递归查询获得的IP地址信息缓存并返回给客户端；</p>
<blockquote>
<p>Local DNS服务器包含缓存模块，在实际域名解析过程中Local DNS服务器会首先查询缓存，缓存命中且解析结果TTL未过期的情况下直接返回，否则才启动递归查询的流程。</p>
</blockquote>
<h4 id="传统的域名解析面临的问题"><a href="#传统的域名解析面临的问题" class="headerlink" title="传统的域名解析面临的问题"></a>传统的域名解析面临的问题</h4><p>了解了域名解析的基本概念和整体流程，我们再一起来探究一下传统域名解析存在的一系列问题。</p>
<h5 id="域名劫持"><a href="#域名劫持" class="headerlink" title="域名劫持"></a>域名劫持</h5><p>域名劫持一直是困扰许多开发者的问题之一，其表现即域名A应该返回的DNS解析结果IP1被恶意替换为了IP2，导致A的访问失败或访问了一个不安全的站点。下面我们一起看看几种常见的域名劫持的场景。</p>
<p>一种可能的域名劫持方式即黑客侵入了宽带路由器并对终端用户的Local DNS进行篡改，指向黑客自己伪造的Local DNS，进而通过控制Local DNS的逻辑返回错误的IP信息进行域名劫持。另一方面，由于DNS解析主要是基于UDP协议，除了上述攻击行为外，攻击者还可以监听终端用户的域名解析请求，并在Local DNS返回正确结果之前将伪造的DNS解析响应传递给终端用户，进而控制终端用户的域名访问行为。</p>
<p>上述攻击行为的影响面相对比较有限，另一种我们最常碰到的域名劫持现象是缓存污染。我们知道在接收到域名解析请求时，Local DNS首先会查找缓存，如果缓存命中就会直接返回缓存结果，不再进行递归DNS查询。这时候如果Local DNS针对部分域名的缓存进行更改，比如将缓存结果指向第三方的广告页，就会导致用户的访问请求被引导到这些广告页地址上。</p>
<p>对比第一种攻击，这类缓存污染往往能带来更明显的群体伤害，比如某个省份某个运营商的用户群可能因为该地区Local DNS的缓存污染而导致访问服务异常。这类缓存污染行为往往是间歇性、局部性发生的，没有明显的规律，导致开发者很难对其进行量化、评估、预防。</p>
<p>有的同学可能会问，“我使用了HTTPS，是否就可以避免域名劫持的问题”，答案是否定的。域名解析环节发生在网络加密请求交互之前，试想一下，如果客户端还没有服务端的确切地址信息，我们又如何知道应该和谁进行加密的握手协商与通信呢？</p>
<h5 id="调度不精准"><a href="#调度不精准" class="headerlink" title="调度不精准"></a>调度不精准</h5><p>除了域名劫持问题，基于传统Local DNS的域名解析还会带来域名调度精准性的问题。对于类似CDN域名访问这类需要按地域、运营商进行智能解析调度的场景，精准调度的诉求是十分强烈的。</p>
<p>关于调度不精准的原因，我们主要可以从两个方面来探究一下。第一个常见的问题即解析转发。</p>
<p>部分Local DNS供应商为了降低运营成本，会将请求到自己节点的域名解析请求转发给其他供应商的Local DNS节点，如上图所示。假如用户请求解析一个CDN域名cdn.aliyun.com，用户分配到的Local DNS A为了节省成本，把该次请求转发给了另一运营商的Local DNS B，权威DNS在进行域名解析时会根据Local DNS的IP信息进行智能调度，即权威DNS会根据Local DNS B的IP78.29.29.1进行调度，分配与78.29.29.1相同运营商并且地理位置最近的CDN节点78.29.29.2，然而这个CDN节点对于终端135.35.35.1而言并不是最优的CDN节点，他们分属不同的运营商，并且地理位置上可能相隔很远。这类解析转发行为会严重影响域名解析的精准性并对用户业务访问延迟带来影响。</p>
<p>除了解析转发对调度精准性带来的影响外，Local DNS的布署情况同样影响着域名智能解析的精准性。</p>
<h5 id="解析生效滞后"><a href="#解析生效滞后" class="headerlink" title="解析生效滞后"></a>解析生效滞后</h5><p>部分业务场景下开发者对域名解析结果变更的生效时间非常敏感（这部分变更操作是开发者在权威DNS上完成的），比如当业务服务器受到攻击时，我们需要最快速地将业务IP切换到另一组集群上，这样的诉求在传统域名解析体系下是无法完成的。</p>
<h5 id="延迟大"><a href="#延迟大" class="headerlink" title="延迟大"></a>延迟大</h5><p>DNS首次查询或缓存过期后的查询，需要递归遍历多个DNS服务器以获取最终的解析结果，这增加了网络请求的前置延时时间。特别是在移动互联网场景下，移动网络质量参差不齐，弱网环境的RTT时间可能高达数百毫秒，对于一次普通的业务请求而言，上述延时是非常沉重的负担。另一方面，弱网环境下的解析超时、解析失败等现象屡见不鲜，如何合理优化DNS解析对于整体网络访问质量的提升至关重要。</p>
<h4 id="HTTPDNS解决方案"><a href="#HTTPDNS解决方案" class="headerlink" title="HTTPDNS解决方案"></a>HTTPDNS解决方案</h4><h5 id="防域名劫持"><a href="#防域名劫持" class="headerlink" title="防域名劫持"></a>防域名劫持</h5><p>HTTPDNS使用HTTP协议进行域名解析，代替现有基于UDP的DNS协议，域名解析请求直接发送到HTTPDNS服务端，从而绕过运营商的Local DNS，如下图所示。</p>
<p><img src="https://yqfile.alicdn.com/6c4402618b6f9580255ba88ea28fa518947629ae.png?_=0.3877227769572087" alt="tu1"></p>
<p>HTTPDNS代替了传统的LocalDNS完成递归解析的功能，基于HTTP协议的设计可以适用于几乎所有的网络环境，同时保留了鉴权、HTTPS等更高安全性的扩展能力，避免恶意攻击劫持行为。另一方面，商业化的HTTPDNS服务（<a href="https://www.aliyun.com/product/httpdns" target="_blank" rel="external">https://www.aliyun.com/product/httpdns</a> ）缓存管理有严格的SLA保障，避免了类似Local DNS的缓存污染的问题。</p>
<h5 id="精准调度"><a href="#精准调度" class="headerlink" title="精准调度"></a>精准调度</h5><p>传统域名解析的调度精准性问题，本质根源在于Local DNS的部署和分配机制上。由于碎片化的管理方式，这些环节的服务质量同样很难得到保障。HTTPDNS在递归解析实现上优化了与权威DNS的交互，通过edns-client-subnet协议（<a href="https://datatracker.ietf.org/doc/rfc7871" target="_blank" rel="external">https://datatracker.ietf.org/doc/rfc7871</a> ）将终端用户的IP信息直接交付给权威DNS，这样权威DNS就可以忽略Local DNS IP信息，根据终端用户的IP信息进行精准调度，避免Local DNS的坐标干扰（当然上述精准调度方案的前提是权威DNS需要支持edns-client-subnet，可喜的是当前主流的权威DNS服务都已支持该协议）。</p>
<h5 id="实时生效"><a href="#实时生效" class="headerlink" title="实时生效"></a>实时生效</h5><p>在域名解析生效周期方面，HTTPDNS也有着传统域名解析体系所无法具备的能力。前文中我们提到由于各个地区的Local DNS是独立维护的，服务质量参差不齐，缓存实现不一，因此导致的解析变更全网生效滞后的问题，在商业化的HTTPDNS服务上就不会存在（HTTPDNS严格遵循DNS TTL限制进行缓存更新）。另一方面，即便我们假设Local DNS严格遵循域名TTL时间进行缓存管理（这里我们假设开发者配置的域名TTL时间为5min），当开发者业务受到攻击并需要快速进行切换时，Local DNS也会遵循域名TTL，在持续5min的时间段内返回旧IP信息，这5min的业务影响对于中大型企业而言是一个不小的损失（对于电商类的大型企业，5min的访问异常可能意味着几百万的交易额下跌）。以阿里云HTTPDNS服务（<a href="https://www.aliyun.com/product/httpdns" target="_blank" rel="external">https://www.aliyun.com/product/httpdns</a> ）为例，HTTPDNS在快速生效方面有专有的方案，配合阿里云的权威DNS服务云解析（ <a href="https://wanwang.aliyun.com/domain/dns" target="_blank" rel="external">https://wanwang.aliyun.com/domain/dns</a> ），用户在权威DNS变更的解析结果将快速同步给HTTPDNS，覆盖原有的缓存记录，帮助用户实现秒级的域名解析切换。</p>
<p>在DNS解析延迟方面，由于HTTPDNS基于HTTP协议，而HTTP基于TCP协议，对比传统的UDP传输多了一些冗余的握手环节，因此从原理上而言网络请求方面的开销并没有降低。但在实际使用过程中，我们可以通过端上的策略来实现一个零延迟DNS解析的方案。接下来我们一起来看看HTTPDNS服务在移动端的最佳实践方案。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/10/证书与打包与APNs/" itemprop="url">
                  证书与打包与APNs
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-10T18:10:49+08:00" content="2016-09-10">
              2016-09-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="苹果在9月22号又更新了有关token和通知的功能-news-大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）"><a href="#苹果在9月22号又更新了有关token和通知的功能-news-大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）" class="headerlink" title="苹果在9月22号又更新了有关token和通知的功能[news] 大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）"></a>苹果在9月22号又更新了有关token和通知的功能<a href="https://developer.apple.com/news/?id=09222016a" target="_blank" rel="external">[news]</a> 大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）</h2><p>APNs 是 Apple Push Notification service 的简称，是苹果提供的Push服务器，Push流程如下：</p>
<p><img src="http://img.blog.csdn.net/20131210220624265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWJlbF90dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="pic 1"></p>
<p>1、应用程序注册消息推送。</p>
<p>2、iOS从APNs Server获取device token，应用程序接收device token。</p>
<p>3、应用程序将device token发送给PUSH服务端程序。</p>
<p>4、服务端程序向APNs服务发送消息。</p>
<p>5、APNs服务将消息发送给iPhone应用程序。</p>
<p>其中iOS客户端到APNs Server到APNs都需要证书连接。</p>
<p>下面是需要用到几个证书文件：</p>
<p>1，CSR文件：CertificateSigningRequest.certSigningRequest</p>
<p>2，p12文件：Push.p12（文件名可自定义）</p>
<p>3，SSL certificate文件：aps_development.cer（文件名可自定义）</p>
<p>通过这3个文件可以生产APNs的服务器证书，具体的生成步骤可以看<a href="http://www.fx114.net/qa-202-108331.aspx" target="_blank" rel="external">这篇文章</a>，其中php服务器与Java服务器需要的证书的格式有区别。</p>
<p>APNs 协议在近两年的 WWDC 上改过两次，2015年12月17日更是推出了革命性的新特性，改掉了很多长期被用户诟病的问题:</p>
<p>2014年6月份WWDC搭载iOS8及以上系统的iOS设备，能够接收的最大playload大小提升到2KB。低于iOS8的设备以及OS X设备维持256字节。参考文档：<a href="https://developer.apple.com/videos/play/wwdc2014/713/" target="_blank" rel="external">What’s New in Notifications - WWDC 2014 - Session 713 - iOS</a></p>
<p>2015年6月份WWDC宣布将在不久的将来发布 “基于 HTTP/2 的全新 APNs 协议”，并在大会上发布了仅仅支持测试证书的版本。参考文档：<a href="https://developer.apple.com/videos/play/wwdc2015/720/" target="_blank" rel="external">What’s New in Notifications - WWDC 2015 - Session 720 - iOS, OS X </a></p>
<p>2015年12月17日起，发布 “基于 HTTP/2 的全新 APNs 协议”,iOS 系统以及 OS X 系统，统一将最大 playload 大小提升到4KB。参考文档：<a href="https://developer.apple.com/news/?id=12172015b" target="_blank" rel="external">Apple Push Notification Service Update 12-17 2015</a></p>
<p>下面是APNs新旧版本的对比：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160425/1461567499300714.jpg" alt="pic 2"></p>
<p>送分发的服务器要打开一个同 APNs 网关服务器的</p>
<p>连接，并保持这个连接。但在旧的协议下，APNs 服务却不保证 socket 能维持这个连接。如果通道上没有消息往来，空闲下来到话，socket将被路由掐断。在旧的协议下，如果服务器响应成功的话，你将不会收到任何回应，但是如果服务器响应失败（例如，使用了一个非法的 Push token），服务器将返回了一个错误编码，并关闭这个socket。最重要的是，你必须重新发送使用这个无效 token 以后发送的所有推送。因此，你可能一直不能确定你的推送是否成功的被 APNs 服务器接收。</p>
<p>基于上述问题新版本的APNs有如下特征：</p>
<p>1，Request 和 Response 支持JSON网络协议</p>
<p>2，APNs支持状态码和返回 error 信息</p>
<p>APNs推送成功时 Response 将返回状态码200，远程通知是否发送成功再也不用靠猜了！<br>APNs推送失败时，Response 将返回 JSON 格式的 Error 信息。<br>3，最大推送长度提升到4096字节（4Kb）</p>
<p>4，可以通过 “HTTP/2 PING ” 心跳包功能检测当前 APNs 连接是否可用，并能维持当前长连接。</p>
<p>5，支持为不同的推送类型定义 “topic” 主题</p>
<p>6，不同推送类型，只需要一种推送证书 Universal Push Notification Client SSL 证书。</p>
<p>其中最大的变化就是基于了 HTTP/2 协议，采用了长连接设计，并提供 “HTTP/2 PING ” 心跳包功能检测、维持当前 APNs 连接，解决了老 APNs 无法维持连接的问题。而且新增的状态码特性，也解决了这个问题：无法获知消息是否成功地从你们的推送系统投递到了 APNs 上。理论上，你们可以保证消息是100%投递到了APNs的，因为你可以准确的知道哪条消息到达了APNs，哪些没到。重发特定失败消息成为可能。</p>
<hr>
<p>参考：<a href="http://www.cocoachina.com/ios/20160426/16013.html" target="_blank" rel="external">国内90%以上的 iOS 开发者，对 APNs 的认识都是错的</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/09/Hybrid-笔记/" itemprop="url">
                  Hybrid 笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-09T16:35:25+08:00" content="2016-09-09">
              2016-09-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hybrid App优势明显，发版不用审核，页面可以随时调整和修复，通用于3个平台节省开发成本等，很多公司都在用，类型主要分Web主体型、多View混合型、单View混合型。</p>
<p>我们公司则经历了从最早的Web主体型APP向多view混合型的过渡，公司早期人员少，业务变化快的情况下，业务代码都放在前端非常方便，不过后期随着用户量的增多，对性能和用户体验开始精益求精，将部分高频的页面native化。</p>
<p>Hybrid APP的核心就是Native和H5之间的交互，native端需要提供一些通用的设备功能让H5可以调用，比如：</p>
<p>1，Alert组件、loading组件、NavigationBar、tabbar等</p>
<p>2，获取定位、获取通讯录、获取陀螺仪、获取相册相机权限、获取设备信息（iOS版本、iPhone型号）、获取网络\定位\push状态</p>
<p>3，对本地缓存数据的增删查改(有的直接通过cookie、session来传递数据)</p>
<p>4，页面的跳转（关闭或新拉起页面）</p>
<p>5，[非通用]加密、支付、动画、地图、分享等功能</p>
<p>以上这些native的功能H5可以通过桥接来执行</p>
<p>H5主要完成如下工作：</p>
<p>(1) 创建了一个用于发送消息的iFrame(通过创建一个隐藏的ifrmae，并设置它的URL 来发出一个请求，从而触发UIWebView的shouldStartLoadWithRequest回调协议)</p>
<p>(2) 创建了一个核心对象，如 WebViewJavascriptBridge，并给它定义了几个方法，这些方法大部分是公开的API方法</p>
<p>(3) 创建了一个事件：WebViewJavascriptBridgeReady，并dispatch(触发)了它。</p>
<p>native的主要工作是通过UIWebViewDelegate协议的方法shouldStartLoadWithRequest：来获取这个请求并执行相应的native方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType &#123;</div><div class="line">//异步桥接</div><div class="line">    if ([url.absoluteString rangeOfString:@&quot;customScheme://operation&quot;].location != NSNotFound) &#123;</div><div class="line">        [self doWebBridgeOperation:[url.query stringByURLDecodingStringParameter]];</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法通过判断url是否有自定义的scheme来决定是否执行桥接方法，如果是的话则执行相应的方法，参数可以通过url query带过去，然后返回NO，表示不会拉起这个url的webview页面。</p>
<p>以上是目前比较主流的桥接方案，除此之外我们还提供了同步桥接，前端可以通过ajax同步请求来触发native的相应方法，这种方法更方便H5的调用，但是执行时会阻塞页面，主要是通过自定义NSURLProtocol的拦截来实现，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// override</div><div class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    // step 1, check the request did marked</div><div class="line">    id prop = [NSURLProtocol propertyForKey:REQUEST_TRACKING_KEY inRequest:request];</div><div class="line">    if (prop != nil) &#123;</div><div class="line">        return NO; // aviod loading cycle</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // step 2, check the scheme of request</div><div class="line">    NSString *scheme = [request.URL scheme];</div><div class="line">    if (scheme == nil) return NO; // the request schema can not be nil</div><div class="line">    </div><div class="line">    scheme = [scheme lowercaseString];</div><div class="line">    if (!([scheme isEqualToString:@&quot;http&quot;]</div><div class="line">          || [scheme isEqualToString:@&quot;https&quot;])) &#123;</div><div class="line">        return NO; // for now, the scheme should be &apos;http&apos; or &apos;https&apos;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先在canInitWithRequest方法里判断是否要拦截，通过propertyForKey来标记这个方法是否处理过，如果这个方法已经处理过，则不会继续处理，避免循环加载，如果scheme不是http 或者https 也不做处理。如果条件都符合则返回YES，执行startLoading：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// override</div><div class="line">- (void)startLoading &#123;</div><div class="line">    NSURL *requestURL = self.request.URL;</div><div class="line">	//拦截同步请求</div><div class="line">    if (url &amp;&amp; [url.absoluteString rangeOfString:customSyncBridgeParam].location != NSNotFound) &#123;</div><div class="line">    NSData* resultBridgeData = [self doSyncBridgeOperation:[url.query stringByURLDecodingStringParameter]];</div><div class="line">   	    // notify did finish load data</div><div class="line">        [self.client URLProtocol:self didLoadData:resultBridgeData];</div><div class="line">        </div><div class="line">        // notify did finish loading</div><div class="line">        [self.client URLProtocolDidFinishLoading:self];</div><div class="line">        </div><div class="line">        [NSURLProtocol setProperty:@(YES) forKey:REQUEST_TRACKING_KEY inRequest:request];</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过url里面是否包含约定的同步桥接字符串，如果有就执行同步桥接。</p>
<p>通过NSURLProtocol我们也可以在startLoading里面自定义request的header、超时时间等，还能替换掉原来的url，比如要加载本地资源：拦截请求后只对特定的类型替换为本地缓存。比如更新静态资源请求是下载zip包，如果本地也存在此zip包，那么更新请求会被拦截导致更新失败。还有一点先在DocumentDirectory中查找缓存文件，如果不存在再在NSBundle.mainBundle()中查找。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/27/OC发送消息的几种方式/" itemprop="url">
                  OC发送消息的几种方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T17:59:37+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>object-c 的消息发送主要有3种方式：</p>
<p>1，直接发送</p>
<p>2，使用performSelector</p>
<p>3，使用NSInvocation</p>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>第一种是用的最多的，</p>
<p>id returnValue = [someObject messageName:parameter];</p>
<p>其中，someObject是消息的“接收者”，messageName为“选择子”，“选择子”与参数合起来叫做消息。转换成C语言就是</p>
<p>void objc_msgSend (id self, SEL cmd, …)</p>
<p>如果是明确类型的对象发送消息，那这个方法必须是在someObject的类里能够找到的，否则Xcode会报错，有的时候我们需要对一个对象做类型转换再发送消息，这种情况下如果原来的对象里没有这种方法编译器也不知道，从而在执行的时候会crash，在运行时找不到方法系统不会直接报错，而是先进行消息转发，过程如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/277577/201509/277577-20150920213203086-713808959.png" alt="msg_resend"></p>
<p>首先，会调用+ (BOOL)resolveInstanceMethod:(SEL)sel。若方法返回YES，则表示可以处理该消息。在这个过程，可以动态地给消息增加方法。</p>
<p>若方法返回NO，则进行消息转发的第二步，查找是否有其它的接收者。对应的处理函数是：- (id)forwardingTargetForSelector:(SEL)aSelector。可以通过该函数返回一个可以处理该消息的对象。</p>
<p>若第二步返回nil，则进入消息转发的第三步。调用- (void)forwardInvocation:(NSInvocation *)anInvocation。这个方法实现得很简单。只需要改变调用目标，使消息在新目标上得以调用即可。不过，如果采用这种方式，实现的效果与第二步的消息转发是一致的。所以比较有用的实现方式是：先以某种方式改变消息内容，比如追加另外一个参数，或者改换选择子，等等。</p>
<p>如果直到NSObject，继承体系中的其它类都无法处理这个消息转发，就会由NSObject调用该方法，并在该方法中调用doesNotRecognizeSelector，以抛出异常。</p>
<p>网上看到一个比较形象的<a href="http://www.cnblogs.com/forwk/p/4822052.html?tvd" target="_blank" rel="external">总结</a> :</p>
<p>1、李四收到做板凳的消息，发现自己不会做，系统问李四是否需要添加这份技能(resolveInstanceMethod中addMethod)</p>
<p>2、李四自己学不会,但是李四决定找一个认识的人来处理这件事(forwardTargetForSelector:)</p>
<p>3、李四实在是找不到任何人来处理这件事，店长或经理搜集客户需求(selector,methodArgument，处理人target)，启用板凳店的终极处理NSInvocation</p>
<p>4、启用之后还是没有什么卵用，店长无赖的告诉张三，doesnotRecognizeSelector</p>
<h3 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h3><p>id returnValue = [someObject messageName: parameter];转换为performSelector的形式：</p>
<p>id returnValue = [someObject performSelector:@selector(messageName:)withObject: parameter];</p>
<p>performSelector是运行时系统负责去找方法的，在编译时候不做任何校验，如果在someObject的类里没有找到，也不会报错，但是为了程序的健壮性，最好先使用检查方法</p>
<ul>
<li>(BOOL)respondsToSelector:(SEL)aSelector;</li>
</ul>
<p>同时performSelector也经常用来做方法的延时调用，performSelector:withObject:afterDelay:这个方法在调用的时候会设置当前runloop中timer</p>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><p>在介绍消息转发时已经提到了NSInvocation，就是在消息转发的第三步就是用NSInvocation来创建一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 方法签名中保存了方法的名称/参数/返回值，协同NSInvocation来进行消息的转发</div><div class="line">// 方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系</div><div class="line">//1、根据方法来初始化NSMethodSignature</div><div class="line">NSMethodSignature  *signature = [ViewController instanceMethodSignatureForSelector:@selector(run:)];</div><div class="line">// NSInvocation中保存了方法所属的对象/方法名称/参数/返回值</div><div class="line">//其实NSInvocation就是将一个方法变成一个对象</div><div class="line">//2、创建NSInvocation对象</div><div class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</div><div class="line">//设置方法调用者</div><div class="line">invocation.target = self;</div><div class="line">//注意：这里的方法名一定要与方法签名类中的方法一致</div><div class="line">invocation.selector = @selector(run:);</div><div class="line">NSString *way = @&quot;byCar&quot;;</div><div class="line">//这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd)</div><div class="line">[invocation setArgument:&amp;way atIndex:2];</div><div class="line">//3、调用invoke方法</div><div class="line">[invocation invoke];</div><div class="line"></div><div class="line">//4、判断当前调用的方法是否有返回值</div><div class="line">if (signature.methodReturnLength) &#123;</div><div class="line">            void *pointer = NULL;</div><div class="line">            [invocation getReturnValue:&amp;pointer];</div><div class="line">            obj = (__bridge id)pointer;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Leii" />
          <p class="site-author-name" itemprop="name">Leii</p>
          <p class="site-description motion-element" itemprop="description">iOS/Unity/Design</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Leii/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://leiiii.lofter.com/" target="_blank" title="Lofter">
                  
                    <i class="fa fa-fw fa-paint-brush"></i>
                  
                  Lofter
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leii</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
