<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leii&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leii.me/"/>
  <updated>2016-10-03T14:10:27.000Z</updated>
  <id>http://leii.me/</id>
  
  <author>
    <name>Leii</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shader笔记[二]</title>
    <link href="http://leii.me/2016/10/02/Shader%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://leii.me/2016/10/02/Shader笔记二/</id>
    <published>2016-10-02T01:19:58.000Z</published>
    <updated>2016-10-03T14:10:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shader-Language"><a href="#Shader-Language" class="headerlink" title="Shader Language"></a>Shader Language</h2><p>shader language，着色语言，是基于物体本身属性和光照条件，计算每个像素点的颜色值。</p>
<p>shader language 被定义为高级语言，但是不能独立于硬件，现阶段shader language还是完全依赖于GPU架构的，在shader language之前基于图形硬件的编程只能靠汇编语言。shader language目前主流的语言有3种：基于OpenGL 的 GLSL，基于Direct3D的HLSL，还有NVIDIA公司的Cg语言。</p>
<h3 id="1-Shader-Language-原理"><a href="#1-Shader-Language-原理" class="headerlink" title="1 Shader Language 原理"></a>1 Shader Language 原理</h3><p>使用shader language 编写的程序称之为shader program着色程序，着色程序分为vertex shader program 和 fragment shader program（顶点着色与片段着色）。GPU上有可编程顶点处理器和可编程片段处理器，其中又分为多个可编程单元，分别能运行顶点程序和片段程序。顶点和片段处理器都拥有非常强大的并行计算能力,并且非常擅长于矩阵 (不高于 4 阶)计算,片段处理器还可以高速查询纹理信息(目前顶点处理器还 不行,这是顶点处理器的一个发展方向)。 </p>
<p>输入寄存器存放输入的图 元信息;输出寄存器存放处理后的图元信息;纹理 buffer 存放纹理数据,目前 大多数的可编程图形硬件只支持片段处理器处理纹理;从外部宿主程序输入的常 量放在常量寄存器中;临时寄存器存放着色程序在执行过程中产生的临时数据。 </p>
<h3 id="2-Vertex-Shader-Program-amp-Fragment-Shader-Program"><a href="#2-Vertex-Shader-Program-amp-Fragment-Shader-Program" class="headerlink" title="2 Vertex Shader Program &amp; Fragment Shader Program"></a>2 Vertex Shader Program &amp; Fragment Shader Program</h3><p>顶点着色程序从输入寄存器中提取图元信息（顶点位置、法向量、纹理坐标等），并完成顶点的空间转换、法向量空间转换、光照计算等操作，最后将计算好的数据传送到指定寄存器中；然后片段着色器从中获取纹理坐标、光照信息等数据，并根据这些信息以及从应用程序传递的纹理信息进行每个片段的颜色计算，最后将处理后的数据传递给光栅化操作模块。</p>
<p>顶点着色程序通常是和片段着色程序配合使用的，前者的输出是后者的输入，不过也可以只有顶点着色程序，这样的话就只对输入的顶点做操作，顶点内部的点则按照硬件默认的方式进行自动插值。例如, 输入一个三角面片,顶点着色程序对其进行 phong 光照计算,只计算三个顶点的 光照颜色,而三角面片内部点的颜色按照硬件默认的算法(Gourand 明暗处理或 者快速 phong 明暗处理)进行插值,如果图形硬件比较先进,默认的处理算法较 好(快速 phong 明暗处理),则效果也会较好;如果图形硬件使用 Gourand 明暗 处理算法,则会出现马赫带效应(条带化)。 </p>
<p>而片段着色程序是对没个片段进行独立的颜色计算，并且算法自己编写，不但可控性好，而且可以达到很多自定义的效果。</p>
<p>顶点着色程序主要进行几何方面的运算，而片段着色程序主要针对最终的颜色值进行计算。<br>片段着色程序还有一个突出的特点是：检索纹理的能力。对于GPU来说，纹理等价于数组，这意味着，如果要做通用计算,例如数组排序、字符串检索等，就必须使用到片段着色程序。 </p>
<blockquote>
<p> 什么是片断?片断和像素有什么不一样?所谓片断就是所有的三维顶点 在光栅化之后的数据集合,这些数据还没有经过深度值比较,而屏幕显示的像素 都是经过深度比较的。 </p>
</blockquote>
<h3 id="3-3种Shader-Language-比较"><a href="#3-3种Shader-Language-比较" class="headerlink" title="3 3种Shader Language 比较"></a>3 3种Shader Language 比较</h3><p>目前有3种主流的着色器语言：基于OpenGL 的GLSL，基于Direct3D的HLSL(High Level Shading Language)，还有NVIDIA公司的Cg (C for Graphic)语言。</p>
<p>GLSL 与 HLSL 分别提基于 OpenGL 和 Direct3D 的接口,两者不能混用 ,Cg 可以被 OpenGL 和 Direct3D 支持。 Cg 语言和 OpenGL、DirectX 并不是同一层次的语言,而是 OpenGL 和 DirectX 的上层 。Unity shader 所使用的语言是Gg语言。</p>
<p>Cg 语言通常采用动态编译的方式,即,在宿主程序运行时利用 Cg 运行库( Cg Runtime library)动态编译 Cg 代码,使用动态编译的方式,可以将 Cg 程序当作一 个脚本,随时修改随时运行,节省大量的时间 </p>
<p>Cg 程序的编译不但依赖于宿主程序所使用的三维编程接口,而且依赖于图 形硬件环境,因为图形硬件自身的限制,不一定支持某种 Cg 语句,例如,如果 你所使用的 GPU 并不支持循环控制指令,那么在 Cg 程序中编写的循环控制语 句将无法通过编译。被特定的图形硬件环境或 AIP 所支持的 Cg 语言子集,被称 为 Cg Profiles。需要注意的是: profile 分为顶点程序的 profile 和片段程序的 profile,这是因为顶点着色器和片段着色器原本就不是工作在同一个硬件。 </p>
<p>一个Cg profile 定义了一个“被特定图形硬件或API所支持的Cg 语言子集”，</p>
<h3 id="4-CG-语言基础"><a href="#4-CG-语言基础" class="headerlink" title="4 CG 语言基础"></a>4 CG 语言基础</h3><h4 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h4><p>7种常见的基本数据类型：float 、half、 int、 fixed、 bool、 sampler *(纹理对象的句柄)、string</p>
<p>内置的向量数据类型：float4、bool4等，表示float或bool类型的4元向量，向量最长不能超过4元，即可以声明float1、float3但是写 float5 array 就会编译错误。向量初始化方式一般为：</p>
<pre><code>float4 array = float4(1.0, 2.0, 3.0, 4.0);
</code></pre><p>还可以使用短的构建长的向量：</p>
<pre><code>float2 a = float2(1.0, 2.0);
float4 b = float4(a, 1.0, 2.0);    
</code></pre><p>Cg还提供了矩阵数据类型，最大维数不超过4*4。如：</p>
<pre><code>float1x1 matrix1;//等价于 float matirx 1; x 是字符,并不是乘号! 
float2x3 matrix2;// 表示 2*3 阶矩阵,包含 6 个 float 类型数据 
float4x2 mat3;// 表示 4*2 阶矩阵,包含 8 个 float 类型数据 
</code></pre><blockquote>
<p>注意:Cg 中向量、矩阵与数组是完全不同,向量和矩阵是内置的数据类型 (矩阵基于向量),而数组则是一种数据结构,不是内置数据类型!这一点和 C\C++中不太一样,在 C\C++中,这三者同属于数据结构,数组可以构建向量和 矩阵。 </p>
</blockquote>
<h4 id="4-2-数组与结构体"><a href="#4-2-数组与结构体" class="headerlink" title="4.2 数组与结构体"></a>4.2 数组与结构体</h4><p>着色程序中，数组通常的使用目的是:作为从外部应用程序传入大量参数 到 Cg 的顶点程序中的形参接口,例如与皮肤形变相关的矩阵数组,或者光照参 数数组等。 </p>
<p>进行数组变量声明时,一定要指定数组长度,除非是作为函数参数而声明的 形参数组。并且在当前的 profiles 中,数组的长度和所引用的数组元素的地址必 须在编译时就知道。 </p>
<p>Cg语言支持结构体(structure),实际上Cg中的结构体的声明、使用和C++ 非常类似(只是类似,不是相同)。一个结构体相当于一种数据类型,可以定义 该类型的变量。引入结构体机制,赋予了 Cg 语言一丝面向对象的色彩。还记得 C++中,结构体与类的区别吗?没有区别,除了默认访问属性在结构体中为 public,类中为 private,所以结构体与类是非常近似的,由此可以看出 shader 语 言的发展趋势还是向着具有面向对象特性的高级语言。不过目前的 Cg 语言中的结构体以展现“封装”功能为主,并不支持继承机制。 </p>
<p>一般来说,Cg 的源代码都会在文件首部定义二个结构体,分别用于定义输人 和输出的类型,这二个结构体定义与普通的 C 结构定义不同,除了定义结构体 成员的数据类型外,还定义了该成员的绑定语义类型( Binding Semantics),所谓 绑定语义类型是为了与宿主环境进行数据交换的时候识别不同数据类型的。目前 Cg 支持的绑定语义类型包括 POSTION 位置),COLOR(颜色),NORMAL(法向 量),Texcoord(纹理坐标)等类型。 </p>
<h4 id="4-3-CG表达式与控制语句"><a href="#4-3-CG表达式与控制语句" class="headerlink" title="4.3 CG表达式与控制语句"></a>4.3 CG表达式与控制语句</h4><p>cg的操作符与C类似，其中有</p>
<pre><code>关系操作符：&lt; != &lt;= ==等
逻辑操作符：&amp;&amp; || !等
数学操作符：++ *= % 等
移位操作符： &gt;&gt; &lt;&lt;
</code></pre><p>除此之外还有比较特殊的swizzle 操作符（.）将一个向量的成员取出组成一根新的向量，如<br>    float4(a, b, c, d).xyz  等价于 float3(a, b, c)<br>    float4(a, b, c, d).xyy  等价于 float3(a, b, b)<br>    float4(a, b, c, d).wzyx  等价于 float4(d, c, b, a) </p>
<blockquote>
<p>注意:swizzle操作符只能对结构体和向量使用,不能对数组使用 </p>
</blockquote>
<p>Cg中的控制流语句和 循环语句与C语言类似:条件语句有:if、if-else;循环语句有:while、for。break 语句可以和在for语句中使用。 </p>
<h4 id="4-4-输入-输出"><a href="#4-4-输入-输出" class="headerlink" title="4.4 输入\输出"></a>4.4 输入\输出</h4><p>Cg的关键字大多数是和C/C++一样，比如int float，不过它也有独特的关键字，这些关键字用于指定输入图元的数据含义（位置信息、法向量信息等），本质上也对应着图元数据存放的硬件资源（寄存器或者纹理），称之为语义词（Semantics），通常也根据其用法称之为绑定语义词(binding semantics)。 </p>
<p>除语义词外,Cg 中还提供了三个关键字,in、out、inout,用于表示函数的 输入参数的传递方式,称为输入\输出关键字,这组关键字可以和语义词合用表 达硬件上不同的存储位置,即同一个语义词,使用 in 关键字修辞和 out 关键词修 辞,表示的图形硬件上不同的寄存器。 </p>
<p>Cg 语言还提供两个修辞符:uniform,用于指定变量的数据初始化方式;const 关键字的含义与 C\C++中相同,表示被修辞变量为常量变量。 </p>
<p>Cg 语言将输入数据流分为两类 </p>
<p>1，Varying inputs,即数据流输入图元信息的各种组成要素。从应用程序输入 到 GPU 的数据除了顶点位置数据,还有顶点的法向量数据,纹理坐标数据 等。Cg 语言提供了一组语义词,用以表明参数是由顶点的哪些数据初始化 的。 </p>
<p>2，Uniform inputs,表示一些与三维渲染有关的离散信息数据,这些数据通 常由应用程序传入,并通常不会随着图元信息的变化而变化,如材质对光的 反射信息、运动矩阵等。Uniform 修辞一个参数,表示该参数的值由外部应 用程序初始化并传入;例如在参数列表中写: </p>
<p>输入\输出修辞符  in\out\inout  分别表示修辞一个形参只是用于输入 ，修辞一个形参只是用于输出的 以及修辞一个形参既用于输入也用于输出,这是典型的引用传递。 也可以使用 return 语句来代替 out 修辞符的使用。输入\输出修辞符通常和语义词一起使用,表示顶点着色程序和片段着色程序的输入输出。</p>
<h4 id="4-5-语义词-Semantic-与语义绑定-Binding-Semantics"><a href="#4-5-语义词-Semantic-与语义绑定-Binding-Semantics" class="headerlink" title="4.5 语义词(Semantic)与语义绑定(Binding Semantics)"></a>4.5 语义词(Semantic)与语义绑定(Binding Semantics)</h4><p>语义概念的提出和图形流水线工作机制大有关系。从前面所讲的 GPU 处理 流程中可以看出，一个阶段处理数据，然后传输给下一个阶段，那么每个阶段之 间的接口是如何确定的呢?例如：顶点处理器的输入数据是处于模型空间的顶点 数据(位置、法向量)，输出的是投影坐标和光照颜色，片段处理器要将光照颜 色做为输入，问题是“片段处理器怎么知道光照颜色值的存放位置”?<br>在高级语言中(C/C++)，数据从接口的一端流向另一端,是因为提供了数 据存放的内存位置(通常是指针信息)，由于 Cg 语言并不支持指针机制,且图 形硬件处理过程中,数据通常暂存在寄存器中，故而在 Cg 语言中，通过引入语 义绑定(binding semantics)机制，指定数据存放的位置,实际上就是将输入\输 出数据和寄存器做一个映射关系(在 OpenGL Cg profiles 中是这样的,但在 DirectX-based Cg profiles 中则并没有这种映射关系)。根据输入语义,图形处理 器从某个寄存器取数据，然后再将处理好的数据,根据输出语义,放到指定的寄存器。 </p>
<p>常用的语义词有：POSITION NORMAL BINORMAL BLENDINDICES TEXCOORD0- TEXCOORD7    PSIZE TANGENT BLENDWEIGHT </p>
<p>如： in float4 modelPos: POSITION 表示该参数的数据是顶点位置坐标（通常位于模型空间），属于输入参数，语义词POSITION是输入语义，如果在OpenGL中则对应为接受应用程序传递的顶点数据的寄存器。</p>
<p>顶点着色程序必须声明一个输出变量并绑定POSITION语义词，该变量中 的数据将被用于,且只被用于光栅化 。<br>为了保持顶点程序输出语义和片段程序输入语义的一致性,通常使用相同的 struct类型数据作为两者之间的传递,这是一种非常方便的写法,推荐使用。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct VertexIn &#123;</div><div class="line">	float4 position : 	POSITION;</div><div class="line">	float4 normal : NORMAL;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct VertexScreen &#123;</div><div class="line">	float4 oPosition : POSITION;</div><div class="line">	float4 objectPos : TEXCOORD0;</div><div class="line">	float4 objectNormal : TEXCOORD1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>【待续……】</p>
<hr>
<p>参考：GPU编程与CG语言之阳春白雪与下里巴人</p>
<p>计算机图形学</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Shader-Language&quot;&gt;&lt;a href=&quot;#Shader-Language&quot; class=&quot;headerlink&quot; title=&quot;Shader Language&quot;&gt;&lt;/a&gt;Shader Language&lt;/h2&gt;&lt;p&gt;shader language，着色
    
    </summary>
    
      <category term="CG" scheme="http://leii.me/categories/CG/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Shader笔记[一]</title>
    <link href="http://leii.me/2016/10/01/Shader%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://leii.me/2016/10/01/Shader笔记一/</id>
    <published>2016-10-01T00:03:29.000Z</published>
    <updated>2016-10-02T03:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>计算机图形学是我们大学专业的必修课，因为是系主任亲自教的当时学的还挺认真的，然而在大学里课程与实践应用脱节比较大，不能学以致用，导致学完忘的也快，直到毕业后发现在游戏开发、以及美图视频类APP中都有很广的应用，又重新翻出课本去看，最近比较空写笔记总结一下。本着要知其然并知其所以然的精神从GPU的历史开始：</p>
</blockquote>
<p>Graphics Processing Unit 是70年代末被提出来，用作图片的合成，80年代末，基于数字信号处理芯片（digital signal processor chip）的GPU研发出来，91年，研制出第一个单芯片2D加速器，98年NVIDIA公司研发modern GPU。 </p>
<p>Modern GPU的发展：</p>
<pre><code>1998，第一代诞生，可以独立于CPU进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三维顶点的空间坐标变换能力，这时的GPU只能用于纹理组合的数学运算或者像素颜色值的计算。
1999-2000，第二代modern GPU，可以进行三维坐标转换和光照计算，并且OpenGL和directX7都提供了开发接口，支持应用程序使用硬件的坐标变换。在此之前只有高级工作站的图形硬件才能支持快速的顶点变换。同时，这一阶段对纹理的操作已经扩展到了立方体纹理。
2001，第三代出现，提供了vertex programmability（可顶点编程）。
2002-2003，第四代modern GPU，代表如NVIDIA 的 GeForce FX和ATI Radeon 9700，都支持vertex programmability和fragment programmability，同时 DirectX 和 OpenGL 也扩展了 自身的 API,用以支持 vertex programmability 和 fragment programmability。 
</code></pre><p>目前最新GPU已经具备如下功能:</p>
<ul>
<li>支持 vertex programmability 和 fragment programmability</li>
<li>支持 IEEE32 位浮点运算</li>
<li>支持 4 元向量,4 阶矩阵计算</li>
<li>提供分支指令,支持循环控制语句</li>
<li>具有高带宽的内存传输能力(&gt;27.1GB/s)</li>
<li>支持 1D、2D、3D 纹理像素查询和使用,且速度极快</li>
<li>支持绘制到纹理功能(Render to Texture,RTT)</li>
</ul>
<p>（其中说了3遍的vertex programmability 和 fragment programmability是本文主线）<br>GPU采用流式并行计算模式，可对每个数据独立计算，但是在依赖其他数据的运算不如CPU。</p>
<h2 id="GPU绘制管线"><a href="#GPU绘制管线" class="headerlink" title="GPU绘制管线"></a>GPU绘制管线</h2><p>图形绘制管线分为3个主要阶段：应用程序阶段、几何阶段、光栅阶段。</p>
<h3 id="1，应用程序阶段"><a href="#1，应用程序阶段" class="headerlink" title="1，应用程序阶段"></a>1，应用程序阶段</h3><p>主要用高级编程语言开发，与CPU内存打交道，如碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段执行。该阶段的末端，几何体数据（顶点坐标、法向量、纹理坐标、纹理等）通过数据总线传到图形硬件。数据总线是一个可以共享的通道，用于多个设备之间传送数据，端口是在两个设备之间传送 数据的通道;带宽用来描述端口或者总线上的吞吐量,可以用每秒字节(b/s) 来度量,数据总线和端口(如加速图形端口,Accelerated Graphic Port,AGP)将 不同的功能模块“粘接”在一起。由于端口和数据总线均具有数据传输能力,因此 通常也将端口认为是数据总线。</p>
<h3 id="2，几何阶段"><a href="#2，几何阶段" class="headerlink" title="2，几何阶段"></a>2，几何阶段</h3><p>这个阶段的主要工作是“变换三维顶点坐标”和“光照计算”，显卡信息中通常会有一个表示“T&amp;L”的硬件部分，即“Transform&amp;Lighting”。</p>
<blockquote>
<p>输入计算机的是一系列三维坐标点，GPU会帮我们转换为二维屏幕上的点，达到“跃然纸面”的效果。<br>坐标类型有以下几种：Object Space 模型坐标空间，World Space 世界坐标空间，Eye Space 观察坐标空间，Clip and Project Space 屏幕坐标空间。<br>转换顺序为：CPU[3D APP or Game -&gt; 3D API(OpenGL/DirectX)] -&gt; GPU[Object Coordinates -&gt; World Coordinates -&gt; Eye Coordinates -&gt; Clip and Project Coordinates]</p>
</blockquote>
<h4 id="2-1-Object-Space-gt-World-Space"><a href="#2-1-Object-Space-gt-World-Space" class="headerlink" title="2.1 Object Space -&gt; World Space"></a>2.1 Object Space -&gt; World Space</h4><p>object space coordinates 是模型文件中的顶点值，建模时得到的，如3DMAX导出的.max文件就包含模型空间坐标，它与其他物体没有任何参照关系（与world space coordinate的主要区别），当模型导入计算机后会给它一个相对坐标原点的位置，这个过程就是模型空间坐标转换为世界空间坐标，由一个四阶矩阵控制，通常称之为world matrix。 (光照计算通常是在世界坐标空间中进行的)</p>
<h4 id="2-2-World-Space-gt-Eye-Space"><a href="#2-2-World-Space-gt-Eye-Space" class="headerlink" title="2.2 World Space -&gt; Eye Space"></a>2.2 World Space -&gt; Eye Space</h4><p>3D游戏中屏幕显示的内容随着视点的变化而变化，是因为GPU将物体顶点坐标从world space 转换为 eye space。eye space 即以camera为原点，由视线方向、视角和远近平面组成的一个梯形的三维空间，称之为viewing frustum视锥，超出这个梯形体的场景数据会被去除 frustum culling 视锥裁剪。</p>
<h4 id="2-3-Eye-Space-gt-Project-and-clip-Space"><a href="#2-3-Eye-Space-gt-Project-and-clip-Space" class="headerlink" title="2.3 Eye Space -&gt; Project and clip Space"></a>2.3 Eye Space -&gt; Project and clip Space</h4><p>转变为屏幕坐标的过程主要为下面3步：</p>
<p>1，用透视变化矩阵把顶点从视锥中变换到裁剪空间的CVV（规范立方体）</p>
<p>2，在CVV中进行图元裁剪</p>
<p>3，屏幕映射：将经过前述过程得到的坐标映射到屏幕坐标系上。<br>    （把顶点从view frustum不规则图形投影到CVV这个过程称为投影，投影分平行投影和透视投影） </p>
<p>Primitive Assembly，图元装配，即将顶点根据原始的连接关系，还原出网格结构，网格由顶点和索引组成,在之前的流水线中是对顶点的处理, 在这个阶段是根据索引将顶点链接在一起,组成线、面单元。之后就是对超出屏 幕外的三角形进行裁剪,想象一下:一个三角形其中一个顶点在画面外,另外两 个顶点在画面内,这是我们在屏幕上看到的就是一个四边形。然后将该四边形切 成两个小的三角形。 此外还有一个操作涉及到三角形的顶点顺序(其实也就是三角形的法向量朝 向),根据右手定则来决定三角面片的法向量,如果该法向量朝向视点(法向量 与到视点的方向的点积为正),则该面是正面。一般是顶点按照逆时针排列。如 果该面是反面,则进行背面去除操作(Back-face Culling)。在 OpenGL 中有专门 的函数 enable 和 disable 背面去除操作。所有的裁剪剔除计算都是为了减少需要 绘制的顶点个数。 </p>
<p>处理三角形的过程被称为 Triangle Setup。到目前位置,我们得到了一堆在 屏幕坐标上的三角面片,这些面片是用于做光栅化的(Rasterizing)。 </p>
<h3 id="3，光栅化阶段"><a href="#3，光栅化阶段" class="headerlink" title="3，光栅化阶段"></a>3，光栅化阶段</h3><h4 id="3-1-光栅化"><a href="#3-1-光栅化" class="headerlink" title="3.1 光栅化:"></a>3.1 光栅化:</h4><p>决定哪些像素被集合图元覆盖的过程(Rasterization is the process of determining the set of pixels covered by a geometric primitive)。经过上面诸多坐标 转换之后,现在我们得到了每个点的屏幕坐标值(Screen coordinate),也知道我 们需要绘制的图元(点、线、面)。但此时还存在两个问题：</p>
<p>问题一:点的屏幕坐标值是浮点数,但像素都是由整数点来表示的,如果确 定屏幕坐标值所对应的像素? </p>
<p>问题二:在屏幕上需要绘制的有点、线、面,如何根据两个已经确定位置的 2 个像素点绘制一条线段,如果根据已经确定了位置的 3 个像素点绘制一个三角 形面片? </p>
<p>答：问题一，四舍五入，例如,一条线段的位置是(10.48,20.51),转换为像<br>素位置则是(10,21) 。</p>
<p>问题二，涉及到画线算法和区域图元填充算法，通常的画线算法有DDA算法和Bresenham画线算法。区域图元算法填充有扫描线多边形填充算法和边界填充算法。</p>
<p>这个过程结束之后，顶点以及绘制图元（线、面）已经对应到像素，接下来要做的就是处理像素：给像素赋予颜色值。</p>
<h4 id="3-2-像素处理"><a href="#3-2-像素处理" class="headerlink" title="3.2 像素处理"></a>3.2 像素处理</h4><p>Pixel operation又称为Raster operation，是在更新帧缓存之前执行的最后一系列针对每个片段的操作，目的是计算每个像素的颜色值，被遮挡面通过一个被称为深度测试的过程而消除掉。主要有以下过程：</p>
<p>1，消除遮挡面。</p>
<p>2，纹理操作，也就是根据像素的纹理坐标，查询相应的纹理值。</p>
<p>3，Blending 混色，根据已经画好的颜色，计算透明度混合为新的颜色输出，称之为alpha混合，为了绘制透明的物体，需要对物体进行排序：首先绘制不透明的物体，然后再不透明的物体上方对透明物体按照又后到前的顺序进行混合处理。排序会用到z buffer 。</p>
<p>4，Filering(滤镜)，再将颜色通过某种滤镜运算载输出新的颜色值。</p>
<h3 id="4，图形硬件"><a href="#4，图形硬件" class="headerlink" title="4，图形硬件"></a>4，图形硬件</h3><p>主要介绍GPU中数据的存放硬件，以及各类缓冲区的具体含义和用途，如：z buffer（深度缓冲区）、stencil buffer（模板缓冲区）、frame buffer （帧缓冲区）和color buffer（颜色缓冲区）</p>
<h4 id="4-1-寄存器"><a href="#4-1-寄存器" class="headerlink" title="4.1 寄存器"></a>4.1 寄存器</h4><p>内存能单独存在而寄存器不能，寄存器是有限存储容量的高速存储，用来暂存指令、数据和地址。shader编程是基于计算机硬件的，包括GPU上的寄存器类型，glsl和hlsl的着色虚拟机版本就是就是基于GPU的寄存器和指令集而区分的。</p>
<h4 id="4-2-Z-Buffer-与Z-值"><a href="#4-2-Z-Buffer-与Z-值" class="headerlink" title="4.2 Z Buffer 与Z 值"></a>4.2 Z Buffer 与Z 值</h4><p>又称深度缓冲区，放的是视点到每个像素点的距离，Z值在【0，1】区间，默认最接近眼睛的顶点Z值是0.0，远裁剪面上的顶点Z值是1.0，使用 z buffer可以用来判断空间点的遮挡关系，Z 值并非真正的笛卡儿空间坐标系中的欧几里德距离(Euclidean distance), 而是一种“顶点到视点距离”的相对度量。 </p>
<p>投影到屏幕坐标的图元内部的点是由已知顶点信息插值而来，所以内部的点的Z值也是插值而来，而透视投影的点做线性插值不符合实际的位置，应该是随着点原来的位置离眼睛越远则偏差越大，为了避免或减轻上述的情况,在设置视点相机远裁减面和近裁减面时,两者 的比值应尽量小于 1000。 </p>
<h4 id="4-3-Stencil-Buffer"><a href="#4-3-Stencil-Buffer" class="headerlink" title="4.3 Stencil Buffer"></a>4.3 Stencil Buffer</h4><p>模板缓冲区，是一个额外的buffer，通常附加到z buffer中，Z buffer 和 stencil buffer 通常在 显存中共享同一片区域。Stencil buffer 对大部分人而言应该比较陌生，这是一个 用来“做记号”的 buffer，每个像素对应一个 stencil buffer(其实就是对应一个 Z buffer)。例如：在一个像素的 stencil buffer 中存放 1，表示该像素对应的空间点处于阴影体(shadow volume)中。 </p>
<h4 id="4-4-Frame-Buffer"><a href="#4-4-Frame-Buffer" class="headerlink" title="4.4 Frame Buffer"></a>4.4 Frame Buffer</h4><p>帧缓冲区，用于存放显示输出的数据，这个buffer的数据一般是像素颜色值。有时候也被认为是color buffer与 z buffer的组合。frame buffer 通常都在显卡上,但是有时显卡会集成到主板上,所以这种情况下 frame buffer 被放在内存区域(general main memory)。</p>
<hr>
<p>参考：GPU编程与CG语言之阳春白雪与下里巴人<br>     计算机图形学</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;计算机图形学是我们大学专业的必修课，因为是系主任亲自教的当时学的还挺认真的，然而在大学里课程与实践应用脱节比较大，不能学以致用，导致学完忘的也快，直到毕业后发现在游戏开发、以及美图视频类APP中都有很广的应用，又重新翻出课本去看，最近比较空写笔记总
    
    </summary>
    
      <category term="CG" scheme="http://leii.me/categories/CG/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>开发手游与开发APP的几点区别</title>
    <link href="http://leii.me/2016/09/29/%E5%BC%80%E5%8F%91%E6%89%8B%E6%B8%B8%E4%B8%8E%E5%BC%80%E5%8F%91APP%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/"/>
    <id>http://leii.me/2016/09/29/开发手游与开发APP的几点区别/</id>
    <published>2016-09-28T16:21:31.000Z</published>
    <updated>2016-10-04T13:41:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>从高中自己做的FLASH小游戏到现在全职做iOS应用的开发，在游戏和应用上都做过了很多尝试，挖过了各种坑，游戏方面的坑有：拼图游戏、射击游戏、基于物理引擎的游戏、消方块类游戏、SLG游戏、赛车游戏等，其中用到的工具/引擎有FLASH、cocos2d-iphone、cocos2d-X、Unity，还有公司自己用JAVA写的安卓游戏引擎。</p>
<p>商用上架的手机应用是从2013年开始写的，到现在为止写过的类型有：股票类、漫画阅览器、类36Kr信息发布平台（一个家政O2O APP），电商类APP、LBS类APP等。</p>
<p>虽然都称不上专家，不过挖了那么久的坑也有不少体会，所以基于自己有限的经验对两者做个比较，也方便自己总结知识点：</p>
<p>1，游戏引擎与系统基础框架，目前国内主流的手机游戏引擎有cocos2d-X和Unity3D，iOS开发时用到系统的Cocoa Touch层和Media层的API较多，而安卓开发主要用到Application Framework这一层的API。</p>
<p>2，游戏引擎注重跨平台，但是不同的引擎功能上差别大；应用基础框架只限于自己的平台，但是功能上iOS安卓大同小异。苹果后来自己研发了用于游戏的API SpriteKit和SceneKit因为不能跨平台用的厂家很少。</p>
<p>3，游戏在客户端的逻辑比较重（因为要自定义很多控件和复杂的交互），应用更多的逻辑放在服务端处理</p>
<p>4，游戏本质上是娱乐产品，给用户提供是APP本身，应用是提供服务的窗口，用作信息的传递和展示</p>
<p>5，多人交互这种强联网类型的游戏主要用长连接（不过也要分具体游戏场景），应用主要是短连接</p>
<p>6，游戏的美术主要分工有：原画、UI、3D、动画、特效、交互等，应用的美术主要是UI和交互</p>
<p>7，游戏在显示层面的工作更多，经常需要用到动画库图形学等，应用在网络层面的工作更多，比如近几年hybrid大热，让native+web的开发成为标配</p>
<p>8，大部分游戏属于小团队开发，产品周期短，所以在工程化以及多人合作开发上的工具和方案都明显比应用要少，特别是Unity在协同开发问题很多，而应用的开发都有比较成熟的项目管理工具（比如iOS的CocoaPod）和组件化方案</p>
<p>9，Unity和cocos2d的热更新主要都是通过Lua实现，iOS主流的热修复工具是JSPatch</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从高中自己做的FLASH小游戏到现在全职做iOS应用的开发，在游戏和应用上都做过了很多尝试，挖过了各种坑，游戏方面的坑有：拼图游戏、射击游戏、基于物理引擎的游戏、消方块类游戏、SLG游戏、赛车游戏等，其中用到的工具/引擎有FLASH、cocos2d-iphone、cocos
    
    </summary>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS近几个版本的主要更新点</title>
    <link href="http://leii.me/2016/09/28/iOS%E8%BF%91%E5%87%A0%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9B%B4%E6%96%B0%E7%82%B9/"/>
    <id>http://leii.me/2016/09/28/iOS近几个版本的主要更新点/</id>
    <published>2016-09-28T13:46:32.000Z</published>
    <updated>2016-10-04T07:38:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>每个版本的iOS更新都会给开发者们带来很多想象和发挥的空间，有的功能可能创造了新的用户场景或者解决了用户诟病很久的问题，当然也有些功能不能被市场接受而无人问津（比如SpriteKit、SceneKit），因为很多成熟的APP都会兼容最近的3个版本的iOS系统，所以有的很棒的新功能出现，被大量主流APP所应用到线上需要几年的时间所以记录下之前版本的更新点以便于在做版本兼容的时候查看，本文主要整理API方面的更新</p>
</blockquote>
<h2 id="iOS10-："><a href="#iOS10-：" class="headerlink" title="iOS10 ："></a>iOS10 ：</h2><h3 id="1，SiriKit"><a href="#1，SiriKit" class="headerlink" title="1，SiriKit"></a>1，SiriKit</h3><p> 支持音频、视频、消息发送接收、搜索照片、预订行程、管理锻炼等等。</p>
<p>主要头文件入口是#import’<intents intents.h="">‘、#import ‘<intentsui intentsui.h="">‘</intentsui></intents></p>
<h3 id="2，Proactive-Suggestions"><a href="#2，Proactive-Suggestions" class="headerlink" title="2，Proactive Suggestions"></a>2，Proactive Suggestions</h3><p> 系统预先建议，头文件主要有：</p>
<p>‘<uikit uitextinputtraits.h="">‘ 输入框</uikit></p>
<p>‘<mediaplayer mpplayablecontentmanager.h="">‘ 视频类</mediaplayer></p>
<p>‘<mapkit mkdirectionsrequest.h="">‘ 地图类</mapkit></p>
<h3 id="3，User-Notifications-用户通知"><a href="#3，User-Notifications-用户通知" class="headerlink" title="3，User Notifications 用户通知"></a>3，User Notifications 用户通知</h3><p>（我在“证书与打包与APNs”这篇博文里有详细介绍）</p>
<p>头文件是’<usernotifications usernotifications.h="">‘</usernotifications></p>
<h3 id="4，Messages-新交互"><a href="#4，Messages-新交互" class="headerlink" title="4，Messages 新交互"></a>4，Messages 新交互</h3><p>Integrating with the Messages App 与系统短信 app交互，可以模拟发消息收消息，发邮件表情包等，提供了UI界面。</p>
<p>头文件入口在’<messages messages.h="">‘</messages></p>
<h3 id="5，Speech-Recognition-语音识别转文字"><a href="#5，Speech-Recognition-语音识别转文字" class="headerlink" title="5，Speech Recognition 语音识别转文字"></a>5，Speech Recognition 语音识别转文字</h3><p>头文件入口在’<speech speech.h="">‘</speech></p>
<h3 id="6，Wide-Color-宽域颜色"><a href="#6，Wide-Color-宽域颜色" class="headerlink" title="6，Wide Color 宽域颜色"></a>6，Wide Color 宽域颜色</h3><p> 大多数的 core字打头的图形框架 还有AVFoundation 都大大提高了对扩展像素和宽色域色彩空间的支持。通过图形堆栈扩展这种方式比以往支持广色域的显示设备更加容易。现在对UIKit扩展可以在sRGB的色彩空间下工作，性能更好，也可以在更广泛的色域来搭配sRGB颜色。</p>
<p>UIColor类里新增了两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);</div><div class="line">- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);</div></pre></td></tr></table></figure>
<h3 id="7，Adapting-to-the-True-Tone-Display-真彩色显示"><a href="#7，Adapting-to-the-True-Tone-Display-真彩色显示" class="headerlink" title="7，Adapting to the True Tone Display 真彩色显示"></a>7，Adapting to the True Tone Display 真彩色显示</h3><p>真彩色的显示会根据光感应器来进行自动的调节来达到特定环境下的显示与性能平衡效果。 如果需要这个功能的话需要再info.plist里配置<br>UIWhitePointAdaptivityStyle<br>共有五种选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIWhitePointAdaptivityStyleStandard 标准</div><div class="line">UIWhitePointAdaptivityStyleReading 阅读</div><div class="line">UIWhitePointAdaptivityStylePhoto 图片</div><div class="line">UIWhitePointAdaptivityStyleVideo 视频</div><div class="line">UIWhitePointAdaptivityStyleGame 游戏</div></pre></td></tr></table></figure>
<h3 id="8，App-Search-Enhancements-应用搜索增强"><a href="#8，App-Search-Enhancements-应用搜索增强" class="headerlink" title="8，App Search Enhancements 应用搜索增强"></a>8，App Search Enhancements 应用搜索增强</h3><p>应用程序内搜索，搜索传递，考虑私人差异，结果可视化。 使用CSSearchQuery类，调用Core Spotlight的api，可以让你不必自己维护自己的搜索索引，关于对搜索关键字的处理，还有考虑到不同类别差异导致搜索结果的排序都是苹果帮你处理。</p>
<p>头文件是’<corespotlight cssearchquery.h="">‘</corespotlight></p>
<h3 id="9，Widget-Enhancements-锁屏部件增强"><a href="#9，Widget-Enhancements-锁屏部件增强" class="headerlink" title="9，Widget Enhancements 锁屏部件增强"></a>9，Widget Enhancements 锁屏部件增强</h3><p>现在锁屏界面有了新的设计，建议我们废弃以前的notificationCenterVibrancyEffect 改用widgetPrimaryVibrancyEffect或者widgetSecondaryVibrancyEffect，并且窗口的小部件可以让你描述有多少东西可用，支持紧凑和扩展两种形态。</p>
<p>‘<notificationcenter notificationcenter.h="">‘ 里面有三个头文件</notificationcenter></p>
<p><img src="http://images2015.cnblogs.com/blog/717809/201606/717809-20160621170857694-1224766609.png" alt="headers"></p>
<h3 id="10，Security-and-Privacy-Enhancements-安全和保密性增强"><a href="#10，Security-and-Privacy-Enhancements-安全和保密性增强" class="headerlink" title="10，Security and Privacy Enhancements 安全和保密性增强"></a>10，Security and Privacy Enhancements 安全和保密性增强</h3><p>安全方面在iOS10中引入了更多修改和补充，具体有以下几点：<br>1.在info.plist文件新增了一个key，NSAllowsArbitraryLoadsInWebContent，允许任意web页面加载，同时苹果会用ATS保护你的app。<br>2.使用改进后的SecKey API 而不是过时的 CDSA API。<br>3.安全传输API中不再支持SSLv3， 建议你们尽快停用SHA1和3DES加密算法。<br>4.剪贴板的扩展，因为wwdc2016演示了可以跨设备复制粘贴啊，那肯定要做一些限制可见（#import <uikit uipasteboard.h="">）<br>5.这点最重要的，建议尽快适配， 所有和用户权限相关的地方必须在info.plist里配置里面包括</uikit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSBluetoothPeripheralUsageDescription</div><div class="line">NSCalendarsUsageDescription</div><div class="line">NSCameraUsageDescription</div><div class="line">NSContactsUsageDescription</div><div class="line">NSHealthShareUsageDescription</div><div class="line">NSHealthUpdateUsageDescription</div><div class="line">NSHomeKitUsageDescription</div><div class="line">NSLocationAlwaysUsageDescription</div><div class="line">NSLocationWhenInUseUsageDescription</div><div class="line">NSMicrophoneUsageDescription</div><div class="line">NSMotionUsageDescription</div><div class="line">NSPhotoLibraryUsageDescription</div><div class="line">NSRemindersUsageDescription</div><div class="line">NSSiriUsageDescription</div><div class="line">NSSpeechRecognitionUsageDescription</div><div class="line">NSVideoSubscriberAccountUsageDescription</div><div class="line">NSVoIPUsageDescription</div></pre></td></tr></table></figure>
<h3 id="11，HomeKit-再次更新"><a href="#11，HomeKit-再次更新" class="headerlink" title="11，HomeKit 再次更新"></a>11，HomeKit 再次更新</h3><p>可以使你的手机连接支持homeKit的智能硬件，（没有的话你可以使用HomeKit Accessroy Simulator来模拟home中的智能电器），Demo教程看<a href="http://www.cocoachina.com/ios/20150324/11411.html" target="_blank" rel="external">这里</a> </p>
<p><a href="https://developer.apple.com/reference/homekit?language=objc" target="_blank" rel="external">官方文档</a></p>
<h2 id="iOS9"><a href="#iOS9" class="headerlink" title="iOS9"></a>iOS9</h2><h3 id="1，Multitasking"><a href="#1，Multitasking" class="headerlink" title="1，Multitasking"></a>1，Multitasking</h3><p>iPad支持新的Multitasking，包括Slide Over, Split View和Picture in Picture，视频需要迁移到 AVKit 的框架</p>
<h3 id="2，XCUITest"><a href="#2，XCUITest" class="headerlink" title="2，XCUITest"></a>2，XCUITest</h3><p>XCUI 使用 Accessibility 标记来确定 view，但因为是 Apple 自家的东西，它可以自动记录你的操作流程，所以你只需要书写最后的验证部分就可以了，比其他的 UI 测试工具方便很多。</p>
<h3 id="3，Search"><a href="#3，Search" class="headerlink" title="3，Search"></a>3，Search</h3><p>主要是spotlight开放了部分api，可以搜索app中的内容。</p>
<h3 id="4，SceneKit-SpriteKit-and-Metal的更新"><a href="#4，SceneKit-SpriteKit-and-Metal的更新" class="headerlink" title="4，SceneKit, SpriteKit, and Metal的更新"></a>4，SceneKit, SpriteKit, and Metal的更新</h3><p>还有GameplayKit，ReplayKit（游戏录像），Model I/O。</p>
<h3 id="5，HomeKit，CloudKit，HealthKit-等"><a href="#5，HomeKit，CloudKit，HealthKit-等" class="headerlink" title="5，HomeKit，CloudKit，HealthKit 等"></a>5，HomeKit，CloudKit，HealthKit 等</h3><p>这几个框架的更新。</p>
<h3 id="6，Swift-2"><a href="#6，Swift-2" class="headerlink" title="6，Swift 2"></a>6，Swift 2</h3><p>更新并开源</p>
<h3 id="7，bitcode"><a href="#7，bitcode" class="headerlink" title="7，bitcode"></a>7，bitcode</h3><p>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
<h3 id="8，App-Transport-Security"><a href="#8，App-Transport-Security" class="headerlink" title="8，App Transport Security"></a>8，App Transport Security</h3><p>NSAllowsArbitraryLoads默认使用了HTTPS协议进行传输</p>
<h3 id="9，RUL-scheme"><a href="#9，RUL-scheme" class="headerlink" title="9，RUL scheme"></a>9，RUL scheme</h3><p>iOS9需要将你要在外部调用的URL scheme列为白名单，才可以完成跳转</p>
<h3 id="10，Contacts-Framework"><a href="#10，Contacts-Framework" class="headerlink" title="10，Contacts Framework"></a>10，Contacts Framework</h3><p>新增Contacts Framework，与此同时废除AddressBookUI Framework</p>
<h3 id="11，-Watch-Connectivity"><a href="#11，-Watch-Connectivity" class="headerlink" title="11， Watch Connectivity"></a>11， Watch Connectivity</h3><p>由于watchOS 2的架构变化，用来对iPhone和Watch进行双向通信</p>
<h3 id="12，Safari-Services-Framework"><a href="#12，Safari-Services-Framework" class="headerlink" title="12，Safari Services Framework"></a>12，Safari Services Framework</h3><p>可以让Safari以一个Controller的形式加载你的网页，和系统的Safari完全共享Cookie和Autofill等特性，最重要的，Safari的JavaScript引擎。在你的app需要展示一个WebView又不需要太多定制的时候，用它来替换掉你现在在用的UIWebView或者WKWebView。</p>
<h3 id="13，UIKit方面的一些提升，比如UIStackView，NSDataAsset"><a href="#13，UIKit方面的一些提升，比如UIStackView，NSDataAsset" class="headerlink" title="13，UIKit方面的一些提升，比如UIStackView，NSDataAsset"></a>13，UIKit方面的一些提升，比如UIStackView，NSDataAsset</h3><h3 id="14，Objective-C-（2015）语言的新特性："><a href="#14，Objective-C-（2015）语言的新特性：" class="headerlink" title="14，Objective-C （2015）语言的新特性："></a>14，Objective-C （2015）语言的新特性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">1、Nullability</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSArray *__nonull names;</div><div class="line">@property (nonatomic, strong, nonnull) NSarray *names;</div><div class="line"></div><div class="line">2、Lightweight Generics * 泛型</div><div class="line"></div><div class="line">NSMutableArray&lt;NSString *&gt; *names;</div><div class="line">NSMutableDictionary&lt;NSString *, NSNumber *&gt; *book;</div><div class="line">NSMutableArray&lt;ObjectType&gt; :</div><div class="line">限制数组只能装字符串，有确定的类型。可以用点语法。自定义泛型。</div><div class="line">泛型的类型可以自己定义，自定义的类添加泛型。协变性，和继承有关系。小类型（子类）-&gt;大类型（父类）__covariant 该怎么去学习。泛型好处取出不是id类型，可以用点语法。</div><div class="line"></div><div class="line">3、__kindof</div><div class="line"></div><div class="line">返回值是id的问题，错了么有警告，潜在问题。所以要写清楚类型。</div><div class="line">做SDK的时候，实现别人看不到。cell 的类型不确定，所以用id。返回不用强制转换。</div><div class="line">返回值可以是他，也可以是他的子类。不用强制转换。方便开发。</div></pre></td></tr></table></figure>
<h2 id="iOS-8"><a href="#iOS-8" class="headerlink" title="iOS 8"></a>iOS 8</h2><h3 id="1，自定义键盘"><a href="#1，自定义键盘" class="headerlink" title="1，自定义键盘"></a>1，自定义键盘</h3><p>支持第三方输入法，你可以为用户提供带有不同输入法和布局的自定义键盘。</p>
<h3 id="2，UIActionSheet-and-UIAlertView-的升级"><a href="#2，UIActionSheet-and-UIAlertView-的升级" class="headerlink" title="2，UIActionSheet and UIAlertView 的升级"></a>2，UIActionSheet and UIAlertView 的升级</h3><p>在iOS8里面，官方提供了新的类UIAlertController来替换UIActionSheet and UIAlertView。</p>
<h3 id="3，Today"><a href="#3，Today" class="headerlink" title="3，Today"></a>3，Today</h3><p>应用可在通知中心的Today视图中展示插件，快速更新或者启动任务，查看包裹寄送情况、最近的上网记录或者即时新闻。</p>
<h3 id="4，Storage-Provider"><a href="#4，Storage-Provider" class="headerlink" title="4，Storage Provider"></a>4，Storage Provider</h3><p>开发者可提供一个能被其他应用访问的文档储存位置。使用文档选择器view controller的应用可以打开由storage provider管理的文档，或者把文档移动到storage provider。</p>
<h3 id="5，touchID"><a href="#5，touchID" class="headerlink" title="5，touchID"></a>5，touchID</h3><p>你可以选择Touch ID登陆第三方应用程序，不需要输入密码，你的指纹数据是被保护的，在没有被允许的情况下别的程序是访问不到它的。</p>
<h3 id="6，分享"><a href="#6，分享" class="headerlink" title="6，分享"></a>6，分享</h3><p>通过提供更多分享选项，iOS 8允许你的应用把照片、视频、网站以及其他内容分享至社交网站或者其他实体。</p>
<h3 id="7，Custom-Actions"><a href="#7，Custom-Actions" class="headerlink" title="7，Custom Actions"></a>7，Custom Actions</h3><p>在Action页面创建自定义action按钮，以便用户给文档添加水印、更新愿望列表，或者把文本转换成不同的语言等。</p>
<h3 id="8，App-Extensions"><a href="#8，App-Extensions" class="headerlink" title="8，App Extensions"></a>8，App Extensions</h3><p>应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他app时使用该项功能。你可以开发一个应用扩展来执行某些特定的任务，用户使用该扩展后就可以在多个上下文环境中执行该任务。</p>
<h3 id="9，PhotoKit"><a href="#9，PhotoKit" class="headerlink" title="9，PhotoKit"></a>9，PhotoKit</h3><p>PhotoKit为使用照片和视频资源提供了新的API，包括由Photos app管理的iCloud Photos资产,所以你可以在“Camera roll”中直接编辑照片，无需提前导入。PhotoKit还包含一个线程安全架构用以获取、缓存缩略图和全尺寸图片，请求资产更改，遵守其他应用所做的变化，以及对资产内容进行可恢复的编辑。</p>
<h3 id="10，Manual-Camera-Controls"><a href="#10，Manual-Camera-Controls" class="headerlink" title="10，Manual Camera Controls"></a>10，Manual Camera Controls</h3><p>AVFoundation框架让拍照变得前所未有的容易。你的应用可以直接控制相机对焦、白平衡以及曝光设置等。应用程序也可以通过包围曝光 (Bracket Exposure)使用不同的曝光设置自动拍摄照片。</p>
<h3 id="11，HealthKit"><a href="#11，HealthKit" class="headerlink" title="11，HealthKit"></a>11，HealthKit</h3><p>HealthKit允许提供健康和健身服务的应用在一个地方访问共享的健康相关信息。用户的健康信息储存在一个集中的安全的地方，用户可以决定和你的应用分享哪些数据。你的应用可访问任何共享的健康相关的信息，并提供关于用户的信息，无需提供对特定健身跟踪设备的专门支持。信息可来自连接至iOS设备的设备，或者由用户手动输入。</p>
<h3 id="12，Metal"><a href="#12，Metal" class="headerlink" title="12，Metal"></a>12，Metal</h3><p>Metal可以使开发者低成本最大限度地发挥A7 GPU的性能，实现了难以令人置信的复杂图形渲染和计算任务，消除了传统图形API中的多个性能瓶颈。Metal提供了精简的API，统一的图形和着色语言以及一个基于Xcode 的工具。许多游戏引擎制造商都已经宣布支持 Metal，比如 Crytek、Unity以及Epic Games。Metal可以将应用的表现和性能带到一个新的水</p>
<hr>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/dsxniubility/p/5596973.html" target="_blank" rel="external">对iOS10新增Api的详细探究</a></p>
<p><a href="http://www.cocoachina.com/ios/20150324/11411.html" target="_blank" rel="external">HomeKit 开发指南（中文版）</a></p>
<p><a href="https://onevcat.com/2015/06/ios9-sdk/" target="_blank" rel="external">开发者所需要知道的 iOS 9 SDK 新特性</a></p>
<p><a href="http://www.cocoachina.com/special/ios8/" target="_blank" rel="external">iOS8开发者手册</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每个版本的iOS更新都会给开发者们带来很多想象和发挥的空间，有的功能可能创造了新的用户场景或者解决了用户诟病很久的问题，当然也有些功能不能被市场接受而无人问津（比如SpriteKit、SceneKit），因为很多成熟的APP都会兼容最近的3个版本的
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>[转]iOS上使用OpenCV</title>
    <link href="http://leii.me/2016/09/20/iOS%E4%B8%8A%E4%BD%BF%E7%94%A8OpenCV/"/>
    <id>http://leii.me/2016/09/20/iOS上使用OpenCV/</id>
    <published>2016-09-20T07:12:13.000Z</published>
    <updated>2016-09-22T09:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="https://objccn.io/issue-21-9/" target="_blank" rel="external">基于 OpenCV 的人脸识别</a></p>
<h4 id="OpenCV-概述"><a href="#OpenCV-概述" class="headerlink" title="OpenCV 概述"></a>OpenCV 概述</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>OpenCV 的 API 是 C++ 的。它由不同的模块组成，这些模块中包含范围极为广泛的各种方法，从底层的图像颜色空间转换到高层的机器学习工具。</p>
<p>OC和Swift不能直接调用OpenCV，这篇<a href="http://docs.opencv.org/2.4/doc/tutorials/ios/video_processing/video_processing.html#opencviosvideoprocessing" target="_blank" rel="external">OpenCV的iOS教程</a>讲解了把OpenCV的类的文件名后缀都改成.mm然后用Objective-C++调用的方法，但是功能好的方法是给所有你要在 app 中使用到的 OpenCV 功能写一层 Objective-C++ 封装。这些 Objective-C++ 封装把 OpenCV 的 C++ API 转化为安全的 Objective-C API，以方便地在所有 Objective-C 类中使用。</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>下面是在<a href="http://docs.opencv.org/2.4/modules/core/doc/intro.html" target="_blank" rel="external">官方文档</a>中列出的最重要的模块。</p>
<ul>
<li>core：简洁的核心模块，定义了基本的数据结构，包括稠密多维数组 Mat 和其他模块需要的基本函数。</li>
<li>imgproc：图像处理模块，包括线性和非线性图像滤波、几何图像转换 (缩放、仿射与透视变换、一般性基于表的重映射)、颜色空间转换、直方图等等。</li>
<li>video：视频分析模块，包括运动估计、背景消除、物体跟踪算法。</li>
<li>calib3d：包括基本的多视角几何算法、单体和立体相机的标定、对象姿态估计、双目立体匹配算法和元素的三维重建。</li>
<li>features2d：包含了显著特征检测算法、描述算子和算子匹配算法。</li>
<li>objdetect：物体检测和一些预定义的物体的检测 (如人脸、眼睛、杯子、人、汽车等)。</li>
<li>ml：多种机器学习算法，如 K 均值、支持向量机和神经网络。</li>
<li>highgui：一个简单易用的接口，提供视频捕捉、图像和视频编码等功能，还有简单的 UI 接口 (iOS 上可用的仅是其一个子集)。</li>
<li>gpu：OpenCV 中不同模块的 GPU 加速算法 (iOS 上不可用)。</li>
<li>ocl：使用 OpenCL 实现的通用算法 (iOS 上不可用)。<br>一些其它辅助模块，如 Python 绑定和用户贡献的算法。</li>
</ul>
<h5 id="基础类和操作"><a href="#基础类和操作" class="headerlink" title="基础类和操作"></a>基础类和操作</h5><p>OpenCV 包含几百个类。为简便起见，我们只看几个基础的类和操作，进一步阅读请参考<a href="http://docs.opencv.org/2.4/modules/core/doc/core.html" target="_blank" rel="external">全部文档</a>。过一遍这几个核心类应该足以对这个库的机理产生一些感觉认识。</p>
<h6 id="cv-Mat"><a href="#cv-Mat" class="headerlink" title="cv::Mat"></a>cv::Mat</h6><p>cv::Mat 是 OpenCV 的核心数据结构，用来表示任意 N 维矩阵。因为图像只是 2 维矩阵的一个特殊场景，所以也是使用 cv::Mat 来表示的。也就是说，cv::Mat 将是你在 OpenCV 中用到最多的类。</p>
<p>一个 cv::Mat 实例的作用就像是图像数据的头，其中包含着描述图像格式的信息。图像数据只是被引用，并能为多个 cv::Mat 实例共享。OpenCV 使用类似于 ARC 的引用计数方法，以保证当最后一个来自 cv::Mat 的引用也消失的时候，图像数据会被释放。图像数据本身是图像连续的行的数组 (对 N 维矩阵来说，这个数据是由连续的 N-1 维数据组成的数组)。使用 step[] 数组中包含的值，图像的任一像素地址都可通过下面的指针运算得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uchar *pixelPtr = cvMat.data + rowIndex * cvMat.step[0] + colIndex * cvMat.step[1]</div></pre></td></tr></table></figure>
<p>每个像素的数据格式可以通过 type() 方法获得。除了常用的每通道 8 位无符号整数的灰度图 (1 通道，CV_8UC1) 和彩色图 (3 通道，CV_8UC3)，OpenCV 还支持很多不常用的格式，例如 CV_16SC3 (每像素 3 通道，每通道使用 16 位有符号整数)，甚至 CV_64FC4 (每像素 4 通道，每通道使用 64 位浮点数)。</p>
<h6 id="cv-Algorithm"><a href="#cv-Algorithm" class="headerlink" title="cv::Algorithm"></a>cv::Algorithm</h6><p>Algorithm 是 OpenCV 中实现的很多算法的抽象基类，包括将在我们的 demo 工程中用到的 FaceRecognizer。它提供的 API 与苹果的 Core Image 框架中的 CIFilter 有些相似之处。创建一个 Algorithm 的时候使用算法的名字来调用 Algorithm::create()，并且可以通过 get() 和 set()方法来获取和设置各个参数，这有点像是键值编码。另外，Algorithm 从底层就支持从/向 XML 或 YAML 文件加载/保存参数的功能。</p>
<h4 id="在-iOS-上使用-OpenCV"><a href="#在-iOS-上使用-OpenCV" class="headerlink" title="在 iOS 上使用 OpenCV"></a>在 iOS 上使用 OpenCV</h4><h5 id="添加-OpenCV-到你的工程中"><a href="#添加-OpenCV-到你的工程中" class="headerlink" title="添加 OpenCV 到你的工程中"></a>添加 OpenCV 到你的工程中</h5><p>集成 OpenCV 到你的工程中有三种方法：</p>
<p>*使用 CocoaPods 就好： pod “OpenCV”。</p>
<p>*下载官方 <a href="http://opencv.org/downloads.html" target="_blank" rel="external">iOS 框架发行包</a>，并把它添加到工程里。</p>
<p>*从 <a href="https://github.com/Itseez/opencv" target="_blank" rel="external">GitHub</a> 拉下代码，并根据<a href="http://docs.opencv.org/2.4/doc/tutorials/introduction/ios_install/ios_install.html#ios-installation" target="_blank" rel="external">教程</a>自己编译 OpenCV 库。</p>
<h5 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C++"></a>Objective-C++</h5><p>如前面所说，OpenCV 是一个 C++ 的 API，因此不能直接在 Swift 和 Objective-C 代码中使用，但能在 Objective-C++ 文件中使用。</p>
<p>Objective-C++ 是 Objective-C 和 C++ 的混合物，让你可以在 Objective-C 类中使用 C++ 对象。clang 编译器会把所有后缀名为 .mm 的文件都当做是 Objective-C++。一般来说，它会如你所期望的那样运行，但还是有一些使用 Objective-C++ 的注意事项。内存管理是你最应该格外注意的点，因为 ARC 只对 Objective-C 对象有效。当你使用一个 C++ 对象作为类属性的时候，其唯一有效的属性就是 assign。因此，你的 dealloc 函数应确保 C++ 对象被正确地释放了。</p>
<p>第二重要的点就是，如果你在 Objective-C++ 头文件中引入了 C++ 头文件，当你在工程中使用该 Objective-C++ 文件的时候就泄露了 C++ 的依赖。任何引入你的 Objective-C++ 类的 Objective-C 类也会引入该 C++ 类，因此该 Objective-C 文件也要被声明为 Objective-C++ 的文件。这会像森林大火一样在工程中迅速蔓延。所以，应该把你引入 C++ 文件的地方都用 #ifdef __cplusplus 包起来，并且只要可能，就尽量只在 .mm 实现文件中引入 C++ 头文件。</p>
<p>要获得更多如何混用 C++ 和 Objective-C 的细节，请查看 Matt Galloway 写的这篇<a href="http://www.raywenderlich.com/62989/introduction-c-ios-developers-part-1" target="_blank" rel="external">教程</a>。</p>
<h4 id="Demo：人脸检测与识别"><a href="#Demo：人脸检测与识别" class="headerlink" title="Demo：人脸检测与识别"></a>Demo：人脸检测与识别</h4><p>现在，我们对 OpenCV 及如何把它集成到我们的应用中有了大概认识，那让我们来做一个小 demo 应用：从 iPhone 的摄像头获取视频流，对它持续进行人脸检测，并在屏幕上标出来。当用户点击一个脸孔时，应用会尝试识别这个人。如果识别结果正确，用户必须点击 “Correct”。如果识别错误，用户必须选择正确的人名来纠正错误。我们的人脸识别器就会从错误中学习，变得越来越好。</p>
<p><img src="https://objccn.io/images/issues/issue-21/blocks-face-recognition-objcio.jpg" alt="pic 1"></p>
<p>本 demo 应用的源码可从 <a href="https://github.com/objcio/issue-21-OpenCV-FaceRec" target="_blank" rel="external">GitHub</a> 获得。</p>
<h5 id="视频拍摄"><a href="#视频拍摄" class="headerlink" title="视频拍摄"></a>视频拍摄</h5><p>OpenCV 的 highgui 模块中有个类，CvVideoCamera，它把 iPhone 的摄像机抽象出来，让我们的 app 通过一个代理函数 - (void)processImage:(cv::Mat&amp;)image 来获得视频流。CvVideoCamera 实例可像下面这样进行设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CvVideoCamera *videoCamera = [[CvVideoCamera alloc] initWithParentView:view];</div><div class="line">videoCamera.defaultAVCaptureDevicePosition = AVCaptureDevicePositionFront;</div><div class="line">videoCamera.defaultAVCaptureSessionPreset = AVCaptureSessionPreset640x480;</div><div class="line">videoCamera.defaultAVCaptureVideoOrientation = AVCaptureVideoOrientationPortrait;</div><div class="line">videoCamera.defaultFPS = 30;</div><div class="line">videoCamera.grayscaleMode = NO;</div><div class="line">videoCamera.delegate = self;</div></pre></td></tr></table></figure>
<p>摄像头的帧率被设置为 30 帧每秒， 我们实现的 processImage 函数将每秒被调用 30 次。因为我们的 app 要持续不断地检测人脸，所以我们应该在这个函数里实现人脸的检测。要注意的是，如果对某一帧进行人脸检测的时间超过 1/30 秒，就会产生掉帧现象。</p>
<h5 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h5><p>其实你并不需要使用 OpenCV 来做人脸检测，因为 Core Image 已经提供了 CIDetector 类。用它来做人脸检测已经相当好了，并且它已经被优化过，使用起来也很容易：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CIDetector *faceDetector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:@&#123;CIDetectorAccuracy: CIDetectorAccuracyHigh&#125;];</div><div class="line"></div><div class="line">NSArray *faces = [faceDetector featuresInImage:image];</div></pre></td></tr></table></figure>
<p>从该图片中检测到的每一张面孔都在数组 faces 中保存着一个 CIFaceFeature 实例。这个实例中保存着这张面孔的所处的位置和宽高，除此之外，眼睛和嘴的位置也是可选的。</p>
<p>另一方面，OpenCV 也提供了一套物体检测功能，经过训练后能够检测出任何你需要的物体。该库为多个场景自带了可以直接拿来用的检测参数，如人脸、眼睛、嘴、身体、上半身、下半身和笑脸。检测引擎由一些非常简单的检测器的级联组成。这些检测器被称为 Haar 特征检测器，它们各自具有不同的尺度和权重。在训练阶段，决策树会通过已知的正确和错误的图片进行优化。关于训练与检测过程的详情可参考此<a href="http://www.multimedia-computing.de/mediawiki//images/5/52/MRL-TR-May02-revised-Dec02.pdf" target="_blank" rel="external">原始论文</a>。当正确的特征级联及其尺度与权重通过训练确立以后，这些参数就可被加载并初始化级联分类器了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 正面人脸检测器训练参数的文件路径</div><div class="line">NSString *faceCascadePath = [[NSBundle mainBundle] pathForResource:@&quot;haarcascade_frontalface_alt2&quot;</div><div class="line">                                                   ofType:@&quot;xml&quot;];</div><div class="line"></div><div class="line">const CFIndex CASCADE_NAME_LEN = 2048;</div><div class="line">char *CASCADE_NAME = (char *) malloc(CASCADE_NAME_LEN);</div><div class="line">CFStringGetFileSystemRepresentation( (CFStringRef)faceCascadePath, CASCADE_NAME, CASCADE_NAME_LEN);</div><div class="line"></div><div class="line">CascadeClassifier faceDetector;</div><div class="line">faceDetector.load(CASCADE_NAME);</div></pre></td></tr></table></figure>
<p>这些参数文件可在 OpenCV 发行包里的 data/haarcascades 文件夹中找到。</p>
<p>在使用所需要的参数对人脸检测器进行初始化后，就可以用它进行人脸检测了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cv::Mat img;</div><div class="line">vector&lt;cv::Rect&gt; faceRects;</div><div class="line">double scalingFactor = 1.1;</div><div class="line">int minNeighbors = 2;</div><div class="line">int flags = 0;</div><div class="line">cv::Size minimumSize(30,30);</div><div class="line">faceDetector.detectMultiScale(img, faceRects,</div><div class="line">                              scalingFactor, minNeighbors, flags</div><div class="line">                              cv::Size(30, 30) );</div></pre></td></tr></table></figure>
<p>检测过程中，已训练好的分类器会用不同的尺度遍历输入图像的每一个像素，以检测不同大小的人脸。参数 scalingFactor 决定每次遍历分类器后尺度会变大多少倍。参数 minNeighbors 指定一个符合条件的人脸区域应该有多少个符合条件的邻居像素才被认为是一个可能的人脸区域；如果一个符合条件的人脸区域只移动了一个像素就不再触发分类器，那么这个区域非常可能并不是我们想要的结果。拥有少于 minNeighbors 个符合条件的邻居像素的人脸区域会被拒绝掉。如果 minNeighbors 被设置为 0，所有可能的人脸区域都会被返回回来。参数 flags 是 OpenCV 1.x 版本 API 的遗留物，应该始终把它设置为 0。最后，参数 minimumSize 指定我们所寻找的人脸区域大小的最小值。faceRects 向量中将会包含对 img 进行人脸识别获得的所有人脸区域。识别的人脸图像可以通过 cv::Mat 的 () 运算符提取出来，调用方式很简单：cv::Mat faceImg = img(aFaceRect)。</p>
<p>不管是使用 CIDetector 还是 OpenCV 的 CascadeClassifier，只要我们获得了至少一个人脸区域，我们就可以对图像中的人进行识别了。</p>
<h5 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h5><p>OpenCV 自带了三个人脸识别算法：Eigenfaces，Fisherfaces 和局部二值模式直方图 (LBPH)。如果你想知道它们的工作原理及相互之间的区别，请阅读 OpenCV 的<a href="http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms" target="_blank" rel="external">详细文档</a>。</p>
<p>针对于我们的 demo app，我们将采用 LBPH 算法。因为它会根据用户的输入自动更新，而不需要在每添加一个人或纠正一次出错的判断的时候都要重新进行一次彻底的训练。</p>
<p>要使用 LBPH 识别器，我们也用 Objective-C++ 把它封装起来。这个封装中暴露以下函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (FJFaceRecognizer *)faceRecognizerWithFile:(NSString *)path;</div><div class="line">- (NSString *)predict:(UIImage*)img confidence:(double *)confidence;</div><div class="line">- (void)updateWithFace:(UIImage *)img name:(NSString *)name;</div></pre></td></tr></table></figure>
<p>像下面这样用工厂方法来创建一个 LBPH 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (FJFaceRecognizer *)faceRecognizerWithFile:(NSString *)path &#123;</div><div class="line">    FJFaceRecognizer *fr = [FJFaceRecognizer new];</div><div class="line">    fr-&gt;_faceClassifier = createLBPHFaceRecognizer();</div><div class="line">    fr-&gt;_faceClassifier-&gt;load(path.UTF8String);</div><div class="line">    return fr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>预测函数可以像下面这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSString *)predict:(UIImage*)img confidence:(double *)confidence &#123;</div><div class="line">    cv::Mat src = [img cvMatRepresentationGray];</div><div class="line">    int label;</div><div class="line">    self-&gt;_faceClassifier-&gt;predict(src, label, *confidence);</div><div class="line">    return _labelsArray[label];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，我们要使用一个类别方法把 UIImage 转化为 cv::Mat。此转换本身倒是相当简单直接：使用 CGBitmapContextCreate 创建一个指向 cv::Image 中的 data 指针所指向的数据的 CGContextRef。当我们在此图形上下文中绘制此 UIImage 的时候，cv::Image 的 data 指针所指就是所需要的数据。更有趣的是，我们能对一个 Objective-C 类创建一个 Objective-C++ 的类别，并且确实管用。</p>
<p>另外，OpenCV 的人脸识别器仅支持整数标签，但是我们想使用人的名字作标签，所以我们得通过一个 NSArray 属性来对二者实现简单的转换。</p>
<p>一旦识别器给了我们一个识别出来的标签，我们把此标签给用户看，这时候就需要用户给识别器一个反馈。用户可以选择，“是的，识别正确”，也可以选择，“不，这是 Y，不是 X”。在这两种情况下，我们都可以通过人脸图像和正确的标签来更新 LBPH 模型，以提高未来识别的性能。使用用户的反馈来更新人脸识别器的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)updateWithFace:(UIImage *)img name:(NSString *)name &#123;</div><div class="line">    cv::Mat src = [img cvMatRepresentationGray];</div><div class="line">    NSInteger label = [_labelsArray indexOfObject:name];</div><div class="line">    if (label == NSNotFound) &#123;</div><div class="line">        [_labelsArray addObject:name];</div><div class="line">        label = [_labelsArray indexOfObject:name];</div><div class="line">    &#125;</div><div class="line">    vector&lt;cv::Mat&gt; images = vector&lt;cv::Mat&gt;();</div><div class="line">    images.push_back(src);</div><div class="line">    vector&lt;int&gt; labels = vector&lt;int&gt;();</div><div class="line">    labels.push_back((int)label);</div><div class="line">    self-&gt;_faceClassifier-&gt;update(images, labels);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，我们又做了一次了从 UIImage 到 cv::Mat、int 到 NSString 标签的转换。我们还得如 OpenCV 的 FaceRecognizer::update API所期望的那样，把我们的参数放到 std::vector 实例中去。</p>
<p>如此“预测，获得反馈，更新循环”，就是文献上所说的<a href="http://zh.wikipedia.org/wiki/%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92" target="_blank" rel="external">监督式学习</a>。</p>
<hr>
<p>英文原文 <a href="https://www.objc.io/issues/21-camera-and-photos/face-recognition-with-opencv/" target="_blank" rel="external"> Face Recognition with OpenCV</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;https://objccn.io/issue-21-9/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;基于 OpenCV 的人脸识别&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;OpenCV-概述&quot;&gt;&lt;a href=&quot;#OpenCV-概述&quot; 
    
    </summary>
    
      <category term="CG" scheme="http://leii.me/categories/CG/"/>
    
    
      <category term="转" scheme="http://leii.me/tags/%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>URL Loading System</title>
    <link href="http://leii.me/2016/09/15/URL-Loading-System/"/>
    <id>http://leii.me/2016/09/15/URL-Loading-System/</id>
    <published>2016-09-15T15:55:29.000Z</published>
    <updated>2016-09-22T09:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>URL Loading System的类主要有以下几种： </p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="url loading system"></p>
<p>其中最重要的3个类分别是NSURLConnection、NSURLSession、NSURLProtocol。</p>
<h5 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h5><p>NSURLConnection 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。</p>
<p>NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <nsurlconnectiondelegate> 和 <nsurlconnectiondatadelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。</nsurlconnectiondatadelegate></nsurlconnectiondelegate></p>
<p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>
<p><img src="http://images.cnitblog.com/i/450136/201406/281617337427186.png" alt="NSURLConnection Pic1"></p>
<p>下面是GET同步请求与异步请求的实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//    GET请求：请求行\请求头\请求体</div><div class="line">//</div><div class="line">//    1.设置请求路径</div><div class="line">     NSString *urlStr= [NSString stringWithFormat: @&quot;http://leii.me/login?username=%@&amp;pwd=%@&quot;,self.username.text,self.pwd.text];</div><div class="line">     NSURL *url=[NSURL URLWithString:urlStr];</div><div class="line">//    2.创建请求对象</div><div class="line">    NSURLRequest *request=[NSURLRequest requestWithURL:url];</div><div class="line">//    3.发送请求</div><div class="line">    //发送同步请求，在主线程执行</div><div class="line">    NSData *data=[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];</div><div class="line">    //（一直在等待服务器返回数据，这行代码会卡住，如果服务器没有返回数据，那么在主线程UI会卡住不能继续执行操作）</div><div class="line">    NSLog(@&quot;同步请求结果：--%d--&quot;,data.length);</div><div class="line">    </div><div class="line">    //发送异步请求</div><div class="line">    //创建一个队列（默认添加到该队列中的任务异步执行）</div><div class="line">//    NSOperationQueue *queue=[[NSOperationQueue alloc]init];</div><div class="line">    //获取一个主队列</div><div class="line">    NSOperationQueue *queue=[NSOperationQueue mainQueue];</div><div class="line">    [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;</div><div class="line">    //通过block异步获取response</div><div class="line">        NSLog(@&quot;--block异步回调数据--%@---%d&quot;, [NSThread currentThread],data.length);</div><div class="line">    &#125;）；</div></pre></td></tr></table></figure>
<p>还可以使用代理方法发送异步请求</p>
<p>要监听服务器返回的data，所以使用<nsurlconnectiondatadelegate>协议</nsurlconnectiondatadelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#pragma mark- NSURLConnectionDataDelegate代理方法</div><div class="line"></div><div class="line">//当接收到服务器的响应（连通了服务器）时会调用</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</div><div class="line"></div><div class="line">//当接收到服务器的数据时会调用（可能会被调用多次，每次只传递部分数据）</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data</div><div class="line"></div><div class="line">//当服务器的数据加载完毕时就会调用</div><div class="line"></div><div class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection</div><div class="line"></div><div class="line">//请求错误（失败）的时候调用（请求超时\断网\没有网\，一般指客户端错误）</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</div></pre></td></tr></table></figure>
<h5 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h5><p>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。</p>
<p>NSURLSession也是一组相互依赖的类，它的大部分组件和NSURLConnection中的组件相同如NSURLRequest，NSURLCache等。而NSURLSession的不同之处在于，它将NSURLConnection替换为NSURLSession和NSURLSessionConfiguration，以及3个NSURLSessionTask的子类：NSURLSessionDataTask, NSURLSessionUploadTask, 和NSURLSessionDownloadTask。</p>
<p>下面是新推出的类：</p>
<p>1.NSURLSessionConfiguration类</p>
<p>其中NSURLSessionConfiguration用于配置会话的属性，可以通过该类配置会话的工作模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSURLSessionConfiguration *)defaultSessionConfiguration;  </div><div class="line">+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;  </div><div class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfiguration:(NSString *)identifier;</div></pre></td></tr></table></figure>
<p>在backgroundSessionConfiguration:方法中的identifier参数指定了会话的ID，用于标记后台的session。<br>该类的其中两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* allow request to route over cellular. */  </div><div class="line">@property BOOL allowsCellularAccess;  </div><div class="line">  </div><div class="line">/* allows background tasks to be scheduled at the discretion of the system for optimal performance. */  </div><div class="line">@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(NA, 7_0);</div></pre></td></tr></table></figure>
<p>allowsCellularAccess 属性指定是否允许使用蜂窝连接， discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。补充：这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过Wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>
<p>2.NSURLSession类</p>
<p>获取NSURLSession类对象有几种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (NSURLSession *)sharedSession;  </div><div class="line">  </div><div class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; </div><div class="line"> </div><div class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue;</div></pre></td></tr></table></figure>
<p>第一种方式是使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书。</p>
<p>第二种方式是通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用。</p>
<p>第三种方式是通过sessionWithConfiguration:delegate:delegateQueue方法创建对象，二三两种方式可以创建一个新会话并定制其会话类型。该方式中指定了session的委托和委托所处的队列。当不再需要连接时，可以调用Session的invalidateAndCancel直接关闭，或者调用finishTasksAndInvalidate等待当前Task结束后关闭。这时Delegate会收到URLSession:didBecomeInvalidWithError:这个事件。Delegate收到这个事件之后会被解引用。</p>
<p>3.NSURLSessionTask类</p>
<p>NSURLSessionTask是一个抽象子类，它有三个子类：NSURLSessionDataTask，NSURLSessionUploadTask和NSURLSessionDownloadTask。这三个类封装了现代应用程序的三个基本网络任务：获取数据，比如JSON或XML，以及上传和下载文件。</p>
<blockquote>
<p>与 NSURLConnection 相比，NSURLsession 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 NSURLSession 对象都由一个 NSURLSessionConfiguration 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</p>
</blockquote>
<p>NSURLSession 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。NSURLSessionTask 与 NSURLConnection 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 NSURLSession 这一公共委托者（common delegate）。</p>
<p>下面是其继承关系：<br><img src="http://img.blog.csdn.net/20140205121918203" alt="pic2"></p>
<p>有多种方法创建对应的任务对象：</p>
<p>（1）NSURLSessionDataTask</p>
<p>通过request对象或url创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Creates a data task with the given request.  The request may have a body stream. */  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;  </div><div class="line">  </div><div class="line">/* Creates a data task to retrieve the contents of the given URL. */  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;</div></pre></td></tr></table></figure>
<p>通过request对象或url创建，同时指定任务完成后通过completionHandler指定回调的代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>（2）NSURLSessionUploadTask<br>通过request创建，在上传时指定文件源或数据源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  </div><div class="line">  </div><div class="line">/* Creates an upload task with the given request.  The body of the request is provided from the bodyData. */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  </div><div class="line">  </div><div class="line">/* Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;</div></pre></td></tr></table></figure>
<p>在创建upload task对象时，通过completionHandler指定任务完成后的回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * upload convenience method. </div><div class="line"> */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>（3）NSURLSessionDownloadTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Creates a download task with the given request. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;  </div><div class="line">  </div><div class="line">/* Creates a download task to download the contents of the given URL. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;  </div><div class="line">  </div><div class="line">/* Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;</div></pre></td></tr></table></figure>
<p>下载任务支持断点续传，第三种方式是通过之前已经下载的数据来创建下载任务。<br>同样地可以通过completionHandler指定任务完成后的回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>4.NSURLSessionDelegate和NSURLSessionTaskDelegate协议</p>
<p>在协议的方法中可以完成各种各样的回调动作，如身份验证、完成任务后的动作、错误处理和后台任务完成的动作等。委托方法指定在NSURLSession中一定数量的字节传输使用int64_t类型的参数。</p>
<p>这里只说下后台任务的一个委托方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>合作使用的ApplicationDelegate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>将任务切换到后台之后，Session的Delegate不会再收到和Task相关的消息。当所有Task全都完成后，程序将被唤醒，并调用ApplicationDelegate的application:handleEventsForBackgroundURLSession:completionHandler:回调，在这里要为后台session（由background session的identifier标识）指定对应的回调代码块。<br>随后，对于每一个完成的后台Task调用该Session的Delegate中的URLSession:downloadTask:didFinishDownloadingToURL:（成功的话）和URLSession:task:didCompleteWithError:（成功或者失败都会调用）方法做处理，以上的回调代码块可以在这里调用。</p>
<h4 id="NSURLSession与NSURLConnection区别"><a href="#NSURLSession与NSURLConnection区别" class="headerlink" title="NSURLSession与NSURLConnection区别"></a>NSURLSession与NSURLConnection区别</h4><p>总结一下两者主要的区别：</p>
<p>1, 使用现状</p>
<p>从iOS9.0开始， NSURLConnection中发送请求的两个方法已过期（同步请求，异步请求），初始化网络连接（initWithRequest: delegate:）的方法也被设置为过期，系统不再推荐使用，建议使用NSURLSession发送网络请求。</p>
<p>2, 普通任务和上传</p>
<p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask, NSURLSessionUploadTask和NSURLSessionDownloadTask.。创建的task都是挂起状态，需要resume才能执行。</p>
<p>当服务器返回的数据较小时，NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别。</p>
<p>执行上传任务时，NSURLSession与NSURLConnection一样同样需要设置POST请求的请求体进行上传。</p>
<p>3, 下载任务方式<br>NSURLConnection下载文件时，先将整个文件下载到内存，然后再写入沙盒，如果文件比较大，就会出现内存暴涨的情况。而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在下载完成后会将tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。</p>
<p>以下代码是实例化网络下载任务时将下载的文件保存到沙盒的caches文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[NSURLSessionDownloadTask [NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://127.0.0.1/dawenjian.zip&quot;] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">   //获取沙盒的caches路径</div><div class="line"></div><div class="line">   NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]stringByAppendingPathComponent:@&quot;kkk.dmg&quot;];</div><div class="line"></div><div class="line">   //生成URL路径</div><div class="line"></div><div class="line">   NSURL *DCurl = [NSURL fileURLWithPath:path];</div><div class="line"></div><div class="line">   //将文件保存到指定文件目录下</div><div class="line"></div><div class="line">   [[NSFileManager defaultManager]moveItemAtURL:location toURL:DCurl error:nil];   &#125;]resume];</div></pre></td></tr></table></figure>
<p>4, 请求方法的控制</p>
<p>NSURLConnection实例化对象，实例化开始，默认请求就发送（同步发送），不需要调用start方法。而cancel 可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</p>
<p>NSURLSession有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务。</p>
<p>5, 断点续传的方式<br>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果 downloadTask （下载任务）为非空，调用 cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中。在点击再次下载时，通过调用 [ [self.session downloadTaskWithResumeData:self.resumeData]resume]方法进行继续下载操作。   </p>
<p>经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷。</p>
<p>6,  配置信息</p>
<p>NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个 NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比于 NSURLConnection 依赖于一个全局的配置对象，缺乏灵活性而言，NSURLSession 有很大的改进了。</p>
<p>[由于篇幅已经很长了，NSProtocol另外创建一篇文章介绍吧… ]</p>
<hr>
<p>参考：</p>
<p><a href="http://blog.csdn.net/jymn_chen/article/details/18937819" target="_blank" rel="external"> NSURLSession学习笔记（一）简介</a></p>
<p><a href="http://www.cnblogs.com/wendingding/p/3813572.html" target="_blank" rel="external">iOS开发网络篇—NSURLConnection基本使用</a></p>
<p><a href="http://www.cnblogs.com/kakaluote123/articles/5426923.html" target="_blank" rel="external">NSURLSession与NSURLConnection区别
</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URL Loading System的类主要有以下几种： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSyste
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>[转]域名解析使用HTTPDNS优化</title>
    <link href="http://leii.me/2016/09/11/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BC%98%E5%8C%96/"/>
    <id>http://leii.me/2016/09/11/域名解析优化/</id>
    <published>2016-09-11T14:43:38.000Z</published>
    <updated>2016-09-22T09:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了部分关于传统DNS解析会存在的一些问题和HTTPDNS的解决方案，更详细的介绍可以看原文 <a href="http://www.cnblogs.com/aliyunblogs/p/5749177.html" target="_blank" rel="external">阿里云官方博客</a></p>
<h4 id="DNS概念"><a href="#DNS概念" class="headerlink" title="DNS概念"></a>DNS概念</h4><p>根域、顶级域、二级域:</p>
<p>DNS系统一般采用树状结构进行组织，以ru.wikipedia.org为例，org为顶级域名，wikipedia为二级域名，ru为三级域名</p>
<p>权威DNS：</p>
<p>权威DNS即最终决定域名解析结果的服务器，开发者可以在权威DNS上配置、变更、删除具体域名的对应解析结果信息。</p>
<p>递归DNS：</p>
<p>递归DNS又称为Local DNS，它没有域名解析结果的决定权，但代理了用户向权威DNS获取域名解析结果的过程。递归DNS上有缓存模块，当目标域名存在缓存解析结果并且TTL未过期时（每个域名都有TTL时间，即有效生存时间，若域名解析结果缓存的时间超过TTL，需要重新向权威DNS获取解析结果），递归DNS会返回缓存结果，否则，递归DNS会一级一级地查询各个层级域名的权威DNS直至获取最终完整域名的解析结果。</p>
<p>公共DNS：</p>
<p>公共DNS是递归DNS的一种特例，它是一种全网开放的递归DNS服务，而传统的递归DNS信息一般由运营商分发给用户。一个比较典型的公共DNS即Google的8.8.8.8，我们可以通过在操作系统配置文件中配置公共DNS来代替Local DNS完成域名解析流程。</p>
<p>以访问www.taobao.com为例，一次完整的域名解析流程包括：</p>
<p>终端向Local DNS发起域名解析请求；<br>Local DNS在获取到域名解析请求后首先从Root hints获取根域名服务器的地址（Root hints包含了互联网DNS根服务器的地址信息）；<br>获取了根域名服务器地址后Local DNS向根域名服务器发起DNS解析请求，根域名服务器返回com顶级域名服务器地址；<br>随后Local DNS向com域名服务器发起解析请求，并得到taobao.com二级域名服务器的地址；<br>Local DNS向taobao.com二级域名服务器发起解析请求，并最终获得了www.taobao.com的IP地址信息；<br>Local DNS将递归查询获得的IP地址信息缓存并返回给客户端；</p>
<blockquote>
<p>Local DNS服务器包含缓存模块，在实际域名解析过程中Local DNS服务器会首先查询缓存，缓存命中且解析结果TTL未过期的情况下直接返回，否则才启动递归查询的流程。</p>
</blockquote>
<h4 id="传统的域名解析面临的问题"><a href="#传统的域名解析面临的问题" class="headerlink" title="传统的域名解析面临的问题"></a>传统的域名解析面临的问题</h4><p>了解了域名解析的基本概念和整体流程，我们再一起来探究一下传统域名解析存在的一系列问题。</p>
<h5 id="域名劫持"><a href="#域名劫持" class="headerlink" title="域名劫持"></a>域名劫持</h5><p>域名劫持一直是困扰许多开发者的问题之一，其表现即域名A应该返回的DNS解析结果IP1被恶意替换为了IP2，导致A的访问失败或访问了一个不安全的站点。下面我们一起看看几种常见的域名劫持的场景。</p>
<p>一种可能的域名劫持方式即黑客侵入了宽带路由器并对终端用户的Local DNS进行篡改，指向黑客自己伪造的Local DNS，进而通过控制Local DNS的逻辑返回错误的IP信息进行域名劫持。另一方面，由于DNS解析主要是基于UDP协议，除了上述攻击行为外，攻击者还可以监听终端用户的域名解析请求，并在Local DNS返回正确结果之前将伪造的DNS解析响应传递给终端用户，进而控制终端用户的域名访问行为。</p>
<p>上述攻击行为的影响面相对比较有限，另一种我们最常碰到的域名劫持现象是缓存污染。我们知道在接收到域名解析请求时，Local DNS首先会查找缓存，如果缓存命中就会直接返回缓存结果，不再进行递归DNS查询。这时候如果Local DNS针对部分域名的缓存进行更改，比如将缓存结果指向第三方的广告页，就会导致用户的访问请求被引导到这些广告页地址上。</p>
<p>对比第一种攻击，这类缓存污染往往能带来更明显的群体伤害，比如某个省份某个运营商的用户群可能因为该地区Local DNS的缓存污染而导致访问服务异常。这类缓存污染行为往往是间歇性、局部性发生的，没有明显的规律，导致开发者很难对其进行量化、评估、预防。</p>
<p>有的同学可能会问，“我使用了HTTPS，是否就可以避免域名劫持的问题”，答案是否定的。域名解析环节发生在网络加密请求交互之前，试想一下，如果客户端还没有服务端的确切地址信息，我们又如何知道应该和谁进行加密的握手协商与通信呢？</p>
<h5 id="调度不精准"><a href="#调度不精准" class="headerlink" title="调度不精准"></a>调度不精准</h5><p>除了域名劫持问题，基于传统Local DNS的域名解析还会带来域名调度精准性的问题。对于类似CDN域名访问这类需要按地域、运营商进行智能解析调度的场景，精准调度的诉求是十分强烈的。</p>
<p>关于调度不精准的原因，我们主要可以从两个方面来探究一下。第一个常见的问题即解析转发。</p>
<p>部分Local DNS供应商为了降低运营成本，会将请求到自己节点的域名解析请求转发给其他供应商的Local DNS节点，如上图所示。假如用户请求解析一个CDN域名cdn.aliyun.com，用户分配到的Local DNS A为了节省成本，把该次请求转发给了另一运营商的Local DNS B，权威DNS在进行域名解析时会根据Local DNS的IP信息进行智能调度，即权威DNS会根据Local DNS B的IP78.29.29.1进行调度，分配与78.29.29.1相同运营商并且地理位置最近的CDN节点78.29.29.2，然而这个CDN节点对于终端135.35.35.1而言并不是最优的CDN节点，他们分属不同的运营商，并且地理位置上可能相隔很远。这类解析转发行为会严重影响域名解析的精准性并对用户业务访问延迟带来影响。</p>
<p>除了解析转发对调度精准性带来的影响外，Local DNS的布署情况同样影响着域名智能解析的精准性。</p>
<h5 id="解析生效滞后"><a href="#解析生效滞后" class="headerlink" title="解析生效滞后"></a>解析生效滞后</h5><p>部分业务场景下开发者对域名解析结果变更的生效时间非常敏感（这部分变更操作是开发者在权威DNS上完成的），比如当业务服务器受到攻击时，我们需要最快速地将业务IP切换到另一组集群上，这样的诉求在传统域名解析体系下是无法完成的。</p>
<h5 id="延迟大"><a href="#延迟大" class="headerlink" title="延迟大"></a>延迟大</h5><p>DNS首次查询或缓存过期后的查询，需要递归遍历多个DNS服务器以获取最终的解析结果，这增加了网络请求的前置延时时间。特别是在移动互联网场景下，移动网络质量参差不齐，弱网环境的RTT时间可能高达数百毫秒，对于一次普通的业务请求而言，上述延时是非常沉重的负担。另一方面，弱网环境下的解析超时、解析失败等现象屡见不鲜，如何合理优化DNS解析对于整体网络访问质量的提升至关重要。</p>
<h4 id="HTTPDNS解决方案"><a href="#HTTPDNS解决方案" class="headerlink" title="HTTPDNS解决方案"></a>HTTPDNS解决方案</h4><h5 id="防域名劫持"><a href="#防域名劫持" class="headerlink" title="防域名劫持"></a>防域名劫持</h5><p>HTTPDNS使用HTTP协议进行域名解析，代替现有基于UDP的DNS协议，域名解析请求直接发送到HTTPDNS服务端，从而绕过运营商的Local DNS，如下图所示。</p>
<p><img src="https://yqfile.alicdn.com/6c4402618b6f9580255ba88ea28fa518947629ae.png?_=0.3877227769572087" alt="tu1"></p>
<p>HTTPDNS代替了传统的LocalDNS完成递归解析的功能，基于HTTP协议的设计可以适用于几乎所有的网络环境，同时保留了鉴权、HTTPS等更高安全性的扩展能力，避免恶意攻击劫持行为。另一方面，商业化的HTTPDNS服务（<a href="https://www.aliyun.com/product/httpdns" target="_blank" rel="external">https://www.aliyun.com/product/httpdns</a> ）缓存管理有严格的SLA保障，避免了类似Local DNS的缓存污染的问题。</p>
<h5 id="精准调度"><a href="#精准调度" class="headerlink" title="精准调度"></a>精准调度</h5><p>传统域名解析的调度精准性问题，本质根源在于Local DNS的部署和分配机制上。由于碎片化的管理方式，这些环节的服务质量同样很难得到保障。HTTPDNS在递归解析实现上优化了与权威DNS的交互，通过edns-client-subnet协议（<a href="https://datatracker.ietf.org/doc/rfc7871" target="_blank" rel="external">https://datatracker.ietf.org/doc/rfc7871</a> ）将终端用户的IP信息直接交付给权威DNS，这样权威DNS就可以忽略Local DNS IP信息，根据终端用户的IP信息进行精准调度，避免Local DNS的坐标干扰（当然上述精准调度方案的前提是权威DNS需要支持edns-client-subnet，可喜的是当前主流的权威DNS服务都已支持该协议）。</p>
<h5 id="实时生效"><a href="#实时生效" class="headerlink" title="实时生效"></a>实时生效</h5><p>在域名解析生效周期方面，HTTPDNS也有着传统域名解析体系所无法具备的能力。前文中我们提到由于各个地区的Local DNS是独立维护的，服务质量参差不齐，缓存实现不一，因此导致的解析变更全网生效滞后的问题，在商业化的HTTPDNS服务上就不会存在（HTTPDNS严格遵循DNS TTL限制进行缓存更新）。另一方面，即便我们假设Local DNS严格遵循域名TTL时间进行缓存管理（这里我们假设开发者配置的域名TTL时间为5min），当开发者业务受到攻击并需要快速进行切换时，Local DNS也会遵循域名TTL，在持续5min的时间段内返回旧IP信息，这5min的业务影响对于中大型企业而言是一个不小的损失（对于电商类的大型企业，5min的访问异常可能意味着几百万的交易额下跌）。以阿里云HTTPDNS服务（<a href="https://www.aliyun.com/product/httpdns" target="_blank" rel="external">https://www.aliyun.com/product/httpdns</a> ）为例，HTTPDNS在快速生效方面有专有的方案，配合阿里云的权威DNS服务云解析（ <a href="https://wanwang.aliyun.com/domain/dns" target="_blank" rel="external">https://wanwang.aliyun.com/domain/dns</a> ），用户在权威DNS变更的解析结果将快速同步给HTTPDNS，覆盖原有的缓存记录，帮助用户实现秒级的域名解析切换。</p>
<p>在DNS解析延迟方面，由于HTTPDNS基于HTTP协议，而HTTP基于TCP协议，对比传统的UDP传输多了一些冗余的握手环节，因此从原理上而言网络请求方面的开销并没有降低。但在实际使用过程中，我们可以通过端上的策略来实现一个零延迟DNS解析的方案。接下来我们一起来看看HTTPDNS服务在移动端的最佳实践方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了部分关于传统DNS解析会存在的一些问题和HTTPDNS的解决方案，更详细的介绍可以看原文 &lt;a href=&quot;http://www.cnblogs.com/aliyunblogs/p/5749177.html&quot; target=&quot;_blank&quot; rel=&quot;external
    
    </summary>
    
      <category term="Base" scheme="http://leii.me/categories/Base/"/>
    
    
      <category term="转" scheme="http://leii.me/tags/%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>证书与打包与APNs</title>
    <link href="http://leii.me/2016/09/10/%E8%AF%81%E4%B9%A6%E4%B8%8E%E6%89%93%E5%8C%85%E4%B8%8EAPNs/"/>
    <id>http://leii.me/2016/09/10/证书与打包与APNs/</id>
    <published>2016-09-10T10:10:49.000Z</published>
    <updated>2016-09-26T22:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="苹果在9月22号又更新了有关token和通知的功能-news-大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）"><a href="#苹果在9月22号又更新了有关token和通知的功能-news-大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）" class="headerlink" title="苹果在9月22号又更新了有关token和通知的功能[news] 大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）"></a>苹果在9月22号又更新了有关token和通知的功能<a href="https://developer.apple.com/news/?id=09222016a" target="_blank" rel="external">[news]</a> 大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRemoteNotificationsWithDeviceToken获取的token不一样）</h2><p>APNs 是 Apple Push Notification service 的简称，是苹果提供的Push服务器，Push流程如下：</p>
<p><img src="http://img.blog.csdn.net/20131210220624265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWJlbF90dQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="pic 1"></p>
<p>1、应用程序注册消息推送。</p>
<p>2、iOS从APNs Server获取device token，应用程序接收device token。</p>
<p>3、应用程序将device token发送给PUSH服务端程序。</p>
<p>4、服务端程序向APNs服务发送消息。</p>
<p>5、APNs服务将消息发送给iPhone应用程序。</p>
<p>其中iOS客户端到APNs Server到APNs都需要证书连接。</p>
<p>下面是需要用到几个证书文件：</p>
<p>1，CSR文件：CertificateSigningRequest.certSigningRequest</p>
<p>2，p12文件：Push.p12（文件名可自定义）</p>
<p>3，SSL certificate文件：aps_development.cer（文件名可自定义）</p>
<p>通过这3个文件可以生产APNs的服务器证书，具体的生成步骤可以看<a href="http://www.fx114.net/qa-202-108331.aspx" target="_blank" rel="external">这篇文章</a>，其中php服务器与Java服务器需要的证书的格式有区别。</p>
<p>APNs 协议在近两年的 WWDC 上改过两次，2015年12月17日更是推出了革命性的新特性，改掉了很多长期被用户诟病的问题:</p>
<p>2014年6月份WWDC搭载iOS8及以上系统的iOS设备，能够接收的最大playload大小提升到2KB。低于iOS8的设备以及OS X设备维持256字节。参考文档：<a href="https://developer.apple.com/videos/play/wwdc2014/713/" target="_blank" rel="external">What’s New in Notifications - WWDC 2014 - Session 713 - iOS</a></p>
<p>2015年6月份WWDC宣布将在不久的将来发布 “基于 HTTP/2 的全新 APNs 协议”，并在大会上发布了仅仅支持测试证书的版本。参考文档：<a href="https://developer.apple.com/videos/play/wwdc2015/720/" target="_blank" rel="external">What’s New in Notifications - WWDC 2015 - Session 720 - iOS, OS X </a></p>
<p>2015年12月17日起，发布 “基于 HTTP/2 的全新 APNs 协议”,iOS 系统以及 OS X 系统，统一将最大 playload 大小提升到4KB。参考文档：<a href="https://developer.apple.com/news/?id=12172015b" target="_blank" rel="external">Apple Push Notification Service Update 12-17 2015</a></p>
<p>下面是APNs新旧版本的对比：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160425/1461567499300714.jpg" alt="pic 2"></p>
<p>送分发的服务器要打开一个同 APNs 网关服务器的</p>
<p>连接，并保持这个连接。但在旧的协议下，APNs 服务却不保证 socket 能维持这个连接。如果通道上没有消息往来，空闲下来到话，socket将被路由掐断。在旧的协议下，如果服务器响应成功的话，你将不会收到任何回应，但是如果服务器响应失败（例如，使用了一个非法的 Push token），服务器将返回了一个错误编码，并关闭这个socket。最重要的是，你必须重新发送使用这个无效 token 以后发送的所有推送。因此，你可能一直不能确定你的推送是否成功的被 APNs 服务器接收。</p>
<p>基于上述问题新版本的APNs有如下特征：</p>
<p>1，Request 和 Response 支持JSON网络协议</p>
<p>2，APNs支持状态码和返回 error 信息</p>
<p>APNs推送成功时 Response 将返回状态码200，远程通知是否发送成功再也不用靠猜了！<br>APNs推送失败时，Response 将返回 JSON 格式的 Error 信息。<br>3，最大推送长度提升到4096字节（4Kb）</p>
<p>4，可以通过 “HTTP/2 PING ” 心跳包功能检测当前 APNs 连接是否可用，并能维持当前长连接。</p>
<p>5，支持为不同的推送类型定义 “topic” 主题</p>
<p>6，不同推送类型，只需要一种推送证书 Universal Push Notification Client SSL 证书。</p>
<p>其中最大的变化就是基于了 HTTP/2 协议，采用了长连接设计，并提供 “HTTP/2 PING ” 心跳包功能检测、维持当前 APNs 连接，解决了老 APNs 无法维持连接的问题。而且新增的状态码特性，也解决了这个问题：无法获知消息是否成功地从你们的推送系统投递到了 APNs 上。理论上，你们可以保证消息是100%投递到了APNs的，因为你可以准确的知道哪条消息到达了APNs，哪些没到。重发特定失败消息成为可能。</p>
<hr>
<p>参考：<a href="http://www.cocoachina.com/ios/20160426/16013.html" target="_blank" rel="external">国内90%以上的 iOS 开发者，对 APNs 的认识都是错的</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;苹果在9月22号又更新了有关token和通知的功能-news-大概意思是现在发送通知可以通过token验证而不需要创建cer证书了，token不会过期而且方便创建，可以用来给你所有的app发送通知（这里的token应该和app打开时didRegisterForRe
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hybrid 笔记</title>
    <link href="http://leii.me/2016/09/09/Hybrid-%E7%AC%94%E8%AE%B0/"/>
    <id>http://leii.me/2016/09/09/Hybrid-笔记/</id>
    <published>2016-09-09T08:35:25.000Z</published>
    <updated>2016-09-22T05:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hybrid App优势明显，发版不用审核，页面可以随时调整和修复，通用于3个平台节省开发成本等，很多公司都在用，类型主要分Web主体型、多View混合型、单View混合型。</p>
<p>我们公司则经历了从最早的Web主体型APP向多view混合型的过渡，公司早期人员少，业务变化快的情况下，业务代码都放在前端非常方便，不过后期随着用户量的增多，对性能和用户体验开始精益求精，将部分高频的页面native化。</p>
<p>Hybrid APP的核心就是Native和H5之间的交互，native端需要提供一些通用的设备功能让H5可以调用，比如：</p>
<p>1，Alert组件、loading组件、NavigationBar、tabbar等</p>
<p>2，获取定位、获取通讯录、获取陀螺仪、获取相册相机权限、获取设备信息（iOS版本、iPhone型号）、获取网络\定位\push状态</p>
<p>3，对本地缓存数据的增删查改(有的直接通过cookie、session来传递数据)</p>
<p>4，页面的跳转（关闭或新拉起页面）</p>
<p>5，[非通用]加密、支付、动画、地图、分享等功能</p>
<p>以上这些native的功能H5可以通过桥接来执行</p>
<p>H5主要完成如下工作：</p>
<p>(1) 创建了一个用于发送消息的iFrame(通过创建一个隐藏的ifrmae，并设置它的URL 来发出一个请求，从而触发UIWebView的shouldStartLoadWithRequest回调协议)</p>
<p>(2) 创建了一个核心对象，如 WebViewJavascriptBridge，并给它定义了几个方法，这些方法大部分是公开的API方法</p>
<p>(3) 创建了一个事件：WebViewJavascriptBridgeReady，并dispatch(触发)了它。</p>
<p>native的主要工作是通过UIWebViewDelegate协议的方法shouldStartLoadWithRequest：来获取这个请求并执行相应的native方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)webView:(UIWebView*)webView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType &#123;</div><div class="line">//异步桥接</div><div class="line">    if ([url.absoluteString rangeOfString:@&quot;customScheme://operation&quot;].location != NSNotFound) &#123;</div><div class="line">        [self doWebBridgeOperation:[url.query stringByURLDecodingStringParameter]];</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法通过判断url是否有自定义的scheme来决定是否执行桥接方法，如果是的话则执行相应的方法，参数可以通过url query带过去，然后返回NO，表示不会拉起这个url的webview页面。</p>
<p>以上是目前比较主流的桥接方案，除此之外我们还提供了同步桥接，前端可以通过ajax同步请求来触发native的相应方法，这种方法更方便H5的调用，但是执行时会阻塞页面，主要是通过自定义NSURLProtocol的拦截来实现，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// override</div><div class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    // step 1, check the request did marked</div><div class="line">    id prop = [NSURLProtocol propertyForKey:REQUEST_TRACKING_KEY inRequest:request];</div><div class="line">    if (prop != nil) &#123;</div><div class="line">        return NO; // aviod loading cycle</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // step 2, check the scheme of request</div><div class="line">    NSString *scheme = [request.URL scheme];</div><div class="line">    if (scheme == nil) return NO; // the request schema can not be nil</div><div class="line">    </div><div class="line">    scheme = [scheme lowercaseString];</div><div class="line">    if (!([scheme isEqualToString:@&quot;http&quot;]</div><div class="line">          || [scheme isEqualToString:@&quot;https&quot;])) &#123;</div><div class="line">        return NO; // for now, the scheme should be &apos;http&apos; or &apos;https&apos;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先在canInitWithRequest方法里判断是否要拦截，通过propertyForKey来标记这个方法是否处理过，如果这个方法已经处理过，则不会继续处理，避免循环加载，如果scheme不是http 或者https 也不做处理。如果条件都符合则返回YES，执行startLoading：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// override</div><div class="line">- (void)startLoading &#123;</div><div class="line">    NSURL *requestURL = self.request.URL;</div><div class="line">	//拦截同步请求</div><div class="line">    if (url &amp;&amp; [url.absoluteString rangeOfString:customSyncBridgeParam].location != NSNotFound) &#123;</div><div class="line">    NSData* resultBridgeData = [self doSyncBridgeOperation:[url.query stringByURLDecodingStringParameter]];</div><div class="line">   	    // notify did finish load data</div><div class="line">        [self.client URLProtocol:self didLoadData:resultBridgeData];</div><div class="line">        </div><div class="line">        // notify did finish loading</div><div class="line">        [self.client URLProtocolDidFinishLoading:self];</div><div class="line">        </div><div class="line">        [NSURLProtocol setProperty:@(YES) forKey:REQUEST_TRACKING_KEY inRequest:request];</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过url里面是否包含约定的同步桥接字符串，如果有就执行同步桥接。</p>
<p>通过NSURLProtocol我们也可以在startLoading里面自定义request的header、超时时间等，还能替换掉原来的url，比如要加载本地资源：拦截请求后只对特定的类型替换为本地缓存。比如更新静态资源请求是下载zip包，如果本地也存在此zip包，那么更新请求会被拦截导致更新失败。还有一点先在DocumentDirectory中查找缓存文件，如果不存在再在NSBundle.mainBundle()中查找。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hybrid App优势明显，发版不用审核，页面可以随时调整和修复，通用于3个平台节省开发成本等，很多公司都在用，类型主要分Web主体型、多View混合型、单View混合型。&lt;/p&gt;
&lt;p&gt;我们公司则经历了从最早的Web主体型APP向多view混合型的过渡，公司早期人员少，
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>OC发送消息的几种方式</title>
    <link href="http://leii.me/2016/06/27/OC%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://leii.me/2016/06/27/OC发送消息的几种方式/</id>
    <published>2016-06-27T09:59:37.000Z</published>
    <updated>2016-10-04T10:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>object-c 的消息发送主要有3种方式：</p>
<p>1，直接发送</p>
<p>2，使用performSelector</p>
<p>3，使用NSInvocation</p>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>第一种是用的最多的，</p>
<p>id returnValue = [someObject messageName:parameter];</p>
<p>其中，someObject是消息的“接收者”，messageName为“选择子”，“选择子”与参数合起来叫做消息。转换成C语言就是</p>
<p>void objc_msgSend (id self, SEL cmd, …)</p>
<p>如果是明确类型的对象发送消息，那这个方法必须是在someObject的类里能够找到的，否则Xcode会报错，有的时候我们需要对一个对象做类型转换再发送消息，这种情况下如果原来的对象里没有这种方法编译器也不知道，从而在执行的时候会crash，在运行时找不到方法系统不会直接报错，而是先进行消息转发，过程如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/277577/201509/277577-20150920213203086-713808959.png" alt="msg_resend"></p>
<p>首先，会调用+ (BOOL)resolveInstanceMethod:(SEL)sel。若方法返回YES，则表示可以处理该消息。在这个过程，可以动态地给消息增加方法。</p>
<p>若方法返回NO，则进行消息转发的第二步，查找是否有其它的接收者。对应的处理函数是：- (id)forwardingTargetForSelector:(SEL)aSelector。可以通过该函数返回一个可以处理该消息的对象。</p>
<p>若第二步返回nil，则进入消息转发的第三步。调用- (void)forwardInvocation:(NSInvocation *)anInvocation。这个方法实现得很简单。只需要改变调用目标，使消息在新目标上得以调用即可。不过，如果采用这种方式，实现的效果与第二步的消息转发是一致的。所以比较有用的实现方式是：先以某种方式改变消息内容，比如追加另外一个参数，或者改换选择子，等等。</p>
<p>如果直到NSObject，继承体系中的其它类都无法处理这个消息转发，就会由NSObject调用该方法，并在该方法中调用doesNotRecognizeSelector，以抛出异常。</p>
<p>网上看到一个比较形象的<a href="http://www.cnblogs.com/forwk/p/4822052.html?tvd" target="_blank" rel="external">总结</a> :</p>
<p>1、李四收到做板凳的消息，发现自己不会做，系统问李四是否需要添加这份技能(resolveInstanceMethod中addMethod)</p>
<p>2、李四自己学不会,但是李四决定找一个认识的人来处理这件事(forwardTargetForSelector:)</p>
<p>3、李四实在是找不到任何人来处理这件事，店长或经理搜集客户需求(selector,methodArgument，处理人target)，启用板凳店的终极处理NSInvocation</p>
<p>4、启用之后还是没有什么卵用，店长无赖的告诉张三，doesnotRecognizeSelector</p>
<h3 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h3><p>id returnValue = [someObject messageName: parameter];转换为performSelector的形式：</p>
<p>id returnValue = [someObject performSelector:@selector(messageName:)withObject: parameter];</p>
<p>performSelector是运行时系统负责去找方法的，在编译时候不做任何校验，如果在someObject的类里没有找到，也不会报错，但是为了程序的健壮性，最好先使用检查方法</p>
<ul>
<li>(BOOL)respondsToSelector:(SEL)aSelector;</li>
</ul>
<p>同时performSelector也经常用来做方法的延时调用，performSelector:withObject:afterDelay:这个方法在调用的时候会设置当前runloop中timer</p>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><p>在介绍消息转发时已经提到了NSInvocation，就是在消息转发的第三步就是用NSInvocation来创建一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 方法签名中保存了方法的名称/参数/返回值，协同NSInvocation来进行消息的转发</div><div class="line">// 方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系</div><div class="line">//1、根据方法来初始化NSMethodSignature</div><div class="line">NSMethodSignature  *signature = [ViewController instanceMethodSignatureForSelector:@selector(run:)];</div><div class="line">// NSInvocation中保存了方法所属的对象/方法名称/参数/返回值</div><div class="line">//其实NSInvocation就是将一个方法变成一个对象</div><div class="line">//2、创建NSInvocation对象</div><div class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</div><div class="line">//设置方法调用者</div><div class="line">invocation.target = self;</div><div class="line">//注意：这里的方法名一定要与方法签名类中的方法一致</div><div class="line">invocation.selector = @selector(run:);</div><div class="line">NSString *way = @&quot;byCar&quot;;</div><div class="line">//这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd)</div><div class="line">[invocation setArgument:&amp;way atIndex:2];</div><div class="line">//3、调用invoke方法</div><div class="line">[invocation invoke];</div><div class="line"></div><div class="line">//4、判断当前调用的方法是否有返回值</div><div class="line">if (signature.methodReturnLength) &#123;</div><div class="line">            void *pointer = NULL;</div><div class="line">            [invocation getReturnValue:&amp;pointer];</div><div class="line">            obj = (__bridge id)pointer;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;object-c 的消息发送主要有3种方式：&lt;/p&gt;
&lt;p&gt;1，直接发送&lt;/p&gt;
&lt;p&gt;2，使用performSelector&lt;/p&gt;
&lt;p&gt;3，使用NSInvocation&lt;/p&gt;
&lt;h3 id=&quot;objc-msgSend&quot;&gt;&lt;a href=&quot;#objc-msgSend&quot;
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="格物" scheme="http://leii.me/tags/%E6%A0%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>iOS常用判断</title>
    <link href="http://leii.me/2016/06/12/iOS%E5%B8%B8%E7%94%A8%E5%88%A4%E6%96%AD/"/>
    <id>http://leii.me/2016/06/12/iOS常用判断/</id>
    <published>2016-06-12T09:26:25.000Z</published>
    <updated>2016-09-24T08:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>[用到就记录下来…]</p>
<h4 id="判断一个对象中是否包含某个属性"><a href="#判断一个对象中是否包含某个属性" class="headerlink" title="判断一个对象中是否包含某个属性"></a>判断一个对象中是否包含某个属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (BOOL) getVariableWithClass:(Class) myClass varName:(NSString *)name&#123;       </div><div class="line">	unsigned int outCount, i;</div><div class="line">  	Ivar *ivars = class_copyIvarList(myClass, &amp;outCount);</div><div class="line">  	for (i = 0; i &lt; outCount; i++) &#123;</div><div class="line">    	Ivar property = ivars[i];</div><div class="line">    	NSString *keyName = [NSString 		stringWithCString:ivar_getName(property) encoding:NSUTF8StringEncoding];</div><div class="line">	    keyName = [keyName stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;&quot;];</div><div class="line">    	if ([keyName isEqualToString:name]) &#123;</div><div class="line">      	return YES;</div><div class="line">    	&#125;</div><div class="line">  	&#125;</div><div class="line">  	return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断字符串是否为纯数字组成"><a href="#判断字符串是否为纯数字组成" class="headerlink" title="判断字符串是否为纯数字组成"></a>判断字符串是否为纯数字组成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isPureInt:(NSString*)string&#123;</div><div class="line">    NSScanner* scan = [NSScanner scannerWithString:string];</div><div class="line">    int val;</div><div class="line">    return[scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断当天是星期几"><a href="#判断当天是星期几" class="headerlink" title="判断当天是星期几"></a>判断当天是星期几</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)weekDayJudge</div><div class="line">&#123;</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</div><div class="line">    NSDate *now;</div><div class="line">    NSDateComponents *comps = [[NSDateComponents alloc] init];</div><div class="line">    NSInteger unitFlags =NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitWeekday |</div><div class="line">    NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond;</div><div class="line">    now=[NSDate date];</div><div class="line">    comps = [calendar components:unitFlags fromDate:now];</div><div class="line"></div><div class="line">    NSLog(@&quot;weekday is %ld&quot;,(long)[comps weekday]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="iOS-判断是否开启定位"><a href="#iOS-判断是否开启定位" class="headerlink" title="iOS 判断是否开启定位"></a>iOS 判断是否开启定位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isLocationServiceOpen &#123;</div><div class="line">    if ([ CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125; else</div><div class="line">        return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="iOS-判断是否允许消息通知"><a href="#iOS-判断是否允许消息通知" class="headerlink" title="iOS 判断是否允许消息通知"></a>iOS 判断是否允许消息通知</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isMessageNotificationServiceOpen &#123;</div><div class="line">    if (SYSTEM_VERSION_GREATER_THAN(@&quot;8.0&quot;)) &#123;</div><div class="line">        return [[UIApplication sharedApplication] isRegisteredForRemoteNotifications];</div><div class="line">    &#125; else &#123;</div><div class="line">        return UIRemoteNotificationTypeNone != [[UIApplication sharedApplication] enabledRemoteNotificationTypes];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="判断是否属于或包含某个类、对象、方法、协议"><a href="#判断是否属于或包含某个类、对象、方法、协议" class="headerlink" title="判断是否属于或包含某个类、对象、方法、协议"></a>判断是否属于或包含某个类、对象、方法、协议</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.  isKindOfClass:Class</div><div class="line">2.  isMemberOfClass:Class</div><div class="line">3.  respondToSelector:selector</div><div class="line">4.  conformsToProtocol:protocol</div></pre></td></tr></table></figure>
<h4 id="获取当前屏幕最顶层显示的viewcontroller"><a href="#获取当前屏幕最顶层显示的viewcontroller" class="headerlink" title="获取当前屏幕最顶层显示的viewcontroller"></a>获取当前屏幕最顶层显示的viewcontroller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)getPresentedViewController</div><div class="line">&#123;</div><div class="line">    UIViewController *appRootVC = [UIApplication sharedApplication].keyWindow.rootViewController;</div><div class="line">    UIViewController *topVC = appRootVC;</div><div class="line">    if (topVC.presentedViewController) &#123;</div><div class="line">        topVC = topVC.presentedViewController;</div><div class="line">    &#125;</div><div class="line">    return topVC;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[用到就记录下来…]&lt;/p&gt;
&lt;h4 id=&quot;判断一个对象中是否包含某个属性&quot;&gt;&lt;a href=&quot;#判断一个对象中是否包含某个属性&quot; class=&quot;headerlink&quot; title=&quot;判断一个对象中是否包含某个属性&quot;&gt;&lt;/a&gt;判断一个对象中是否包含某个属性&lt;/h4&gt;&lt;fi
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Info.plist中常用的key</title>
    <link href="http://leii.me/2016/06/11/Info-plist%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84key/"/>
    <id>http://leii.me/2016/06/11/Info-plist中常用的key/</id>
    <published>2016-06-11T10:23:29.000Z</published>
    <updated>2016-09-12T09:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>Key</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>App Transport Security</td>
<td style="text-align:left">iOS9新增，如果不设置NSAllowsArbitraryLoads将默认强制使用了HTTPS协议进行传输</td>
</tr>
<tr>
<td>UIRequiresPersistentWiFi</td>
<td style="text-align:left">在程序中弹出wifi选择的key（系统设置中需要将wifi提示打开）</td>
</tr>
<tr>
<td>UIAppFonts</td>
<td style="text-align:left">内嵌字体</td>
</tr>
<tr>
<td>UIApplicationExitsOnSuspend</td>
<td style="text-align:left">程序是否在后台运行</td>
</tr>
<tr>
<td>UIBackgroundModes</td>
<td style="text-align:left">后台运行时的服务，具体看iOS4的后台介绍</td>
</tr>
<tr>
<td>UIDeviceFamily</td>
<td style="text-align:left">设备集合,array类型</td>
</tr>
<tr>
<td>UIFileSharingEnabled</td>
<td style="text-align:left">开启itunes共享document文件夹</td>
</tr>
<tr>
<td>UILaunchImageFile</td>
<td style="text-align:left">启动页图片</td>
</tr>
<tr>
<td>UIPrerenderedIcon</td>
<td style="text-align:left">icon上是否有高光</td>
</tr>
<tr>
<td>UIRequiredDeviceCapabilities</td>
<td style="text-align:left">设备需要的功能</td>
</tr>
<tr>
<td>UIStatusBarHidden</td>
<td style="text-align:left">状态栏隐藏（和程序内的区别是在于显示Default.png已经生效）</td>
</tr>
<tr>
<td>UIStatusBarStyle</td>
<td style="text-align:left">状态栏类型</td>
</tr>
<tr>
<td>UIViewEdgeAntialiasing</td>
<td style="text-align:left">是否开启抗锯齿</td>
</tr>
<tr>
<td>CFBundleDisplayName</td>
<td style="text-align:left">app显示名</td>
</tr>
<tr>
<td>CFBundleIconFile</td>
<td style="text-align:left">图标</td>
</tr>
<tr>
<td>CFBundleName</td>
<td style="text-align:left">app显示名短名16个字符以内</td>
</tr>
<tr>
<td>CFBundleVersion</td>
<td style="text-align:left">版本</td>
</tr>
<tr>
<td>CFBundleURLTypes</td>
<td style="text-align:left">自定义url，用于利用url弹回程序</td>
</tr>
<tr>
<td>CFBundleLocalizations</td>
<td style="text-align:left">本地资源的本地化语言，用于itunes页面左下角显示本地话语种</td>
</tr>
<tr>
<td>CFBundleDevelopmentRegion</td>
<td style="text-align:left">也是本地化相关，如果用户所在地没有相应的语言资源，则用这个key的value来作为默认</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;App Transport Security&lt;/td&gt;
&lt;td style=
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>OC之@property</title>
    <link href="http://leii.me/2016/06/04/OC%E4%B9%8B-property/"/>
    <id>http://leii.me/2016/06/04/OC之-property/</id>
    <published>2016-06-04T14:13:51.000Z</published>
    <updated>2016-09-17T03:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>OC的@property本质是一种支持快捷访问成员变量的方法，自动生成setter和getter方法。</p>
<p>声明：在@interface 里声明</p>
<p>声明格式 @property (attributes) type propertyName;</p>
<p>合成：在.m文件里合成</p>
<p>合成格式 @synthesize name = _name;(自动合成，Xcode4.4之后版本不需要写，系统会自动合成)或通过@dynamic，自己</p>
<p>访问权限：在.h中声明成员变量，默认是protected，在.m文件中声明默认是private的。</p>
<p>@synthesize  propertyName = _name；如果变量_name没有声明，系统会自动生成该成员变量且为private权限。如果_name已声明，它们会自动合成。</p>
<p>默认读取方法名为-(type)name 和 -(void)setName也可以改变setter和getter的访问名称。</p>
<p>如：@property  (setter=setMyValue, getter=getBool) NSInteger  value; 此时setValue的方法就会被覆盖。</p>
<h4 id="property的修饰属性-attributes"><a href="#property的修饰属性-attributes" class="headerlink" title="@property的修饰属性(attributes)"></a>@property的修饰属性(attributes)</h4><p>可读性：readwrite/readonly，不写默认为readwrite</p>
<pre><code>readwrite：同时生成setter与getter方法
readonly：只生成getter方法
</code></pre><p>原子性：nonatomic/atomic，不写默认是atomic</p>
<pre><code>atomic：线程安全，表示多线程中只有一个线程能对它访问
nonatomic：非线程安全，但访问速度快
</code></pre><p>内存：assign/retain/copy/weak/strong/unsafe_unretaunied</p>
<p>（Xcode4.2(iOS sdk4.3和以下版本)和以前的版本用retain和assign<br>　　Xcode4.3(iOS 5和以上版本)或之后有了ARC用strong和weak）</p>
<pre><code>assign：简单赋值，不更改引用计数，基础数据类型(如NSInteger,CGFloat)和C数据类型(如int,float)的默认值，非ARC的默认值
retain：使用了引用计数，retain+1，release-1，当引用计数为0时，调用dealloc，内存释放
copy：用于非共享内存，每个指针有自己的内存空间
weak：只作用于ARC,不更改引用计数，作用于对象，当引用计数为0时会将对象置为nil
strong：只作用于ARC，引用计数加1，是对象的默认值
unsafe_unretained：作用于ARC，功能与assign一样，引用计数为0时不会置为nil，可能出现野指针，所以不安全
</code></pre><p>Nullability Annotations：nonnull/nullable/null_resettable，多数为nonnull，包在NS_ASSUME_NONNULL_BEGIN与NS_ASSUME_NONNULL_END中间的默认为nonnull</p>
<p>（llvm 6.1 Xcode6.3中加入，表示是否可以为nil或者NULL，对应swift的？ ！）</p>
<pre><code>nonnull：不能为空
nullable：可以为空
null_resettable：表示 setter nullable，但是 getter nonnull，如@property (null_resettable, nonatomic, strong) UIView *view; 可以被设为nil，但是getter的时候会调用-loadView创建一个非nil的view
</code></pre><p> 为了安全起见，苹果还制定了几条规则：</p>
<blockquote>
<p>1.typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。</p>
<p>2.复杂的指针类型(如id <em>)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id </em> __nonnull”。</p>
<p>3.我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。</p>
</blockquote>
<p>Nullability Annotations的兼容性：</p>
<blockquote>
<p>1.老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。</p>
<p>2.老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。</p>
<p>3.nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。</p>
<p>事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。</p>
</blockquote>
<h4 id="声明临时变量"><a href="#声明临时变量" class="headerlink" title="声明临时变量"></a>声明临时变量</h4><p>用<strong>strong,  </strong>weak, <strong>unsafe_unretained,  </strong>autoreleasing等，用法与上面一样</p>
<p><strong>autoreleasing用法介绍：可以使对象延迟释放。通过传递</strong>autoreleaseing的对象，可以做到在函数内部申请空间，函数外部也可以使用。具体的释放时间取决于runloop创建的autorelease pool，如果autorelease pool释放，则__autorelease 声明的变量都会被释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC的@property本质是一种支持快捷访问成员变量的方法，自动生成setter和getter方法。&lt;/p&gt;
&lt;p&gt;声明：在@interface 里声明&lt;/p&gt;
&lt;p&gt;声明格式 @property (attributes) type propertyName;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="格物" scheme="http://leii.me/tags/%E6%A0%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>[转]http的session与cookie</title>
    <link href="http://leii.me/2016/06/03/%E8%BD%AC-http%E7%9A%84session%E4%B8%8Ecookie/"/>
    <id>http://leii.me/2016/06/03/转-http的session与cookie/</id>
    <published>2016-06-03T14:05:54.000Z</published>
    <updated>2016-09-20T00:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：虽然session机制在web应用程序中被采用已经很长时间了，但是仍然有很多人不清楚session机制的本质，以至不能正确的应用这一技术。本文将详细讨论session的工作机制并且对在Java web application中应用session机制时常见的问题作出解答。 </p>
<p>目录： </p>
<p>一、术语session </p>
<p>二、HTTP协议与状态保持 </p>
<p>三、理解cookie机制 </p>
<p>四、理解session机制 </p>
<p>五、理解javax.servlet.http.HttpSession </p>
<p>六、HttpSession常见问题 </p>
<p>七、跨应用程序的session共享 </p>
<p>八、总结 </p>
<p>参考文档 </p>
<p>一、术语session </p>
<p>在我的经验里，session这个词被滥用的程度大概仅次于transaction，更加有趣的是transaction与session在某些语境下的含义是相同的。 </p>
<p>session，中文经常翻译为会话，其本来的含义是指有始有终的一系列动作/消息，比如打电话时从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个 session。有时候我们可以看到这样的话“在一个浏览器会话期间，…”，这里的会话一词用的就是其本义，是指从一个浏览器窗口打开到关闭这个期间 ①。最混乱的是“用户（客户端）在一次会话期间”这样一句话，它可能指用户的一系列动作（一般情况下是同某个具体目的相关的一系列动作，比如从登录到选购商品到结账登出这样一个网上购物的过程，有时候也被称为一个transaction），然而有时候也可能仅仅是指一次连接，也有可能是指含义①，其中的差别只能靠上下文来推断②。 </p>
<p>然而当session一词与网络协议相关联时，它又往往隐含了“面向连接”和/或“保持状态”这样两个含义， “面向连接”指的是在通信双方在通信之前要先建立一个通信的渠道，比如打电话，直到对方接了电话通信才能开始，与此相对的是写信，在你把信发出去的时候你并不能确认对方的地址是否正确，通信渠道不一定能建立，但对发信人来说，通信已经开始了。“保持状态”则是指通信的一方能够把一系列的消息关联起来，使得消息之间可以互相依赖，比如一个服务员能够认出再次光临的老顾客并且记得上次这个顾客还欠店里一块钱。这一类的例子有“一个TCP session”或者 “一个POP3 session”③。 </p>
<p>而到了web服务器蓬勃发展的时代，session在web开发语境下的语义又有了新的扩展，它的含义是指一类用来在客户端与服务器之间保持状态的解决方案④。有时候session也用来指这种解决方案的存储结构，如“把xxx保存在session 里”⑤。由于各种用于web开发的语言在一定程度上都提供了对这种解决方案的支持，所以在某种特定语言的语境下，session也被用来指代该语言的解决方案，比如经常把Java里提供的javax.servlet.http.HttpSession简称为session⑥。</p>
<p>鉴于这种混乱已不可改变，本文中session一词的运用也会根据上下文有不同的含义，请大家注意分辨。<br>在本文中，使用中文“浏览器会话期间”来表达含义①，使用“session机制”来表达含义④，使用“session”表达含义⑤，使用具体的“HttpSession”来表达含义⑥ </p>
<p>二、HTTP协议与状态保持 </p>
<p>HTTP 协议本身是无状态的，这与HTTP协议本来的目的是相符的，客户端只需要简单的向服务器请求下载某些文件，无论是客户端还是服务器都没有必要纪录彼此过去的行为，每一次请求之间都是独立的，好比一个顾客和一个自动售货机或者一个普通的（非会员制）大卖场之间的关系一样。 </p>
<p>然而聪明（或者贪心？）的人们很快发现如果能够提供一些按需生成的动态信息会使web变得更加有用，就像给有线电视加上点播功能一样。这种需求一方面迫使HTML逐步添加了表单、脚本、DOM等客户端行为，另一方面在服务器端则出现了CGI规范以响应客户端的动态请求，作为传输载体的HTTP协议也添加了文件上载、 cookie这些特性。其中cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。至于后来出现的session机制则是又一种在客户端与服务器之间保持状态的解决方案。 </p>
<p>让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： </p>
<p>1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 </p>
<p>2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 </p>
<p>3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。 </p>
<p>由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 </p>
<p>三、理解cookie机制<br>cookie机制的基本原理就如上面的例子一样简单，但是还有几个问题需要解决：“会员卡”如何分发；“会员卡”的内容；以及客户如何使用“会员卡”。 </p>
<p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。 </p>
<p>而cookie 的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。意思是麦当劳的会员卡只能在麦当劳的店里出示，如果某家分店还发行了自己的会员卡，那么进这家店的时候除了要出示麦当劳的会员卡，还要出示这家店的会员卡。 </p>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。 </p>
<p>其中域可以指定某一个域比如.google.com，相当于总店招牌，比如宝洁公司，也可以指定一个域下的具体某台机器比如www.google.com或者froogle.google.com，可以用飘柔来做比。<br>路径就是跟在域名后面的URL路径，比如/或者/foo等等，可以用某飘柔专柜做比。<br>路径与域合在一起就构成了cookie的作用范围。 </p>
<p>如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览器会话期的 cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。 </p>
<p>存储在硬盘上的cookie 可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。对于IE，在一个打开的窗口上按 Ctrl-N（或者从文件菜单）打开的窗口可以与原窗口共享，而使用其他方式新开的IE进程则不能共享已经打开的窗口的内存cookie；对于 Mozilla Firefox0.8，所有的进程和标签页都可以共享同样的cookie。一般来说是用javascript的window.open打开的窗口会与原窗口共享内存cookie。浏览器对于会话cookie的这种只认cookie不认人的处理方式经常给采用session机制的web应用程序开发者造成很大的困扰。 </p>
<p>下面就是一个goolge设置cookie的响应头的例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found </div><div class="line">Location: http://www.google.com/intl/zh-CN/ </div><div class="line">Set-Cookie: PREF=ID=0565f77e132de138:NW=1:TM=1098082649:LM=1098082649: </div><div class="line">S=KaeaCFPo49RiA_d8; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com </div><div class="line">Content-Type: text/html</div></pre></td></tr></table></figure>
<p>这是使用HTTPLook这个HTTP Sniffer软件来俘获的HTTP通讯纪录的一部分 </p>
<p>浏览器在再次访问goolge的资源时自动向外发送cookie </p>
<p>使用Firefox可以很容易的观察现有的cookie的值<br>使用HTTPLook配合Firefox可以很容易的理解cookie的工作原理。 </p>
<p>IE也可以设置在接受cookie前询问 </p>
<p>这是一个询问接受cookie的对话框。 </p>
<p>四、理解session机制<br>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 </p>
<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。 </p>
<p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID= ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是 JSESSIONID。 </p>
<p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为<a href="http://...../xxx;jsessionid=" target="_blank" rel="external">http://...../xxx;jsessionid=</a><br>ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764<br>另一种是作为查询字符串附加在URL后面，表现形式为<a href="http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764" target="_blank" rel="external">http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</a><br>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。<br>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。 </p>
<p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; </div><div class="line">&lt;input type=&quot;text&quot;&gt; </div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>在被传递给客户端之前将被改写成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; </div><div class="line">&lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; </div><div class="line">value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; </div><div class="line">&lt;input type=&quot;text&quot;&gt; </div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>这种技术现在已较少应用，笔者接触过的很古老的iPlanet6(SunONE应用服务器的前身)就使用了这种技术。<br>实际上这种技术可以简单的用对action应用URL重写来代替。 </p>
<p>在谈论session机制的时候，常常听到这样一种误解“只要关闭浏览器，session就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个 session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够找到原来的session。 </p>
<p>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 </p>
<p>五、理解javax.servlet.http.HttpSession </p>
<p>HttpSession是Java平台对session机制的实现规范，因为它仅仅是个接口，具体到每个web应用服务器的提供商，除了对规范支持之外，仍然会有一些规范里没有规定的细微差异。这里我们以BEA的Weblogic Server8.1作为例子来演示。 </p>
<p>首先，Weblogic Server提供了一系列的参数来控制它的HttpSession的实现，包括使用cookie的开关选项，使用URL重写的开关选项，session持久化的设置，session失效时间的设置，以及针对cookie的各种设置，比如设置cookie的名字、路径、域， cookie的生存时间等。 </p>
<p>一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用， Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。 </p>
<p>复制严格说来不算持久化保存，因为session实际上还是保存在内存里，不过同样的信息被复制到各个cluster内的服务器进程中，这样即使某个服务器进程停止工作也仍然可以从其他进程中取得session。 </p>
<p>cookie生存时间的设置则会影响浏览器生成的cookie是否是一个会话cookie。默认是使用会话cookie。有兴趣的可以用它来试验我们在第四节里提到的那个误解。 </p>
<p>cookie的路径对于web应用程序来说是一个非常重要的选项，Weblogic Server对这个选项的默认处理方式使得它与其他服务器有明显的区别。后面我们会专题讨论。 </p>
<p>关于session的设置参考[5] <a href="http://e-docs.bea.com/wls/docs70/webapp/weblogic_xml.html#1036869" target="_blank" rel="external">http://e-docs.bea.com/wls/docs70/webapp/weblogic_xml.html#1036869</a> </p>
<p>六、HttpSession常见问题 </p>
<p>（在本小节中session的含义为⑤和⑥的混合） </p>
<p>1、session在何时被创建 </p>
<p>一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;% @page session=”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句 HttpSession session = HttpServletRequest.getSession(true);这也是JSP中隐含的 session对象的来历。 </p>
<p>由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 </p>
<p>2、session何时被删除 </p>
<p>综合前面的讨论，session在下列情况下被删除a.程序调用HttpSession.invalidate();或b.距离上一次收到客户端发送的session id时间间隔超过了session的超时设置;或c.服务器进程被停止（非持久session） </p>
<p>3、如何做到在浏览器关闭时删除session </p>
<p>严格的讲，做不到这一点。可以做一点努力的办法是在所有的客户端页面里使用javascript代码window.oncolose来监视浏览器的关闭动作，然后向服务器发送一个请求来删除session。但是对于浏览器崩溃或者强行杀死进程这些非常规手段仍然无能为力。 </p>
<p>4、有个HttpSessionListener是怎么回事 </p>
<p>你可以创建这样的listener去监控session的创建和销毁事件，使得在发生这样的事件时你可以做一些相应的工作。注意是session的创建和销毁动作触发listener，而不是相反。类似的与HttpSession有关的listener还有 HttpSessionBindingListener，HttpSessionActivationListener和 HttpSessionAttributeListener。 </p>
<p>5、存放在session中的对象必须是可序列化的吗 </p>
<p>不是必需的。要求对象可序列化只是为了session能够在集群中被复制或者能够持久保存或者在必要时server能够暂时把session交换出内存。在 Weblogic Server的session中放置一个不可序列化的对象在控制台上会收到一个警告。我所用过的某个iPlanet版本如果 session中有不可序列化的对象，在session销毁时会有一个Exception，很奇怪。 </p>
<p>6、如何才能正确的应付客户端禁止cookie的可能性 </p>
<p>对所有的URL使用URL重写，包括超链接，form的action，和重定向的URL，具体做法参见[6]<br><a href="http://e-docs.bea.com/wls/docs70/webapp/sessions.html#100770" target="_blank" rel="external">http://e-docs.bea.com/wls/docs70/webapp/sessions.html#100770</a> </p>
<p>7、开两个浏览器窗口访问应用程序会使用同一个session还是不同的session</p>
<p>参见第三小节对cookie的讨论，对session来说是只认id不认人，因此不同的浏览器，不同的窗口打开方式以及不同的cookie存储方式都会对这个问题的答案有影响。 </p>
<p>8、如何防止用户打开两个浏览器窗口操作导致的session混乱</p>
<p>这个问题与防止表单多次提交是类似的，可以通过设置客户端的令牌来解决。就是在服务器每次生成一个不同的id返回给客户端，同时保存在session里，客户端提交表单时必须把这个id也返回服务器，程序首先比较返回的id与保存在session里的值是否一致，如果不一致则说明本次操作已经被提交过了。可以参看《J2EE核心模式》关于表示层模式的部分。需要注意的是对于使用javascript window.open打开的窗口，一般不设置这个id，或者使用单独的id，以防主窗口无法操作，建议不要再window.open打开的窗口里做修改操作，这样就可以不用设置。 </p>
<p>9、为什么在Weblogic Server中改变session的值后要重新调用一次session.setValue </p>
<p>做这个动作主要是为了在集群环境中提示Weblogic Server session中的值发生了改变，需要向其他服务器进程复制新的session值。 </p>
<p>10、为什么session不见了 </p>
<p>排除session正常失效的因素之外，服务器本身的可能性应该是微乎其微的，虽然笔者在iPlanet6SP1加若干补丁的Solaris版本上倒也遇到过；浏览器插件的可能性次之，笔者也遇到过3721插件造成的问题；理论上防火墙或者代理服务器在cookie处理上也有可能会出现问题。<br>出现这一问题的大部分原因都是程序的错误，最常见的就是在一个应用程序中去访问另外一个应用程序。我们在下一节讨论这个问题。 </p>
<p>七、跨应用程序的session共享 </p>
<p>常常有这样的情况，一个大项目被分割成若干小项目开发，为了能够互不干扰，要求每个小项目作为一个单独的web应用程序开发，可是到了最后突然发现某几个小项目之间需要共享一些信息，或者想使用session来实现SSO(single sign on)，在session中保存login的用户信息，最自然的要求是应用程序间能够访问彼此的session。 </p>
<p>然而按照Servlet规范，session的作用范围应该仅仅限于当前应用程序下，不同的应用程序之间是不能够互相访问对方的session的。各个应用服务器从实际效果上都遵守了这一规范，但是实现的细节却可能各有不同，因此解决跨应用程序session共享的方法也各不相同。 </p>
<p>首先来看一下Tomcat是如何实现web应用程序之间session的隔离的，从 Tomcat设置的cookie路径来看，它对不同的应用程序设置的cookie路径是不同的，这样不同的应用程序所用的session id是不同的，因此即使在同一个浏览器窗口里访问不同的应用程序，发送给服务器的session id也可以是不同的。 </p>
<p>根据这个特性，我们可以推测Tomcat中session的内存结构大致如下。 </p>
<p>笔者以前用过的iPlanet也采用的是同样的方式，估计SunONE与iPlanet之间不会有太大的差别。对于这种方式的服务器，解决的思路很简单，实际实行起来也不难。要么让所有的应用程序共享一个session id，要么让应用程序能够获得其他应用程序的session id。 </p>
<p>iPlanet中有一种很简单的方法来实现共享一个session id，那就是把各个应用程序的cookie路径都设为/（实际上应该是/NASApp，对于应用程序来讲它的作用相当于根）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-info&gt; </div><div class="line">&lt;path&gt;/NASApp&lt;/path&gt; </div><div class="line">&lt;/session-info&gt;</div></pre></td></tr></table></figure>
<p>需要注意的是，操作共享的session应该遵循一些编程约定，比如在session attribute名字的前面加上应用程序的前缀，使得 setAttribute(“name”, “neo”)变成setAttribute(“app1.name”, “neo”)，以防止命名空间冲突，导致互相覆盖。 </p>
<p>在Tomcat中则没有这么方便的选择。在Tomcat版本3上，我们还可以有一些手段来共享session。对于版本4以上的Tomcat，目前笔者尚未发现简单的办法。只能借助于第三方的力量，比如使用文件、数据库、JMS或者客户端cookie，URL参数或者隐藏字段等手段。 </p>
<p>我们再看一下Weblogic Server是如何处理session的。 </p>
<p>从截屏画面上可以看到Weblogic Server对所有的应用程序设置的cookie的路径都是/，这是不是意味着在Weblogic Server中默认的就可以共享session了呢？然而一个小实验即可证明即使不同的应用程序使用的是同一个session，各个应用程序仍然只能访问自己所设置的那些属性。这说明Weblogic Server中的session的内存结构可能如下 </p>
<p>对于这样一种结构，在 session机制本身上来解决session共享的问题应该是不可能的了。除了借助于第三方的力量，比如使用文件、数据库、JMS或者客户端 cookie，URL参数或者隐藏字段等手段，还有一种较为方便的做法，就是把一个应用程序的session放到ServletContext中，这样另外一个应用程序就可以从ServletContext中取得前一个应用程序的引用。示例代码如下， </p>
<p>应用程序A </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.setAttribute(&quot;appA&quot;, session);</div></pre></td></tr></table></figure>
<p>应用程序B </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contextA = context.getContext(&quot;/appA&quot;); </div><div class="line">HttpSession sessionA = (HttpSession)contextA.getAttribute(&quot;appA&quot;);</div></pre></td></tr></table></figure>
<p>值得注意的是这种用法不可移植，因为根据ServletContext的JavaDoc，应用服务器可以处于安全的原因对于context.getContext(“/appA”);返回空值，以上做法在Weblogic Server 8.1中通过。 </p>
<p>那么Weblogic Server为什么要把所有的应用程序的cookie路径都设为/呢？原来是为了SSO，凡是共享这个session的应用程序都可以共享认证的信息。一个简单的实验就可以证明这一点，修改首先登录的那个应用程序的描述符weblogic.xml，把cookie路径修改为/appA 访问另外一个应用程序会重新要求登录，即使是反过来，先访问cookie路径为/的应用程序，再访问修改过路径的这个，虽然不再提示登录，但是登录的用户信息也会丢失。注意做这个实验时认证方式应该使用FORM，因为浏览器和web服务器对basic认证方式有其他的处理方式，第二次请求的认证不是通过 session来实现的。</p>
<p>具体请参看[7] secion 14.8 Authorization，你可以修改所附的示例程序来做这些试验。</p>
<p>八、总结 </p>
<p>session机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的经验，而是始终需要具体情况具体分析。 </p>
<p>摘要：虽然session机制在web应用程序中被采用已经很长时间了，但是仍然有很多人不清楚session机制的本质，以至不能正确的应用这一技术。本文将详细讨论session的工作机制并且对在Java web application中应用session机制时常见的问题作出解答</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：虽然session机制在web应用程序中被采用已经很长时间了，但是仍然有很多人不清楚session机制的本质，以至不能正确的应用这一技术。本文将详细讨论session的工作机制并且对在Java web application中应用session机制时常见的问题作出解答
    
    </summary>
    
      <category term="Base" scheme="http://leii.me/categories/Base/"/>
    
    
      <category term="转" scheme="http://leii.me/tags/%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>苹果高德百度定位坐标转换</title>
    <link href="http://leii.me/2016/06/03/%E8%8B%B9%E6%9E%9C%E9%AB%98%E5%BE%B7%E7%99%BE%E5%BA%A6%E5%AE%9A%E4%BD%8D%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <id>http://leii.me/2016/06/03/苹果高德百度定位坐标转换/</id>
    <published>2016-06-03T12:41:28.000Z</published>
    <updated>2016-09-13T08:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84"><a href="#苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84" class="headerlink" title="苹果的CLLocationManager定位得到的是世界标准地理坐标(WGS-84)"></a>苹果的CLLocationManager定位得到的是世界标准地理坐标(WGS-84)</h4><h4 id="高德SDK定位得到的是火星坐标（GCJ-02）"><a href="#高德SDK定位得到的是火星坐标（GCJ-02）" class="headerlink" title="高德SDK定位得到的是火星坐标（GCJ-02）"></a>高德SDK定位得到的是火星坐标（GCJ-02）</h4><h4 id="百度SDK定位得到的是百度地理坐标（BD-09）"><a href="#百度SDK定位得到的是百度地理坐标（BD-09）" class="headerlink" title="百度SDK定位得到的是百度地理坐标（BD-09）"></a>百度SDK定位得到的是百度地理坐标（BD-09）</h4><p>有的项目里因为老的代码或者第三方库用的SDK不一样，也可能后端使用的定位SDK更换，都会需要坐标的转换来兼容老版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">#define LAT_OFFSET_0(x,y) -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x))  </div><div class="line">#define LAT_OFFSET_1 (20.0 * sin(6.0 * x * M_PI) + 20.0 * sin(2.0 * x * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LAT_OFFSET_2 (20.0 * sin(y * M_PI) + 40.0 * sin(y / 3.0 * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LAT_OFFSET_3 (160.0 * sin(y / 12.0 * M_PI) + 320 * sin(y * M_PI / 30.0)) * 2.0 / 3.0  </div><div class="line">  </div><div class="line">#define LON_OFFSET_0(x,y) 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x))  </div><div class="line">#define LON_OFFSET_1 (20.0 * sin(6.0 * x * M_PI) + 20.0 * sin(2.0 * x * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LON_OFFSET_2 (20.0 * sin(x * M_PI) + 40.0 * sin(x / 3.0 * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LON_OFFSET_3 (150.0 * sin(x / 12.0 * M_PI) + 300.0 * sin(x / 30.0 * M_PI)) * 2.0 / 3.0  </div><div class="line">  </div><div class="line">#define RANGE_LON_MAX 137.8347  </div><div class="line">#define RANGE_LON_MIN 72.004  </div><div class="line">#define RANGE_LAT_MAX 55.8271  </div><div class="line">#define RANGE_LAT_MIN 0.8293  </div><div class="line">// jzA = 6378245.0, 1/f = 298.3  </div><div class="line">// b = a * (1 - f)  </div><div class="line">// ee = (a^2 - b^2) / a^2;  </div><div class="line">#define jzA 6378245.0  </div><div class="line">#define jzEE 0.00669342162296594323  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">//判断是不是在中国  </div><div class="line">+(BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271)  </div><div class="line">        return YES;  </div><div class="line">    return NO;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (double)transformLat:(double)x BDLon:(double)y  </div><div class="line">&#123;  </div><div class="line">    double ret = LAT_OFFSET_0(x, y);  </div><div class="line">    ret += LAT_OFFSET_1;  </div><div class="line">    ret += LAT_OFFSET_2;  </div><div class="line">    ret += LAT_OFFSET_3;  </div><div class="line">    return ret;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (double)transformLon:(double)x BDLon:(double)y  </div><div class="line">&#123;  </div><div class="line">    double ret = LON_OFFSET_0(x, y);  </div><div class="line">    ret += LON_OFFSET_1;  </div><div class="line">    ret += LON_OFFSET_2;  </div><div class="line">    ret += LON_OFFSET_3;  </div><div class="line">    return ret;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (BOOL)outOfChina:(double)lat BDLon:(double)lon  </div><div class="line">&#123;  </div><div class="line">    if (lon &lt; RANGE_LON_MIN || lon &gt; RANGE_LON_MAX)  </div><div class="line">        return true;  </div><div class="line">    if (lat &lt; RANGE_LAT_MIN || lat &gt; RANGE_LAT_MAX)  </div><div class="line">        return true;  </div><div class="line">    return false;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02Encrypt:(double)ggLat BDLon:(double)ggLon  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D resPoint;  </div><div class="line">    double mgLat;  </div><div class="line">    double mgLon;  </div><div class="line">    if ([self outOfChina:ggLat BDLon:ggLon]) &#123;  </div><div class="line">        resPoint.latitude = ggLat;  </div><div class="line">        resPoint.longitude = ggLon;  </div><div class="line">        return resPoint;  </div><div class="line">    &#125;  </div><div class="line">    double dLat = [self transformLat:(ggLon - 105.0)BDLon:(ggLat - 35.0)];  </div><div class="line">    double dLon = [self transformLon:(ggLon - 105.0) BDLon:(ggLat - 35.0)];  </div><div class="line">    double radLat = ggLat / 180.0 * M_PI;  </div><div class="line">    double magic = sin(radLat);  </div><div class="line">    magic = 1 - jzEE * magic * magic;  </div><div class="line">    double sqrtMagic = sqrt(magic);  </div><div class="line">    dLat = (dLat * 180.0) / ((jzA * (1 - jzEE)) / (magic * sqrtMagic) * M_PI);  </div><div class="line">    dLon = (dLon * 180.0) / (jzA / sqrtMagic * cos(radLat) * M_PI);  </div><div class="line">    mgLat = ggLat + dLat;  </div><div class="line">    mgLon = ggLon + dLon;  </div><div class="line">      </div><div class="line">    resPoint.latitude = mgLat;  </div><div class="line">    resPoint.longitude = mgLon;  </div><div class="line">    return resPoint;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02Decrypt:(double)gjLat gjLon:(double)gjLon &#123;  </div><div class="line">    CLLocationCoordinate2D  gPt = [self GCJ02Encrypt:gjLat BDLon:gjLon];  </div><div class="line">    double dLon = gPt.longitude - gjLon;  </div><div class="line">    double dLat = gPt.latitude - gjLat;  </div><div class="line">    CLLocationCoordinate2D pt;  </div><div class="line">    pt.latitude = gjLat - dLat;  </div><div class="line">    pt.longitude = gjLon - dLon;  </div><div class="line">    return pt;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)BD09Decrypt:(double)BDLat BDLon:(double)BDLon  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D GCJPt;  </div><div class="line">    double x = BDLon - 0.0065, y = BDLat - 0.006;  </div><div class="line">    double z = sqrt(x * x + y * y) - 0.00002 * sin(y * M_PI);  </div><div class="line">    double theta = atan2(y, x) - 0.000003 * cos(x * M_PI);  </div><div class="line">    GCJPt.longitude = z * cos(theta);  </div><div class="line">    GCJPt.latitude = z * sin(theta);  </div><div class="line">    return GCJPt;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+(CLLocationCoordinate2D)BD09Encrypt:(double)ggLat BDLon:(double)ggLon  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D BDPt;  </div><div class="line">    double x = ggLon, y = ggLat;  </div><div class="line">    double z = sqrt(x * x + y * y) + 0.00002 * sin(y * M_PI);  </div><div class="line">    double theta = atan2(y, x) + 0.000003 * cos(x * M_PI);  </div><div class="line">    BDPt.longitude = z * cos(theta) + 0.0065;  </div><div class="line">    BDPt.latitude = z * sin(theta) + 0.006;  </div><div class="line">    return BDPt;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">//6种转换</div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)WGS84ToGCJ02:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return [self GCJ02Encrypt:location.latitude BDLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02ToWGS84:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return [self GCJ02Decrypt:location.latitude gjLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)WGS84ToBD09:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D GCJ02Pt = [self GCJ02Encrypt:location.latitude  </div><div class="line">                                                  BDLon:location.longitude];  </div><div class="line">    return [self BD09Encrypt:GCJ02Pt.latitude BDLon:GCJ02Pt.longitude] ;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02ToBD09:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return  [self BD09Encrypt:location.latitude BDLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)BD09ToGCJ02:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return [self BD09Decrypt:location.latitude BDLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)BD09ToWGS84:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D GCJ02 = [self BD09ToGCJ02:location];  </div><div class="line">    return [self GCJ02Decrypt:GCJ02.latitude gjLon:GCJ02.longitude];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84&quot;&gt;&lt;a href=&quot;#苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84&quot; class=&quot;headerlink&quot; title=&quot;苹果的CLLocat
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>大学时的渣画</title>
    <link href="http://leii.me/2016/05/17/%E5%A4%A7%E5%AD%A6%E6%97%B6%E7%9A%84%E6%B8%A3%E7%94%BB/"/>
    <id>http://leii.me/2016/05/17/大学时的渣画/</id>
    <published>2016-05-17T11:39:42.000Z</published>
    <updated>2016-09-22T09:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>好怀念当初在校自己做手游找不到美术，然后一手键盘一手数位板的日子，虽然一直没有什么进步也没时间系统的学一下 ╮(╯_╰)╭  </p>
<p><img src="http://imglf2.nosdn.127.net/img/SnJLZEdtSzE0OVJrRWZFS1FsSmhHNE9lUnlXUnhDTEQ.png?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg"></p>
<p><img src="http://imglf1.nosdn.127.net/img/SnJLZEdtSzE0OVRFblo1aGh4aE0rUUhSUkgyM2RhUVY.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好怀念当初在校自己做手游找不到美术，然后一手键盘一手数位板的日子，虽然一直没有什么进步也没时间系统的学一下 ╮(╯_╰)╭  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/SnJLZEdtSzE0OVJrRWZFS1Fs
    
    </summary>
    
      <category term="Design" scheme="http://leii.me/categories/Design/"/>
    
    
  </entry>
  
  <entry>
    <title>开张</title>
    <link href="http://leii.me/2016/05/17/%E5%BC%80%E5%BC%A0/"/>
    <id>http://leii.me/2016/05/17/开张/</id>
    <published>2016-05-17T01:04:15.000Z</published>
    <updated>2016-09-23T05:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间突然心血来潮画了这两张公司LOGO的同人画，唉~毕业了两年第一次翻出数位板，居然还没有坏，感慨万千，虽然画的还是这么渣不过这种创作的快感依然不减，以后码代码的时间需要平衡一下了，毕竟多维的人生才更有乐趣。</p>
<p>CSDN简书博客园显然技术氛围太浓分享技术以外的东西都感觉很违和，以后各种类型的作品都可以放在这个个人博客里了哈哈哈</p>
<p><img src="http://imglf1.nosdn.127.net/img/SnJLZEdtSzE0OVFaSzRVL1RTWXVaVm9KZ2xtdDJ5VVoyT0dhd3pWWmxXbVVxSUc0SmRrdG5RPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg"></p>
<p><img src="http://imglf.nosdn.127.net/img/SnJLZEdtSzE0OVFaSzRVL1RTWXVaZGNhRmdYWGlsOGIwbEhPY052ZnhRZ0VZeDhxeU1acDJRPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间突然心血来潮画了这两张公司LOGO的同人画，唉~毕业了两年第一次翻出数位板，居然还没有坏，感慨万千，虽然画的还是这么渣不过这种创作的快感依然不减，以后码代码的时间需要平衡一下了，毕竟多维的人生才更有乐趣。&lt;/p&gt;
&lt;p&gt;CSDN简书博客园显然技术氛围太浓分享技术以外
    
    </summary>
    
      <category term="Design" scheme="http://leii.me/categories/Design/"/>
    
    
  </entry>
  
</feed>
