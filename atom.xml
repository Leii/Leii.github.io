<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leii&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leii.me/"/>
  <updated>2016-09-20T10:29:40.000Z</updated>
  <id>http://leii.me/</id>
  
  <author>
    <name>Leii</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>URL Loading System</title>
    <link href="http://leii.me/2016/09/19/URL-Loading-System/"/>
    <id>http://leii.me/2016/09/19/URL-Loading-System/</id>
    <published>2016-09-19T15:55:29.000Z</published>
    <updated>2016-09-20T10:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>URL Loading System的类主要有以下几种： </p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="url loading system"></p>
<p>其中最重要的3个类分别是NSURLConnection、NSURLSession、NSURLProtocol。</p>
<h5 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h5><p>NSURLConnection 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。</p>
<p>NSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 <nsurlconnectiondelegate> 和 <nsurlconnectiondatadelegate>）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。</nsurlconnectiondatadelegate></nsurlconnectiondelegate></p>
<p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>
<p><img src="http://images.cnitblog.com/i/450136/201406/281617337427186.png" alt="NSURLConnection Pic1"></p>
<p>下面是GET同步请求与异步请求的实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//    GET请求：请求行\请求头\请求体</div><div class="line">//</div><div class="line">//    1.设置请求路径</div><div class="line">     NSString *urlStr= [NSString stringWithFormat: @&quot;http://leii.me/login?username=%@&amp;pwd=%@&quot;,self.username.text,self.pwd.text];</div><div class="line">     NSURL *url=[NSURL URLWithString:urlStr];</div><div class="line">//    2.创建请求对象</div><div class="line">    NSURLRequest *request=[NSURLRequest requestWithURL:url];</div><div class="line">//    3.发送请求</div><div class="line">    //发送同步请求，在主线程执行</div><div class="line">    NSData *data=[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];</div><div class="line">    //（一直在等待服务器返回数据，这行代码会卡住，如果服务器没有返回数据，那么在主线程UI会卡住不能继续执行操作）</div><div class="line">    NSLog(@&quot;同步请求结果：--%d--&quot;,data.length);</div><div class="line">    </div><div class="line">    //发送异步请求</div><div class="line">    //创建一个队列（默认添加到该队列中的任务异步执行）</div><div class="line">//    NSOperationQueue *queue=[[NSOperationQueue alloc]init];</div><div class="line">    //获取一个主队列</div><div class="line">    NSOperationQueue *queue=[NSOperationQueue mainQueue];</div><div class="line">    [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;</div><div class="line">    //通过block异步获取response</div><div class="line">        NSLog(@&quot;--block异步回调数据--%@---%d&quot;, [NSThread currentThread],data.length);</div><div class="line">    &#125;）；</div></pre></td></tr></table></figure>
<p>还可以使用代理方法发送异步请求</p>
<p>要监听服务器返回的data，所以使用<nsurlconnectiondatadelegate>协议</nsurlconnectiondatadelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#pragma mark- NSURLConnectionDataDelegate代理方法</div><div class="line"></div><div class="line">//当接收到服务器的响应（连通了服务器）时会调用</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</div><div class="line"></div><div class="line">//当接收到服务器的数据时会调用（可能会被调用多次，每次只传递部分数据）</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data</div><div class="line"></div><div class="line">//当服务器的数据加载完毕时就会调用</div><div class="line"></div><div class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection</div><div class="line"></div><div class="line">//请求错误（失败）的时候调用（请求超时\断网\没有网\，一般指客户端错误）</div><div class="line"></div><div class="line">-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</div></pre></td></tr></table></figure>
<h5 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h5><p>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。</p>
<p>NSURLSession也是一组相互依赖的类，它的大部分组件和NSURLConnection中的组件相同如NSURLRequest，NSURLCache等。而NSURLSession的不同之处在于，它将NSURLConnection替换为NSURLSession和NSURLSessionConfiguration，以及3个NSURLSessionTask的子类：NSURLSessionDataTask, NSURLSessionUploadTask, 和NSURLSessionDownloadTask。</p>
<p>下面是新推出的类：</p>
<p>1.NSURLSessionConfiguration类</p>
<p>其中NSURLSessionConfiguration用于配置会话的属性，可以通过该类配置会话的工作模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (NSURLSessionConfiguration *)defaultSessionConfiguration;  </div><div class="line">+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;  </div><div class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfiguration:(NSString *)identifier;</div></pre></td></tr></table></figure>
<p>在backgroundSessionConfiguration:方法中的identifier参数指定了会话的ID，用于标记后台的session。<br>该类的其中两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* allow request to route over cellular. */  </div><div class="line">@property BOOL allowsCellularAccess;  </div><div class="line">  </div><div class="line">/* allows background tasks to be scheduled at the discretion of the system for optimal performance. */  </div><div class="line">@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(NA, 7_0);</div></pre></td></tr></table></figure>
<p>allowsCellularAccess 属性指定是否允许使用蜂窝连接， discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。补充：这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过Wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p>
<p>2.NSURLSession类</p>
<p>获取NSURLSession类对象有几种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (NSURLSession *)sharedSession;  </div><div class="line">  </div><div class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration; </div><div class="line"> </div><div class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue;</div></pre></td></tr></table></figure>
<p>第一种方式是使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书。</p>
<p>第二种方式是通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用。</p>
<p>第三种方式是通过sessionWithConfiguration:delegate:delegateQueue方法创建对象，二三两种方式可以创建一个新会话并定制其会话类型。该方式中指定了session的委托和委托所处的队列。当不再需要连接时，可以调用Session的invalidateAndCancel直接关闭，或者调用finishTasksAndInvalidate等待当前Task结束后关闭。这时Delegate会收到URLSession:didBecomeInvalidWithError:这个事件。Delegate收到这个事件之后会被解引用。</p>
<p>3.NSURLSessionTask类</p>
<p>NSURLSessionTask是一个抽象子类，它有三个子类：NSURLSessionDataTask，NSURLSessionUploadTask和NSURLSessionDownloadTask。这三个类封装了现代应用程序的三个基本网络任务：获取数据，比如JSON或XML，以及上传和下载文件。</p>
<blockquote>
<p>与 NSURLConnection 相比，NSURLsession 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 NSURLSession 对象都由一个 NSURLSessionConfiguration 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</p>
</blockquote>
<p>NSURLSession 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。NSURLSessionTask 与 NSURLConnection 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 NSURLSession 这一公共委托者（common delegate）。</p>
<p>下面是其继承关系：<br><img src="http://img.blog.csdn.net/20140205121918203" alt="pic2"></p>
<p>有多种方法创建对应的任务对象：</p>
<p>（1）NSURLSessionDataTask</p>
<p>通过request对象或url创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Creates a data task with the given request.  The request may have a body stream. */  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;  </div><div class="line">  </div><div class="line">/* Creates a data task to retrieve the contents of the given URL. */  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;</div></pre></td></tr></table></figure>
<p>通过request对象或url创建，同时指定任务完成后通过completionHandler指定回调的代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>（2）NSURLSessionUploadTask<br>通过request创建，在上传时指定文件源或数据源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  </div><div class="line">  </div><div class="line">/* Creates an upload task with the given request.  The body of the request is provided from the bodyData. */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  </div><div class="line">  </div><div class="line">/* Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;</div></pre></td></tr></table></figure>
<p>在创建upload task对象时，通过completionHandler指定任务完成后的回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* </div><div class="line"> * upload convenience method. </div><div class="line"> */  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>（3）NSURLSessionDownloadTask</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/* Creates a download task with the given request. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;  </div><div class="line">  </div><div class="line">/* Creates a download task to download the contents of the given URL. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;  </div><div class="line">  </div><div class="line">/* Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;</div></pre></td></tr></table></figure>
<p>下载任务支持断点续传，第三种方式是通过之前已经下载的数据来创建下载任务。<br>同样地可以通过completionHandler指定任务完成后的回调代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;</div></pre></td></tr></table></figure>
<p>4.NSURLSessionDelegate和NSURLSessionTaskDelegate协议</p>
<p>在协议的方法中可以完成各种各样的回调动作，如身份验证、完成任务后的动作、错误处理和后台任务完成的动作等。委托方法指定在NSURLSession中一定数量的字节传输使用int64_t类型的参数。</p>
<p>这里只说下后台任务的一个委托方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>合作使用的ApplicationDelegate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler NS_AVAILABLE_IOS(7_0);</div></pre></td></tr></table></figure>
<p>将任务切换到后台之后，Session的Delegate不会再收到和Task相关的消息。当所有Task全都完成后，程序将被唤醒，并调用ApplicationDelegate的application:handleEventsForBackgroundURLSession:completionHandler:回调，在这里要为后台session（由background session的identifier标识）指定对应的回调代码块。<br>随后，对于每一个完成的后台Task调用该Session的Delegate中的URLSession:downloadTask:didFinishDownloadingToURL:（成功的话）和URLSession:task:didCompleteWithError:（成功或者失败都会调用）方法做处理，以上的回调代码块可以在这里调用。</p>
<h4 id="NSURLSession与NSURLConnection区别"><a href="#NSURLSession与NSURLConnection区别" class="headerlink" title="NSURLSession与NSURLConnection区别"></a>NSURLSession与NSURLConnection区别</h4><p>总结一下两者主要的区别：</p>
<p>1, 使用现状</p>
<p>从iOS9.0开始， NSURLConnection中发送请求的两个方法已过期（同步请求，异步请求），初始化网络连接（initWithRequest: delegate:）的方法也被设置为过期，系统不再推荐使用，建议使用NSURLSession发送网络请求。</p>
<p>2, 普通任务和上传</p>
<p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask, NSURLSessionUploadTask和NSURLSessionDownloadTask.。创建的task都是挂起状态，需要resume才能执行。</p>
<p>当服务器返回的数据较小时，NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别。</p>
<p>执行上传任务时，NSURLSession与NSURLConnection一样同样需要设置POST请求的请求体进行上传。</p>
<p>3, 下载任务方式<br>NSURLConnection下载文件时，先将整个文件下载到内存，然后再写入沙盒，如果文件比较大，就会出现内存暴涨的情况。而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在下载完成后会将tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。</p>
<p>以下代码是实例化网络下载任务时将下载的文件保存到沙盒的caches文件夹中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[NSURLSessionDownloadTask [NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://127.0.0.1/dawenjian.zip&quot;] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">   //获取沙盒的caches路径</div><div class="line"></div><div class="line">   NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]stringByAppendingPathComponent:@&quot;kkk.dmg&quot;];</div><div class="line"></div><div class="line">   //生成URL路径</div><div class="line"></div><div class="line">   NSURL *DCurl = [NSURL fileURLWithPath:path];</div><div class="line"></div><div class="line">   //将文件保存到指定文件目录下</div><div class="line"></div><div class="line">   [[NSFileManager defaultManager]moveItemAtURL:location toURL:DCurl error:nil];   &#125;]resume];</div></pre></td></tr></table></figure>
<p>4, 请求方法的控制</p>
<p>NSURLConnection实例化对象，实例化开始，默认请求就发送（同步发送），不需要调用start方法。而cancel 可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</p>
<p>NSURLSession有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务。</p>
<p>5, 断点续传的方式<br>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果 downloadTask （下载任务）为非空，调用 cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中。在点击再次下载时，通过调用 [ [self.session downloadTaskWithResumeData:self.resumeData]resume]方法进行继续下载操作。   </p>
<p>经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷。</p>
<p>6,  配置信息</p>
<p>NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个 NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比于 NSURLConnection 依赖于一个全局的配置对象，缺乏灵活性而言，NSURLSession 有很大的改进了。</p>
<p>[由于篇幅已经很长了，NSProtocol另外创建一篇文章介绍吧… ]</p>
<hr>
<p>参考：</p>
<p><a href="http://blog.csdn.net/jymn_chen/article/details/18937819" target="_blank" rel="external"> NSURLSession学习笔记（一）简介</a></p>
<p><a href="http://www.cnblogs.com/wendingding/p/3813572.html" target="_blank" rel="external">iOS开发网络篇—NSURLConnection基本使用</a></p>
<p><a href="http://www.cnblogs.com/kakaluote123/articles/5426923.html" target="_blank" rel="external">NSURLSession与NSURLConnection区别
</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;URL Loading System的类主要有以下几种： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSyste
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking(OC)与Alamofire(swift)</title>
    <link href="http://leii.me/2016/09/18/AFNetWorking-OC-%E4%B8%8EAlamofire-swift/"/>
    <id>http://leii.me/2016/09/18/AFNetWorking-OC-与Alamofire-swift/</id>
    <published>2016-09-18T10:49:37.000Z</published>
    <updated>2016-09-20T00:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetWorking与Alamofire现在分别是OC与Swift开发最流行的网络请求第三方库(当然AFNetWorking也有swift版本)，他们都是基于对Foundation中的NSURLConnect以及所以NSURLSession的封装，所以我们会先NSURLConnect和NSURLSession开始分析。</p>
<h4 id="NSURLConnect与NSURLSession"><a href="#NSURLConnect与NSURLSession" class="headerlink" title="NSURLConnect与NSURLSession"></a>NSURLConnect与NSURLSession</h4><p>NSURLConnect是早期苹果提供的用于</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetWorking与Alamofire现在分别是OC与Swift开发最流行的网络请求第三方库(当然AFNetWorking也有swift版本)，他们都是基于对Foundation中的NSURLConnect以及所以NSURLSession的封装，所以我们会先NSURL
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="格物" scheme="http://leii.me/tags/%E6%A0%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>证书与打包与APNs</title>
    <link href="http://leii.me/2016/09/18/%E8%AF%81%E4%B9%A6%E4%B8%8E%E6%89%93%E5%8C%85%E4%B8%8EAPNs/"/>
    <id>http://leii.me/2016/09/18/证书与打包与APNs/</id>
    <published>2016-09-18T10:10:49.000Z</published>
    <updated>2016-09-18T10:10:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hybrid 笔记</title>
    <link href="http://leii.me/2016/09/09/Hybrid-%E7%AC%94%E8%AE%B0/"/>
    <id>http://leii.me/2016/09/09/Hybrid-笔记/</id>
    <published>2016-09-09T08:35:25.000Z</published>
    <updated>2016-09-19T15:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hybrid App优势明显，发版不用审核，页面可以随时调整和修复，通用于3个平台节省开发成本等，很多公司都在用，类型主要分Web主体型、多View混合型、单View混合型。</p>
<p>我们公司则经历了从最早的Web主体型APP向多view混合型的过渡，公司早期人员少，业务变化快的情况下，业务代码都放在前端非常方便，不过后期随着用户量的增多，对性能和用户体验开始精益求精，将部分高频的页面native化。</p>
<p>Hybrid APP的核心就是Native和H5之间的交互</p>
<p>H5调用native用的是webview的shouldStartLoadWithRequest方法里面捕获url，解析出需要的参数，看是否有约定的异步桥接的字符串，然后传给一个统一的处理方法。native调用h5用的是UIWebView的 stringByEvaluatingJavaScriptFromString方法。</p>
<p>除此之外我们还用了同步桥接，主要是通过NSURLProtocol的拦截，先在canInitWithRequest方法里判断是否要拦截，然后再startLoading里实现拦截，并标示该request为已经处理过了，防止无限循环执行，[NSURLProtocol setProperty:@YES forKey:URLProtocolHandledKey inRequest:mutableReqeust];<br>通过url里面是否包含约定的同步桥接字符串，如果有就执行同步桥接。</p>
<p>同时因为有大量的操作是在网络连接的部分，所以Foundation库的URL加载系统也是经常要用到的，比如下图这些类：</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="url loading system"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hybrid App优势明显，发版不用审核，页面可以随时调整和修复，通用于3个平台节省开发成本等，很多公司都在用，类型主要分Web主体型、多View混合型、单View混合型。&lt;/p&gt;
&lt;p&gt;我们公司则经历了从最早的Web主体型APP向多view混合型的过渡，公司早期人员少，
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS常用判断</title>
    <link href="http://leii.me/2016/06/12/iOS%E5%B8%B8%E7%94%A8%E5%88%A4%E6%96%AD/"/>
    <id>http://leii.me/2016/06/12/iOS常用判断/</id>
    <published>2016-06-12T09:26:25.000Z</published>
    <updated>2016-09-12T14:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>[用到就记录下来…]</p>
<h4 id="判断一个对象中是否包含某个属性"><a href="#判断一个对象中是否包含某个属性" class="headerlink" title="判断一个对象中是否包含某个属性"></a>判断一个对象中是否包含某个属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (BOOL) getVariableWithClass:(Class) myClass varName:(NSString *)name&#123;       </div><div class="line">	unsigned int outCount, i;</div><div class="line">  	Ivar *ivars = class_copyIvarList(myClass, &amp;outCount);</div><div class="line">  	for (i = 0; i &lt; outCount; i++) &#123;</div><div class="line">    	Ivar property = ivars[i];</div><div class="line">    	NSString *keyName = [NSString 		stringWithCString:ivar_getName(property) encoding:NSUTF8StringEncoding];</div><div class="line">	    keyName = [keyName stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;&quot;];</div><div class="line">    	if ([keyName isEqualToString:name]) &#123;</div><div class="line">      	return YES;</div><div class="line">    	&#125;</div><div class="line">  	&#125;</div><div class="line">  	return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断字符串是否为纯数字组成"><a href="#判断字符串是否为纯数字组成" class="headerlink" title="判断字符串是否为纯数字组成"></a>判断字符串是否为纯数字组成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isPureInt:(NSString*)string&#123;</div><div class="line">    NSScanner* scan = [NSScanner scannerWithString:string];</div><div class="line">    int val;</div><div class="line">    return[scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断当天是星期几"><a href="#判断当天是星期几" class="headerlink" title="判断当天是星期几"></a>判断当天是星期几</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)weekDayJudge</div><div class="line">&#123;</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</div><div class="line">    NSDate *now;</div><div class="line">    NSDateComponents *comps = [[NSDateComponents alloc] init];</div><div class="line">    NSInteger unitFlags =NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitWeekday |</div><div class="line">    NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond;</div><div class="line">    now=[NSDate date];</div><div class="line">    comps = [calendar components:unitFlags fromDate:now];</div><div class="line"></div><div class="line">    NSLog(@&quot;weekday is %ld&quot;,(long)[comps weekday]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="iOS-判断是否开启定位"><a href="#iOS-判断是否开启定位" class="headerlink" title="iOS 判断是否开启定位"></a>iOS 判断是否开启定位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isLocationServiceOpen &#123;</div><div class="line">    if ([ CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125; else</div><div class="line">        return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="iOS-判断是否允许消息通知"><a href="#iOS-判断是否允许消息通知" class="headerlink" title="iOS 判断是否允许消息通知"></a>iOS 判断是否允许消息通知</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isMessageNotificationServiceOpen &#123;</div><div class="line">    if (SYSTEM_VERSION_GREATER_THAN(@&quot;8.0&quot;)) &#123;</div><div class="line">        return [[UIApplication sharedApplication] isRegisteredForRemoteNotifications];</div><div class="line">    &#125; else &#123;</div><div class="line">        return UIRemoteNotificationTypeNone != [[UIApplication sharedApplication] enabledRemoteNotificationTypes];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="获取当前屏幕最顶层显示的viewcontroller"><a href="#获取当前屏幕最顶层显示的viewcontroller" class="headerlink" title="获取当前屏幕最顶层显示的viewcontroller"></a>获取当前屏幕最顶层显示的viewcontroller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)getPresentedViewController</div><div class="line">&#123;</div><div class="line">    UIViewController *appRootVC = [UIApplication sharedApplication].keyWindow.rootViewController;</div><div class="line">    UIViewController *topVC = appRootVC;</div><div class="line">    if (topVC.presentedViewController) &#123;</div><div class="line">        topVC = topVC.presentedViewController;</div><div class="line">    &#125;</div><div class="line">    return topVC;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[用到就记录下来…]&lt;/p&gt;
&lt;h4 id=&quot;判断一个对象中是否包含某个属性&quot;&gt;&lt;a href=&quot;#判断一个对象中是否包含某个属性&quot; class=&quot;headerlink&quot; title=&quot;判断一个对象中是否包含某个属性&quot;&gt;&lt;/a&gt;判断一个对象中是否包含某个属性&lt;/h4&gt;&lt;fi
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Info.plist中常用的key</title>
    <link href="http://leii.me/2016/06/11/Info-plist%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84key/"/>
    <id>http://leii.me/2016/06/11/Info-plist中常用的key/</id>
    <published>2016-06-11T10:23:29.000Z</published>
    <updated>2016-09-12T09:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>Key</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>App Transport Security</td>
<td style="text-align:left">iOS9新增，如果不设置NSAllowsArbitraryLoads将默认强制使用了HTTPS协议进行传输</td>
</tr>
<tr>
<td>UIRequiresPersistentWiFi</td>
<td style="text-align:left">在程序中弹出wifi选择的key（系统设置中需要将wifi提示打开）</td>
</tr>
<tr>
<td>UIAppFonts</td>
<td style="text-align:left">内嵌字体</td>
</tr>
<tr>
<td>UIApplicationExitsOnSuspend</td>
<td style="text-align:left">程序是否在后台运行</td>
</tr>
<tr>
<td>UIBackgroundModes</td>
<td style="text-align:left">后台运行时的服务，具体看iOS4的后台介绍</td>
</tr>
<tr>
<td>UIDeviceFamily</td>
<td style="text-align:left">设备集合,array类型</td>
</tr>
<tr>
<td>UIFileSharingEnabled</td>
<td style="text-align:left">开启itunes共享document文件夹</td>
</tr>
<tr>
<td>UILaunchImageFile</td>
<td style="text-align:left">启动页图片</td>
</tr>
<tr>
<td>UIPrerenderedIcon</td>
<td style="text-align:left">icon上是否有高光</td>
</tr>
<tr>
<td>UIRequiredDeviceCapabilities</td>
<td style="text-align:left">设备需要的功能</td>
</tr>
<tr>
<td>UIStatusBarHidden</td>
<td style="text-align:left">状态栏隐藏（和程序内的区别是在于显示Default.png已经生效）</td>
</tr>
<tr>
<td>UIStatusBarStyle</td>
<td style="text-align:left">状态栏类型</td>
</tr>
<tr>
<td>UIViewEdgeAntialiasing</td>
<td style="text-align:left">是否开启抗锯齿</td>
</tr>
<tr>
<td>CFBundleDisplayName</td>
<td style="text-align:left">app显示名</td>
</tr>
<tr>
<td>CFBundleIconFile</td>
<td style="text-align:left">图标</td>
</tr>
<tr>
<td>CFBundleName</td>
<td style="text-align:left">app显示名短名16个字符以内</td>
</tr>
<tr>
<td>CFBundleVersion</td>
<td style="text-align:left">版本</td>
</tr>
<tr>
<td>CFBundleURLTypes</td>
<td style="text-align:left">自定义url，用于利用url弹回程序</td>
</tr>
<tr>
<td>CFBundleLocalizations</td>
<td style="text-align:left">本地资源的本地化语言，用于itunes页面左下角显示本地话语种</td>
</tr>
<tr>
<td>CFBundleDevelopmentRegion</td>
<td style="text-align:left">也是本地化相关，如果用户所在地没有相应的语言资源，则用这个key的value来作为默认</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;App Transport Security&lt;/td&gt;
&lt;td style=
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>OC之@property</title>
    <link href="http://leii.me/2016/06/04/OC%E4%B9%8B-property/"/>
    <id>http://leii.me/2016/06/04/OC之-property/</id>
    <published>2016-06-04T14:13:51.000Z</published>
    <updated>2016-09-17T03:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>OC的@property本质是一种支持快捷访问成员变量的方法，自动生成setter和getter方法。</p>
<p>声明：在@interface 里声明</p>
<p>声明格式 @property (attributes) type propertyName;</p>
<p>合成：在.m文件里合成</p>
<p>合成格式 @synthesize name = _name;(自动合成，Xcode4.4之后版本不需要写，系统会自动合成)或通过@dynamic，自己</p>
<p>访问权限：在.h中声明成员变量，默认是protected，在.m文件中声明默认是private的。</p>
<p>@synthesize  propertyName = _name；如果变量_name没有声明，系统会自动生成该成员变量且为private权限。如果_name已声明，它们会自动合成。</p>
<p>默认读取方法名为-(type)name 和 -(void)setName也可以改变setter和getter的访问名称。</p>
<p>如：@property  (setter=setMyValue, getter=getBool) NSInteger  value; 此时setValue的方法就会被覆盖。</p>
<h4 id="property的修饰属性-attributes"><a href="#property的修饰属性-attributes" class="headerlink" title="@property的修饰属性(attributes)"></a>@property的修饰属性(attributes)</h4><p>可读性：readwrite/readonly，不写默认为readwrite</p>
<pre><code>readwrite：同时生成setter与getter方法
readonly：只生成getter方法
</code></pre><p>原子性：nonatomic/atomic，不写默认是atomic</p>
<pre><code>atomic：线程安全，表示多线程中只有一个线程能对它访问
nonatomic：非线程安全，但访问速度快
</code></pre><p>内存：assign/retain/copy/weak/strong/unsafe_unretaunied</p>
<p>（Xcode4.2(iOS sdk4.3和以下版本)和以前的版本用retain和assign<br>　　Xcode4.3(iOS 5和以上版本)或之后有了ARC用strong和weak）</p>
<pre><code>assign：简单赋值，不更改引用计数，基础数据类型(如NSInteger,CGFloat)和C数据类型(如int,float)的默认值，非ARC的默认值
retain：使用了引用计数，retain+1，release-1，当引用计数为0时，调用dealloc，内存释放
copy：用于非共享内存，每个指针有自己的内存空间
weak：只作用于ARC,不更改引用计数，作用于对象，当引用计数为0时会将对象置为nil
strong：只作用于ARC，引用计数加1，是对象的默认值
unsafe_unretained：作用于ARC，功能与assign一样，引用计数为0时不会置为nil，可能出现野指针，所以不安全
</code></pre><p>Nullability Annotations：nonnull/nullable/null_resettable，多数为nonnull，包在NS_ASSUME_NONNULL_BEGIN与NS_ASSUME_NONNULL_END中间的默认为nonnull</p>
<p>（llvm 6.1 Xcode6.3中加入，表示是否可以为nil或者NULL，对应swift的？ ！）</p>
<pre><code>nonnull：不能为空
nullable：可以为空
null_resettable：表示 setter nullable，但是 getter nonnull，如@property (null_resettable, nonatomic, strong) UIView *view; 可以被设为nil，但是getter的时候会调用-loadView创建一个非nil的view
</code></pre><p> 为了安全起见，苹果还制定了几条规则：</p>
<blockquote>
<p>1.typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。</p>
<p>2.复杂的指针类型(如id <em>)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id </em> __nonnull”。</p>
<p>3.我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。</p>
</blockquote>
<p>Nullability Annotations的兼容性：</p>
<blockquote>
<p>1.老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。</p>
<p>2.老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。</p>
<p>3.nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。</p>
<p>事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。</p>
</blockquote>
<h4 id="声明临时变量"><a href="#声明临时变量" class="headerlink" title="声明临时变量"></a>声明临时变量</h4><p>用<strong>strong,  </strong>weak, <strong>unsafe_unretained,  </strong>autoreleasing等，用法与上面一样</p>
<p><strong>autoreleasing用法介绍：可以使对象延迟释放。通过传递</strong>autoreleaseing的对象，可以做到在函数内部申请空间，函数外部也可以使用。具体的释放时间取决于runloop创建的autorelease pool，如果autorelease pool释放，则__autorelease 声明的变量都会被释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC的@property本质是一种支持快捷访问成员变量的方法，自动生成setter和getter方法。&lt;/p&gt;
&lt;p&gt;声明：在@interface 里声明&lt;/p&gt;
&lt;p&gt;声明格式 @property (attributes) type propertyName;&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="格物" scheme="http://leii.me/tags/%E6%A0%BC%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>[转]http的session与cookie</title>
    <link href="http://leii.me/2016/06/03/%E8%BD%AC-http%E7%9A%84session%E4%B8%8Ecookie/"/>
    <id>http://leii.me/2016/06/03/转-http的session与cookie/</id>
    <published>2016-06-03T14:05:54.000Z</published>
    <updated>2016-09-20T00:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：虽然session机制在web应用程序中被采用已经很长时间了，但是仍然有很多人不清楚session机制的本质，以至不能正确的应用这一技术。本文将详细讨论session的工作机制并且对在Java web application中应用session机制时常见的问题作出解答。 </p>
<p>目录： </p>
<p>一、术语session </p>
<p>二、HTTP协议与状态保持 </p>
<p>三、理解cookie机制 </p>
<p>四、理解session机制 </p>
<p>五、理解javax.servlet.http.HttpSession </p>
<p>六、HttpSession常见问题 </p>
<p>七、跨应用程序的session共享 </p>
<p>八、总结 </p>
<p>参考文档 </p>
<p>一、术语session </p>
<p>在我的经验里，session这个词被滥用的程度大概仅次于transaction，更加有趣的是transaction与session在某些语境下的含义是相同的。 </p>
<p>session，中文经常翻译为会话，其本来的含义是指有始有终的一系列动作/消息，比如打电话时从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个 session。有时候我们可以看到这样的话“在一个浏览器会话期间，…”，这里的会话一词用的就是其本义，是指从一个浏览器窗口打开到关闭这个期间 ①。最混乱的是“用户（客户端）在一次会话期间”这样一句话，它可能指用户的一系列动作（一般情况下是同某个具体目的相关的一系列动作，比如从登录到选购商品到结账登出这样一个网上购物的过程，有时候也被称为一个transaction），然而有时候也可能仅仅是指一次连接，也有可能是指含义①，其中的差别只能靠上下文来推断②。 </p>
<p>然而当session一词与网络协议相关联时，它又往往隐含了“面向连接”和/或“保持状态”这样两个含义， “面向连接”指的是在通信双方在通信之前要先建立一个通信的渠道，比如打电话，直到对方接了电话通信才能开始，与此相对的是写信，在你把信发出去的时候你并不能确认对方的地址是否正确，通信渠道不一定能建立，但对发信人来说，通信已经开始了。“保持状态”则是指通信的一方能够把一系列的消息关联起来，使得消息之间可以互相依赖，比如一个服务员能够认出再次光临的老顾客并且记得上次这个顾客还欠店里一块钱。这一类的例子有“一个TCP session”或者 “一个POP3 session”③。 </p>
<p>而到了web服务器蓬勃发展的时代，session在web开发语境下的语义又有了新的扩展，它的含义是指一类用来在客户端与服务器之间保持状态的解决方案④。有时候session也用来指这种解决方案的存储结构，如“把xxx保存在session 里”⑤。由于各种用于web开发的语言在一定程度上都提供了对这种解决方案的支持，所以在某种特定语言的语境下，session也被用来指代该语言的解决方案，比如经常把Java里提供的javax.servlet.http.HttpSession简称为session⑥。</p>
<p>鉴于这种混乱已不可改变，本文中session一词的运用也会根据上下文有不同的含义，请大家注意分辨。<br>在本文中，使用中文“浏览器会话期间”来表达含义①，使用“session机制”来表达含义④，使用“session”表达含义⑤，使用具体的“HttpSession”来表达含义⑥ </p>
<p>二、HTTP协议与状态保持 </p>
<p>HTTP 协议本身是无状态的，这与HTTP协议本来的目的是相符的，客户端只需要简单的向服务器请求下载某些文件，无论是客户端还是服务器都没有必要纪录彼此过去的行为，每一次请求之间都是独立的，好比一个顾客和一个自动售货机或者一个普通的（非会员制）大卖场之间的关系一样。 </p>
<p>然而聪明（或者贪心？）的人们很快发现如果能够提供一些按需生成的动态信息会使web变得更加有用，就像给有线电视加上点播功能一样。这种需求一方面迫使HTML逐步添加了表单、脚本、DOM等客户端行为，另一方面在服务器端则出现了CGI规范以响应客户端的动态请求，作为传输载体的HTTP协议也添加了文件上载、 cookie这些特性。其中cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。至于后来出现的session机制则是又一种在客户端与服务器之间保持状态的解决方案。 </p>
<p>让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： </p>
<p>1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 </p>
<p>2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 </p>
<p>3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。 </p>
<p>由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 </p>
<p>三、理解cookie机制<br>cookie机制的基本原理就如上面的例子一样简单，但是还有几个问题需要解决：“会员卡”如何分发；“会员卡”的内容；以及客户如何使用“会员卡”。 </p>
<p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。 </p>
<p>而cookie 的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。意思是麦当劳的会员卡只能在麦当劳的店里出示，如果某家分店还发行了自己的会员卡，那么进这家店的时候除了要出示麦当劳的会员卡，还要出示这家店的会员卡。 </p>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。 </p>
<p>其中域可以指定某一个域比如.google.com，相当于总店招牌，比如宝洁公司，也可以指定一个域下的具体某台机器比如www.google.com或者froogle.google.com，可以用飘柔来做比。<br>路径就是跟在域名后面的URL路径，比如/或者/foo等等，可以用某飘柔专柜做比。<br>路径与域合在一起就构成了cookie的作用范围。 </p>
<p>如果不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览器会话期的 cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。如果设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。 </p>
<p>存储在硬盘上的cookie 可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。对于IE，在一个打开的窗口上按 Ctrl-N（或者从文件菜单）打开的窗口可以与原窗口共享，而使用其他方式新开的IE进程则不能共享已经打开的窗口的内存cookie；对于 Mozilla Firefox0.8，所有的进程和标签页都可以共享同样的cookie。一般来说是用javascript的window.open打开的窗口会与原窗口共享内存cookie。浏览器对于会话cookie的这种只认cookie不认人的处理方式经常给采用session机制的web应用程序开发者造成很大的困扰。 </p>
<p>下面就是一个goolge设置cookie的响应头的例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 302 Found </div><div class="line">Location: http://www.google.com/intl/zh-CN/ </div><div class="line">Set-Cookie: PREF=ID=0565f77e132de138:NW=1:TM=1098082649:LM=1098082649: </div><div class="line">S=KaeaCFPo49RiA_d8; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com </div><div class="line">Content-Type: text/html</div></pre></td></tr></table></figure>
<p>这是使用HTTPLook这个HTTP Sniffer软件来俘获的HTTP通讯纪录的一部分 </p>
<p>浏览器在再次访问goolge的资源时自动向外发送cookie </p>
<p>使用Firefox可以很容易的观察现有的cookie的值<br>使用HTTPLook配合Firefox可以很容易的理解cookie的工作原理。 </p>
<p>IE也可以设置在接受cookie前询问 </p>
<p>这是一个询问接受cookie的对话框。 </p>
<p>四、理解session机制<br>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 </p>
<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id将被在本次响应中返回给客户端保存。 </p>
<p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID，而。比如weblogic对于web应用程序生成的cookie，JSESSIONID= ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是 JSESSIONID。 </p>
<p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为<a href="http://...../xxx;jsessionid=" target="_blank" rel="external">http://...../xxx;jsessionid=</a><br>ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764<br>另一种是作为查询字符串附加在URL后面，表现形式为<a href="http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764" target="_blank" rel="external">http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</a><br>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。<br>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。 </p>
<p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; </div><div class="line">&lt;input type=&quot;text&quot;&gt; </div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>在被传递给客户端之前将被改写成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; </div><div class="line">&lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; </div><div class="line">value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; </div><div class="line">&lt;input type=&quot;text&quot;&gt; </div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>这种技术现在已较少应用，笔者接触过的很古老的iPlanet6(SunONE应用服务器的前身)就使用了这种技术。<br>实际上这种技术可以简单的用对action应用URL重写来代替。 </p>
<p>在谈论session机制的时候，常常听到这样一种误解“只要关闭浏览器，session就消失了”。其实可以想象一下会员卡的例子，除非顾客主动对店家提出销卡，否则店家绝对不会轻易删除顾客的资料。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个 session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够找到原来的session。 </p>
<p>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。 </p>
<p>五、理解javax.servlet.http.HttpSession </p>
<p>HttpSession是Java平台对session机制的实现规范，因为它仅仅是个接口，具体到每个web应用服务器的提供商，除了对规范支持之外，仍然会有一些规范里没有规定的细微差异。这里我们以BEA的Weblogic Server8.1作为例子来演示。 </p>
<p>首先，Weblogic Server提供了一系列的参数来控制它的HttpSession的实现，包括使用cookie的开关选项，使用URL重写的开关选项，session持久化的设置，session失效时间的设置，以及针对cookie的各种设置，比如设置cookie的名字、路径、域， cookie的生存时间等。 </p>
<p>一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用， Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。 </p>
<p>复制严格说来不算持久化保存，因为session实际上还是保存在内存里，不过同样的信息被复制到各个cluster内的服务器进程中，这样即使某个服务器进程停止工作也仍然可以从其他进程中取得session。 </p>
<p>cookie生存时间的设置则会影响浏览器生成的cookie是否是一个会话cookie。默认是使用会话cookie。有兴趣的可以用它来试验我们在第四节里提到的那个误解。 </p>
<p>cookie的路径对于web应用程序来说是一个非常重要的选项，Weblogic Server对这个选项的默认处理方式使得它与其他服务器有明显的区别。后面我们会专题讨论。 </p>
<p>关于session的设置参考[5] <a href="http://e-docs.bea.com/wls/docs70/webapp/weblogic_xml.html#1036869" target="_blank" rel="external">http://e-docs.bea.com/wls/docs70/webapp/weblogic_xml.html#1036869</a> </p>
<p>六、HttpSession常见问题 </p>
<p>（在本小节中session的含义为⑤和⑥的混合） </p>
<p>1、session在何时被创建 </p>
<p>一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;% @page session=”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句 HttpSession session = HttpServletRequest.getSession(true);这也是JSP中隐含的 session对象的来历。 </p>
<p>由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 </p>
<p>2、session何时被删除 </p>
<p>综合前面的讨论，session在下列情况下被删除a.程序调用HttpSession.invalidate();或b.距离上一次收到客户端发送的session id时间间隔超过了session的超时设置;或c.服务器进程被停止（非持久session） </p>
<p>3、如何做到在浏览器关闭时删除session </p>
<p>严格的讲，做不到这一点。可以做一点努力的办法是在所有的客户端页面里使用javascript代码window.oncolose来监视浏览器的关闭动作，然后向服务器发送一个请求来删除session。但是对于浏览器崩溃或者强行杀死进程这些非常规手段仍然无能为力。 </p>
<p>4、有个HttpSessionListener是怎么回事 </p>
<p>你可以创建这样的listener去监控session的创建和销毁事件，使得在发生这样的事件时你可以做一些相应的工作。注意是session的创建和销毁动作触发listener，而不是相反。类似的与HttpSession有关的listener还有 HttpSessionBindingListener，HttpSessionActivationListener和 HttpSessionAttributeListener。 </p>
<p>5、存放在session中的对象必须是可序列化的吗 </p>
<p>不是必需的。要求对象可序列化只是为了session能够在集群中被复制或者能够持久保存或者在必要时server能够暂时把session交换出内存。在 Weblogic Server的session中放置一个不可序列化的对象在控制台上会收到一个警告。我所用过的某个iPlanet版本如果 session中有不可序列化的对象，在session销毁时会有一个Exception，很奇怪。 </p>
<p>6、如何才能正确的应付客户端禁止cookie的可能性 </p>
<p>对所有的URL使用URL重写，包括超链接，form的action，和重定向的URL，具体做法参见[6]<br><a href="http://e-docs.bea.com/wls/docs70/webapp/sessions.html#100770" target="_blank" rel="external">http://e-docs.bea.com/wls/docs70/webapp/sessions.html#100770</a> </p>
<p>7、开两个浏览器窗口访问应用程序会使用同一个session还是不同的session</p>
<p>参见第三小节对cookie的讨论，对session来说是只认id不认人，因此不同的浏览器，不同的窗口打开方式以及不同的cookie存储方式都会对这个问题的答案有影响。 </p>
<p>8、如何防止用户打开两个浏览器窗口操作导致的session混乱</p>
<p>这个问题与防止表单多次提交是类似的，可以通过设置客户端的令牌来解决。就是在服务器每次生成一个不同的id返回给客户端，同时保存在session里，客户端提交表单时必须把这个id也返回服务器，程序首先比较返回的id与保存在session里的值是否一致，如果不一致则说明本次操作已经被提交过了。可以参看《J2EE核心模式》关于表示层模式的部分。需要注意的是对于使用javascript window.open打开的窗口，一般不设置这个id，或者使用单独的id，以防主窗口无法操作，建议不要再window.open打开的窗口里做修改操作，这样就可以不用设置。 </p>
<p>9、为什么在Weblogic Server中改变session的值后要重新调用一次session.setValue </p>
<p>做这个动作主要是为了在集群环境中提示Weblogic Server session中的值发生了改变，需要向其他服务器进程复制新的session值。 </p>
<p>10、为什么session不见了 </p>
<p>排除session正常失效的因素之外，服务器本身的可能性应该是微乎其微的，虽然笔者在iPlanet6SP1加若干补丁的Solaris版本上倒也遇到过；浏览器插件的可能性次之，笔者也遇到过3721插件造成的问题；理论上防火墙或者代理服务器在cookie处理上也有可能会出现问题。<br>出现这一问题的大部分原因都是程序的错误，最常见的就是在一个应用程序中去访问另外一个应用程序。我们在下一节讨论这个问题。 </p>
<p>七、跨应用程序的session共享 </p>
<p>常常有这样的情况，一个大项目被分割成若干小项目开发，为了能够互不干扰，要求每个小项目作为一个单独的web应用程序开发，可是到了最后突然发现某几个小项目之间需要共享一些信息，或者想使用session来实现SSO(single sign on)，在session中保存login的用户信息，最自然的要求是应用程序间能够访问彼此的session。 </p>
<p>然而按照Servlet规范，session的作用范围应该仅仅限于当前应用程序下，不同的应用程序之间是不能够互相访问对方的session的。各个应用服务器从实际效果上都遵守了这一规范，但是实现的细节却可能各有不同，因此解决跨应用程序session共享的方法也各不相同。 </p>
<p>首先来看一下Tomcat是如何实现web应用程序之间session的隔离的，从 Tomcat设置的cookie路径来看，它对不同的应用程序设置的cookie路径是不同的，这样不同的应用程序所用的session id是不同的，因此即使在同一个浏览器窗口里访问不同的应用程序，发送给服务器的session id也可以是不同的。 </p>
<p>根据这个特性，我们可以推测Tomcat中session的内存结构大致如下。 </p>
<p>笔者以前用过的iPlanet也采用的是同样的方式，估计SunONE与iPlanet之间不会有太大的差别。对于这种方式的服务器，解决的思路很简单，实际实行起来也不难。要么让所有的应用程序共享一个session id，要么让应用程序能够获得其他应用程序的session id。 </p>
<p>iPlanet中有一种很简单的方法来实现共享一个session id，那就是把各个应用程序的cookie路径都设为/（实际上应该是/NASApp，对于应用程序来讲它的作用相当于根）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;session-info&gt; </div><div class="line">&lt;path&gt;/NASApp&lt;/path&gt; </div><div class="line">&lt;/session-info&gt;</div></pre></td></tr></table></figure>
<p>需要注意的是，操作共享的session应该遵循一些编程约定，比如在session attribute名字的前面加上应用程序的前缀，使得 setAttribute(“name”, “neo”)变成setAttribute(“app1.name”, “neo”)，以防止命名空间冲突，导致互相覆盖。 </p>
<p>在Tomcat中则没有这么方便的选择。在Tomcat版本3上，我们还可以有一些手段来共享session。对于版本4以上的Tomcat，目前笔者尚未发现简单的办法。只能借助于第三方的力量，比如使用文件、数据库、JMS或者客户端cookie，URL参数或者隐藏字段等手段。 </p>
<p>我们再看一下Weblogic Server是如何处理session的。 </p>
<p>从截屏画面上可以看到Weblogic Server对所有的应用程序设置的cookie的路径都是/，这是不是意味着在Weblogic Server中默认的就可以共享session了呢？然而一个小实验即可证明即使不同的应用程序使用的是同一个session，各个应用程序仍然只能访问自己所设置的那些属性。这说明Weblogic Server中的session的内存结构可能如下 </p>
<p>对于这样一种结构，在 session机制本身上来解决session共享的问题应该是不可能的了。除了借助于第三方的力量，比如使用文件、数据库、JMS或者客户端 cookie，URL参数或者隐藏字段等手段，还有一种较为方便的做法，就是把一个应用程序的session放到ServletContext中，这样另外一个应用程序就可以从ServletContext中取得前一个应用程序的引用。示例代码如下， </p>
<p>应用程序A </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">context.setAttribute(&quot;appA&quot;, session);</div></pre></td></tr></table></figure>
<p>应用程序B </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contextA = context.getContext(&quot;/appA&quot;); </div><div class="line">HttpSession sessionA = (HttpSession)contextA.getAttribute(&quot;appA&quot;);</div></pre></td></tr></table></figure>
<p>值得注意的是这种用法不可移植，因为根据ServletContext的JavaDoc，应用服务器可以处于安全的原因对于context.getContext(“/appA”);返回空值，以上做法在Weblogic Server 8.1中通过。 </p>
<p>那么Weblogic Server为什么要把所有的应用程序的cookie路径都设为/呢？原来是为了SSO，凡是共享这个session的应用程序都可以共享认证的信息。一个简单的实验就可以证明这一点，修改首先登录的那个应用程序的描述符weblogic.xml，把cookie路径修改为/appA 访问另外一个应用程序会重新要求登录，即使是反过来，先访问cookie路径为/的应用程序，再访问修改过路径的这个，虽然不再提示登录，但是登录的用户信息也会丢失。注意做这个实验时认证方式应该使用FORM，因为浏览器和web服务器对basic认证方式有其他的处理方式，第二次请求的认证不是通过 session来实现的。</p>
<p>具体请参看[7] secion 14.8 Authorization，你可以修改所附的示例程序来做这些试验。</p>
<p>八、总结 </p>
<p>session机制本身并不复杂，然而其实现和配置上的灵活性却使得具体情况复杂多变。这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的经验，而是始终需要具体情况具体分析。 </p>
<p>摘要：虽然session机制在web应用程序中被采用已经很长时间了，但是仍然有很多人不清楚session机制的本质，以至不能正确的应用这一技术。本文将详细讨论session的工作机制并且对在Java web application中应用session机制时常见的问题作出解答</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：虽然session机制在web应用程序中被采用已经很长时间了，但是仍然有很多人不清楚session机制的本质，以至不能正确的应用这一技术。本文将详细讨论session的工作机制并且对在Java web application中应用session机制时常见的问题作出解答
    
    </summary>
    
      <category term="Base" scheme="http://leii.me/categories/Base/"/>
    
    
      <category term="转" scheme="http://leii.me/tags/%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>苹果高德百度定位坐标转换</title>
    <link href="http://leii.me/2016/06/03/%E8%8B%B9%E6%9E%9C%E9%AB%98%E5%BE%B7%E7%99%BE%E5%BA%A6%E5%AE%9A%E4%BD%8D%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <id>http://leii.me/2016/06/03/苹果高德百度定位坐标转换/</id>
    <published>2016-06-03T12:41:28.000Z</published>
    <updated>2016-09-13T08:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84"><a href="#苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84" class="headerlink" title="苹果的CLLocationManager定位得到的是世界标准地理坐标(WGS-84)"></a>苹果的CLLocationManager定位得到的是世界标准地理坐标(WGS-84)</h4><h4 id="高德SDK定位得到的是火星坐标（GCJ-02）"><a href="#高德SDK定位得到的是火星坐标（GCJ-02）" class="headerlink" title="高德SDK定位得到的是火星坐标（GCJ-02）"></a>高德SDK定位得到的是火星坐标（GCJ-02）</h4><h4 id="百度SDK定位得到的是百度地理坐标（BD-09）"><a href="#百度SDK定位得到的是百度地理坐标（BD-09）" class="headerlink" title="百度SDK定位得到的是百度地理坐标（BD-09）"></a>百度SDK定位得到的是百度地理坐标（BD-09）</h4><p>有的项目里因为老的代码或者第三方库用的SDK不一样，也可能后端使用的定位SDK更换，都会需要坐标的转换来兼容老版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">#define LAT_OFFSET_0(x,y) -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x))  </div><div class="line">#define LAT_OFFSET_1 (20.0 * sin(6.0 * x * M_PI) + 20.0 * sin(2.0 * x * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LAT_OFFSET_2 (20.0 * sin(y * M_PI) + 40.0 * sin(y / 3.0 * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LAT_OFFSET_3 (160.0 * sin(y / 12.0 * M_PI) + 320 * sin(y * M_PI / 30.0)) * 2.0 / 3.0  </div><div class="line">  </div><div class="line">#define LON_OFFSET_0(x,y) 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x))  </div><div class="line">#define LON_OFFSET_1 (20.0 * sin(6.0 * x * M_PI) + 20.0 * sin(2.0 * x * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LON_OFFSET_2 (20.0 * sin(x * M_PI) + 40.0 * sin(x / 3.0 * M_PI)) * 2.0 / 3.0  </div><div class="line">#define LON_OFFSET_3 (150.0 * sin(x / 12.0 * M_PI) + 300.0 * sin(x / 30.0 * M_PI)) * 2.0 / 3.0  </div><div class="line">  </div><div class="line">#define RANGE_LON_MAX 137.8347  </div><div class="line">#define RANGE_LON_MIN 72.004  </div><div class="line">#define RANGE_LAT_MAX 55.8271  </div><div class="line">#define RANGE_LAT_MIN 0.8293  </div><div class="line">// jzA = 6378245.0, 1/f = 298.3  </div><div class="line">// b = a * (1 - f)  </div><div class="line">// ee = (a^2 - b^2) / a^2;  </div><div class="line">#define jzA 6378245.0  </div><div class="line">#define jzEE 0.00669342162296594323  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">//判断是不是在中国  </div><div class="line">+(BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271)  </div><div class="line">        return YES;  </div><div class="line">    return NO;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (double)transformLat:(double)x BDLon:(double)y  </div><div class="line">&#123;  </div><div class="line">    double ret = LAT_OFFSET_0(x, y);  </div><div class="line">    ret += LAT_OFFSET_1;  </div><div class="line">    ret += LAT_OFFSET_2;  </div><div class="line">    ret += LAT_OFFSET_3;  </div><div class="line">    return ret;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (double)transformLon:(double)x BDLon:(double)y  </div><div class="line">&#123;  </div><div class="line">    double ret = LON_OFFSET_0(x, y);  </div><div class="line">    ret += LON_OFFSET_1;  </div><div class="line">    ret += LON_OFFSET_2;  </div><div class="line">    ret += LON_OFFSET_3;  </div><div class="line">    return ret;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (BOOL)outOfChina:(double)lat BDLon:(double)lon  </div><div class="line">&#123;  </div><div class="line">    if (lon &lt; RANGE_LON_MIN || lon &gt; RANGE_LON_MAX)  </div><div class="line">        return true;  </div><div class="line">    if (lat &lt; RANGE_LAT_MIN || lat &gt; RANGE_LAT_MAX)  </div><div class="line">        return true;  </div><div class="line">    return false;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02Encrypt:(double)ggLat BDLon:(double)ggLon  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D resPoint;  </div><div class="line">    double mgLat;  </div><div class="line">    double mgLon;  </div><div class="line">    if ([self outOfChina:ggLat BDLon:ggLon]) &#123;  </div><div class="line">        resPoint.latitude = ggLat;  </div><div class="line">        resPoint.longitude = ggLon;  </div><div class="line">        return resPoint;  </div><div class="line">    &#125;  </div><div class="line">    double dLat = [self transformLat:(ggLon - 105.0)BDLon:(ggLat - 35.0)];  </div><div class="line">    double dLon = [self transformLon:(ggLon - 105.0) BDLon:(ggLat - 35.0)];  </div><div class="line">    double radLat = ggLat / 180.0 * M_PI;  </div><div class="line">    double magic = sin(radLat);  </div><div class="line">    magic = 1 - jzEE * magic * magic;  </div><div class="line">    double sqrtMagic = sqrt(magic);  </div><div class="line">    dLat = (dLat * 180.0) / ((jzA * (1 - jzEE)) / (magic * sqrtMagic) * M_PI);  </div><div class="line">    dLon = (dLon * 180.0) / (jzA / sqrtMagic * cos(radLat) * M_PI);  </div><div class="line">    mgLat = ggLat + dLat;  </div><div class="line">    mgLon = ggLon + dLon;  </div><div class="line">      </div><div class="line">    resPoint.latitude = mgLat;  </div><div class="line">    resPoint.longitude = mgLon;  </div><div class="line">    return resPoint;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02Decrypt:(double)gjLat gjLon:(double)gjLon &#123;  </div><div class="line">    CLLocationCoordinate2D  gPt = [self GCJ02Encrypt:gjLat BDLon:gjLon];  </div><div class="line">    double dLon = gPt.longitude - gjLon;  </div><div class="line">    double dLat = gPt.latitude - gjLat;  </div><div class="line">    CLLocationCoordinate2D pt;  </div><div class="line">    pt.latitude = gjLat - dLat;  </div><div class="line">    pt.longitude = gjLon - dLon;  </div><div class="line">    return pt;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)BD09Decrypt:(double)BDLat BDLon:(double)BDLon  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D GCJPt;  </div><div class="line">    double x = BDLon - 0.0065, y = BDLat - 0.006;  </div><div class="line">    double z = sqrt(x * x + y * y) - 0.00002 * sin(y * M_PI);  </div><div class="line">    double theta = atan2(y, x) - 0.000003 * cos(x * M_PI);  </div><div class="line">    GCJPt.longitude = z * cos(theta);  </div><div class="line">    GCJPt.latitude = z * sin(theta);  </div><div class="line">    return GCJPt;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+(CLLocationCoordinate2D)BD09Encrypt:(double)ggLat BDLon:(double)ggLon  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D BDPt;  </div><div class="line">    double x = ggLon, y = ggLat;  </div><div class="line">    double z = sqrt(x * x + y * y) + 0.00002 * sin(y * M_PI);  </div><div class="line">    double theta = atan2(y, x) + 0.000003 * cos(x * M_PI);  </div><div class="line">    BDPt.longitude = z * cos(theta) + 0.0065;  </div><div class="line">    BDPt.latitude = z * sin(theta) + 0.006;  </div><div class="line">    return BDPt;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">//6种转换</div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)WGS84ToGCJ02:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return [self GCJ02Encrypt:location.latitude BDLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02ToWGS84:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return [self GCJ02Decrypt:location.latitude gjLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)WGS84ToBD09:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D GCJ02Pt = [self GCJ02Encrypt:location.latitude  </div><div class="line">                                                  BDLon:location.longitude];  </div><div class="line">    return [self BD09Encrypt:GCJ02Pt.latitude BDLon:GCJ02Pt.longitude] ;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)GCJ02ToBD09:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return  [self BD09Encrypt:location.latitude BDLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)BD09ToGCJ02:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    return [self BD09Decrypt:location.latitude BDLon:location.longitude];  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">+ (CLLocationCoordinate2D)BD09ToWGS84:(CLLocationCoordinate2D)location  </div><div class="line">&#123;  </div><div class="line">    CLLocationCoordinate2D GCJ02 = [self BD09ToGCJ02:location];  </div><div class="line">    return [self GCJ02Decrypt:GCJ02.latitude gjLon:GCJ02.longitude];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84&quot;&gt;&lt;a href=&quot;#苹果的CLLocationManager定位得到的是世界标准地理坐标-WGS-84&quot; class=&quot;headerlink&quot; title=&quot;苹果的CLLocat
    
    </summary>
    
      <category term="iOS" scheme="http://leii.me/categories/iOS/"/>
    
    
      <category term="笔记" scheme="http://leii.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>大学时的渣画</title>
    <link href="http://leii.me/2016/05/18/%E5%A4%A7%E5%AD%A6%E6%97%B6%E7%9A%84%E6%B8%A3%E7%94%BB/"/>
    <id>http://leii.me/2016/05/18/大学时的渣画/</id>
    <published>2016-05-18T11:39:42.000Z</published>
    <updated>2016-09-14T13:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>好怀念当初在校自己做手游找不到美术，然后一手键盘一手数位板的日子，虽然一直没有什么进步也没时间系统的学一下 ╮(╯_╰)╭  </p>
<p><img src="http://imglf2.nosdn.127.net/img/SnJLZEdtSzE0OVJrRWZFS1FsSmhHNE9lUnlXUnhDTEQ.png?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg"></p>
<p><img src="http://imglf1.nosdn.127.net/img/SnJLZEdtSzE0OVRFblo1aGh4aE0rUUhSUkgyM2RhUVY.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好怀念当初在校自己做手游找不到美术，然后一手键盘一手数位板的日子，虽然一直没有什么进步也没时间系统的学一下 ╮(╯_╰)╭  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/SnJLZEdtSzE0OVJrRWZFS1Fs
    
    </summary>
    
      <category term="Design" scheme="http://leii.me/categories/Design/"/>
    
    
  </entry>
  
  <entry>
    <title>开张</title>
    <link href="http://leii.me/2016/05/17/%E5%BC%80%E5%BC%A0/"/>
    <id>http://leii.me/2016/05/17/开张/</id>
    <published>2016-05-17T01:04:15.000Z</published>
    <updated>2016-09-13T08:01:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间突然心血来潮画了这两张公司LOGO的同人画，唉~毕业了两年第一次翻出数位板，居然还没有坏，感觉像是和多年不见的老朋友又见面了，感慨万千，虽然画的还是这么渣不过这种创作的快感依然不减，以后码代码的时间需要平衡一下了，毕竟多维的人生才更有乐趣。</p>
<p>CSDN简书博客园显然技术氛围太浓分享技术以外的东西都感觉很违和，以后各种类型的作品都可以放在这个个人博客里了哈哈哈</p>
<p><img src="http://imglf1.nosdn.127.net/img/SnJLZEdtSzE0OVFaSzRVL1RTWXVaVm9KZ2xtdDJ5VVoyT0dhd3pWWmxXbVVxSUc0SmRrdG5RPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg"></p>
<p><img src="http://imglf.nosdn.127.net/img/SnJLZEdtSzE0OVFaSzRVL1RTWXVaZGNhRmdYWGlsOGIwbEhPY052ZnhRZ0VZeDhxeU1acDJRPT0.jpg?imageView&thumbnail=1680x0&quality=96&stripmeta=0&type=jpg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间突然心血来潮画了这两张公司LOGO的同人画，唉~毕业了两年第一次翻出数位板，居然还没有坏，感觉像是和多年不见的老朋友又见面了，感慨万千，虽然画的还是这么渣不过这种创作的快感依然不减，以后码代码的时间需要平衡一下了，毕竟多维的人生才更有乐趣。&lt;/p&gt;
&lt;p&gt;CSDN简
    
    </summary>
    
      <category term="Design" scheme="http://leii.me/categories/Design/"/>
    
    
  </entry>
  
</feed>
